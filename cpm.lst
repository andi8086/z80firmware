              	; --------------------------------------
              	; zasm: assemble "cpm.s"
              	; date: 2019-12-06 00:38:26
              	; --------------------------------------


              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*	    adapted by A. J. Reichel in 2019
              	;**************************************************************
              	;
              	;   Set memory limit here. This is the amount of contigeous
              	; ram starting from 0000. CP/M will reside at the end of this space.
              	;
0040:         	MEM	EQU	64		;for a 62k system (TS802 TEST - WORKS OK).
              	;
0003:         	IOBYTE	EQU	3		;i/o definition byte.
0004:         	TDRIVE	EQU	4		;current drive name and user number.
EC06:         	ENTRY	EQU	FBASE		;entry point for the cp/m bdos.
005C:         	TFCB	EQU	5CH		;default file control block.
0080:         	TBUFF	EQU	80H		;i/o buffer and command line storage.
0100:         	TBASE	EQU	100H		;transiant program storage area.
              	;
              	;   Set control character equates.
              	;
0003:         	CNTRLC	EQU	3		;control-c
0005:         	CNTRLE	EQU	05H		;control-e
0008:         	BS	EQU	08H		;backspace
0009:         	TAB	EQU	09H		;tab
000A:         	LF	EQU	0AH		;line feed
000C:         	FF	EQU	0CH		;form feed
000D:         	CR	EQU	0DH		;carriage return
0010:         	CNTRLP	EQU	10H		;control-p
0012:         	CNTRLR	EQU	12H		;control-r
0013:         	CNTRLS	EQU	13H		;control-s
0015:         	CNTRLU	EQU	15H		;control-u
0018:         	CNTRLX	EQU	18H		;control-x
001A:         	CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
007F:         	DEL	EQU	7FH		;rubout
              	;
              	;   Set origin for CP/M
              	;
E400:         		ORG	(MEM-7)*1024
              	
E400: C35CE7  	CBASE:	JP	COMMAND		;execute command processor (ccp).
E403: C358E7  		JP	CLEARBUF	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   Standard cp/m ccp input buffer. Format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
E406: 7F      	INBUFF:	DEFB	127		;length of input buffer.
E407: 00      		DEFB	0		;current length of contents.
E408: 436F7079		DEFB	'Copyright'
E40C: 72696768	
E410: 74      	
E411: 20313937		DEFB	' 1979 (c) by Digital Research      '
E415: 39202863	
E419: 29206279	
E41D: 20446967	
E421: 6974616C	
E425: 20526573	
E429: 65617263	
E42D: 68202020	
E431: 202020  	
E434: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E438: 00...   	
E44B: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E44F: 00...   	
E462: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E466: 00...   	
E479: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E47D: 00...   	
E488: 08E4    	INPOINT:DEFW	INBUFF+2	;input line pointer
E48A: 0000    	NAMEPNT:DEFW	0		;input line pointer used for error message. Points to
              	;			;start of name in error.
              	;
              	;   Routine to print (A) on the console. All registers used.
              	;
E48C: 5F      	PRINT:	LD	E,A		;setup bdos call.
E48D: 0E02    		LD	C,2
E48F: C306EC  		JP	ENTRY
              	;
              	;   Routine to print (A) on the console and to save (BC).
              	;
E492: C5      	PRINTB:	PUSH	BC
E493: CD8CE4  		CALL	PRINT
E496: C1      		POP	BC
E497: C9      		RET
              	;
              	;   Routine to send a carriage return, line feed combination
              	; to the console.
              	;
E498: 3E0D    	CRLF:	LD	A,CR
E49A: CD92E4  		CALL	PRINTB
E49D: 3E0A    		LD	A,LF
E49F: C392E4  		JP	PRINTB
              	;
              	;   Routine to send one space to the console and save (BC).
              	;
E4A2: 3E20    	SPACE:	LD	A,' '
E4A4: C392E4  		JP	PRINTB
              	;
              	;   Routine to print character string pointed to be (BC) on the
              	; console. It must terminate with a null byte.
              	;
E4A7: C5      	PLINE:	PUSH	BC
E4A8: CD98E4  		CALL	CRLF
E4AB: E1      		POP	HL
E4AC: 7E      	PLINE2:	LD	A,(HL)
E4AD: B7      		OR	A
E4AE: C8      		RET	Z
E4AF: 23      		INC	HL
E4B0: E5      		PUSH	HL
E4B1: CD8CE4  		CALL	PRINT
E4B4: E1      		POP	HL
E4B5: C3ACE4  		JP	PLINE2
              	;
              	;   Routine to reset the disk system.
              	;
E4B8: 0E0D    	RESDSK:	LD	C,13
E4BA: C306EC  		JP	ENTRY
              	;
              	;   Routine to select disk (A).
              	;
E4BD: 5F      	DSKSEL:	LD	E,A
E4BE: 0E0E    		LD	C,14
E4C0: C306EC  		JP	ENTRY
              	;
              	;   Routine to call bdos and save the return code. The zero
              	; flag is set on a return of 0ffh.
              	;
E4C3: CD06EC  	ENTRY1:	CALL	ENTRY
E4C6: 32EEEB  		LD	(RTNCODE),A	;save return code.
E4C9: 3C      		INC	A		;set zero if 0ffh returned.
E4CA: C9      		RET
              	;
              	;   Routine to open a file. (DE) must point to the FCB.
              	;
E4CB: 0E0F    	OPEN:	LD	C,15
E4CD: C3C3E4  		JP	ENTRY1
              	;
              	;   Routine to open file at (FCB).
              	;
E4D0: AF      	OPENFCB:XOR	A		;clear the record number byte at fcb+32
E4D1: 32EDEB  		LD	(FCB+32),A
E4D4: 11CDEB  		LD	DE,FCB
E4D7: C3CBE4  		JP	OPEN
              	;
              	;   Routine to close a file. (DE) points to FCB.
              	;
E4DA: 0E10    	CLOSE:	LD	C,16
E4DC: C3C3E4  		JP	ENTRY1
              	;
              	;   Routine to search for the first file with ambigueous name
              	; (DE).
              	;
E4DF: 0E11    	SRCHFST:LD	C,17
E4E1: C3C3E4  		JP	ENTRY1
              	;
              	;   Search for the next ambigeous file name.
              	;
E4E4: 0E12    	SRCHNXT:LD	C,18
E4E6: C3C3E4  		JP	ENTRY1
              	;
              	;   Search for file at (FCB).
              	;
E4E9: 11CDEB  	SRCHFCB:LD	DE,FCB
E4EC: C3DFE4  		JP	SRCHFST
              	;
              	;   Routine to delete a file pointed to by (DE).
              	;
E4EF: 0E13    	DELETE:	LD	C,19
E4F1: C306EC  		JP	ENTRY
              	;
              	;   Routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
E4F4: CD06EC  	ENTRY2:	CALL	ENTRY
E4F7: B7      		OR	A		;set zero flag if appropriate.
E4F8: C9      		RET
              	;
              	;   Routine to read the next record from a sequential file.
              	; (DE) points to the FCB.
              	;
E4F9: 0E14    	RDREC:	LD	C,20
E4FB: C3F4E4  		JP	ENTRY2
              	;
              	;   Routine to read file at (FCB).
              	;
E4FE: 11CDEB  	READFCB:LD	DE,FCB
E501: C3F9E4  		JP	RDREC
              	;
              	;   Routine to write the next record of a sequential file.
              	; (DE) points to the FCB.
              	;
E504: 0E15    	WRTREC:	LD	C,21
E506: C3F4E4  		JP	ENTRY2
              	;
              	;   Routine to create the file pointed to by (DE).
              	;
E509: 0E16    	CREATE:	LD	C,22
E50B: C3C3E4  		JP	ENTRY1
              	;
              	;   Routine to rename the file pointed to by (DE). Note that
              	; the new name starts at (DE+16).
              	;
E50E: 0E17    	RENAM:	LD	C,23
E510: C306EC  		JP	ENTRY
              	;
              	;   Get the current user code.
              	;
E513: 1EFF    	GETUSR:	LD	E,0FFH
              	;
              	;   Routne to get or set the current user code.
              	; If (E) is FF then this is a GET, else it is a SET.
              	;
E515: 0E20    	GETSETUC: LD	C,32
E517: C306EC  		JP	ENTRY
              	;
              	;   Routine to set the current drive byte at (TDRIVE).
              	;
E51A: CD13E5  	SETCDRV:CALL	GETUSR		;get user number
E51D: 87      		ADD	A,A		;and shift into the upper 4 bits.
E51E: 87      		ADD	A,A
E51F: 87      		ADD	A,A
E520: 87      		ADD	A,A
E521: 21EFEB  		LD	HL,CDRIVE	;now add in the current drive number.
E524: B6      		OR	(HL)
E525: 320400  		LD	(TDRIVE),A	;and save.
E528: C9      		RET
              	;
              	;   Move currently active drive down to (TDRIVE).
              	;
E529: 3AEFEB  	MOVECD:	LD	A,(CDRIVE)
E52C: 320400  		LD	(TDRIVE),A
E52F: C9      		RET
              	;
              	;   Routine to convert (A) into upper case ascii. Only letters
              	; are affected.
              	;
E530: FE61    	UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
E532: D8      		RET	C
E533: FE7B    		CP	'{'
E535: D0      		RET	NC
E536: E65F    		AND	5FH		;convert it if found.
E538: C9      		RET
              	;
              	;   Routine to get a line of input. We must check to see if the
              	; user is in (BATCH) mode. If so, then read the input from file
              	; ($$$.SUB). At the end, reset to console input.
              	;
E539: 3AABEB  	GETINP:	LD	A,(BATCH)	;if =0, then use console input.
E53C: B7      		OR	A
E53D: CA96E5  		JP	Z,GETINP1
              	;
              	;   Use the submit file ($$$.sub) which is prepared by a
              	; SUBMIT run. It must be on drive (A) and it will be deleted
              	; if and error occures (like eof).
              	;
E540: 3AEFEB  		LD	A,(CDRIVE)	;select drive 0 if need be.
E543: B7      		OR	A
E544: 3E00    		LD	A,0		;always use drive A for submit.
E546: C4BDE4  		CALL	NZ,DSKSEL	;select it if required.
E549: 11ACEB  		LD	DE,BATCHFCB
E54C: CDCBE4  		CALL	OPEN		;look for it.
E54F: CA96E5  		JP	Z,GETINP1	;if not there, use normal input.
E552: 3ABBEB  		LD	A,(BATCHFCB+15)	;get last record number+1.
E555: 3D      		DEC	A
E556: 32CCEB  		LD	(BATCHFCB+32),A
E559: 11ACEB  		LD	DE,BATCHFCB
E55C: CDF9E4  		CALL	RDREC		;read last record.
E55F: C296E5  		JP	NZ,GETINP1	;quit on end of file.
              	;
              	;   Move this record into input buffer.
              	;
E562: 1107E4  		LD	DE,INBUFF+1
E565: 218000  		LD	HL,TBUFF	;data was read into buffer here.
E568: 0680    		LD	B,128		;all 128 characters may be used.
E56A: CD42E8  		CALL	HL2DE		;(HL) to (DE), (B) bytes.
E56D: 21BAEB  		LD	HL,BATCHFCB+14
E570: 3600    		LD	(HL),0		;zero out the 's2' byte.
E572: 23      		INC	HL		;and decrement the record count.
E573: 35      		DEC	(HL)
E574: 11ACEB  		LD	DE,BATCHFCB	;close the batch file now.
E577: CDDAE4  		CALL	CLOSE
E57A: CA96E5  		JP	Z,GETINP1	;quit on an error.
E57D: 3AEFEB  		LD	A,(CDRIVE)	;re-select previous drive if need be.
E580: B7      		OR	A
E581: C4BDE4  		CALL	NZ,DSKSEL	;don't do needless selects.
              	;
              	;   Print line just read on console.
              	;
E584: 2108E4  		LD	HL,INBUFF+2
E587: CDACE4  		CALL	PLINE2
E58A: CDC2E5  		CALL	CHKCON		;check console, quit on a key.
E58D: CAA7E5  		JP	Z,GETINP2	;jump if no key is pressed.
              	;
              	;   Terminate the submit job on any keyboard input. Delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
E590: CDDDE5  		CALL	DELBATCH	;delete the batch file.
E593: C382E7  		JP	CMMND1		;and restart command input.
              	;
              	;   Get here for normal keyboard input. Delete the submit file
              	; incase there was one.
              	;
E596: CDDDE5  	GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
E599: CD1AE5  		CALL	SETCDRV		;reset active disk.
E59C: 0E0A    		LD	C,10		;get line from console device.
E59E: 1106E4  		LD	DE,INBUFF
E5A1: CD06EC  		CALL	ENTRY
E5A4: CD29E5  		CALL	MOVECD		;reset current drive (again).
              	;
              	;   Convert input line to upper case.
              	;
E5A7: 2107E4  	GETINP2:LD	HL,INBUFF+1
E5AA: 46      		LD	B,(HL)		;(B)=character counter.
E5AB: 23      	GETINP3:INC	HL
E5AC: 78      		LD	A,B		;end of the line?
E5AD: B7      		OR	A
E5AE: CABAE5  		JP	Z,GETINP4
E5B1: 7E      		LD	A,(HL)		;convert to upper case.
E5B2: CD30E5  		CALL	UPPER
E5B5: 77      		LD	(HL),A
E5B6: 05      		DEC	B		;adjust character count.
E5B7: C3ABE5  		JP	GETINP3
E5BA: 77      	GETINP4:LD	(HL),A		;add trailing null.
E5BB: 2108E4  		LD	HL,INBUFF+2
E5BE: 2288E4  		LD	(INPOINT),HL	;reset input line pointer.
E5C1: C9      		RET
              	;
              	;   Routine to check the console for a key pressed. The zero
              	; flag is set is none, else the character is returned in (A).
              	;
E5C2: 0E0B    	CHKCON:	LD	C,11		;check console.
E5C4: CD06EC  		CALL	ENTRY
E5C7: B7      		OR	A
E5C8: C8      		RET	Z		;return if nothing.
E5C9: 0E01    		LD	C,1		;else get character.
E5CB: CD06EC  		CALL	ENTRY
E5CE: B7      		OR	A		;clear zero flag and return.
E5CF: C9      		RET
              	;
              	;   Routine to get the currently active drive number.
              	;
E5D0: 0E19    	GETDSK:	LD	C,25
E5D2: C306EC  		JP	ENTRY
              	;
              	;   Set the stabdard dma address.
              	;
E5D5: 118000  	STDDMA:	LD	DE,TBUFF
              	;
              	;   Routine to set the dma address to (DE).
              	;
E5D8: 0E1A    	DMASET:	LD	C,26
E5DA: C306EC  		JP	ENTRY
              	;
              	;  Delete the batch file created by SUBMIT.
              	;
E5DD: 21ABEB  	DELBATCH: LD	HL,BATCH	;is batch active?
E5E0: 7E      		LD	A,(HL)
E5E1: B7      		OR	A
E5E2: C8      		RET	Z
E5E3: 3600    		LD	(HL),0		;yes, de-activate it.
E5E5: AF      		XOR	A
E5E6: CDBDE4  		CALL	DSKSEL		;select drive 0 for sure.
E5E9: 11ACEB  		LD	DE,BATCHFCB	;and delete this file.
E5EC: CDEFE4  		CALL	DELETE
E5EF: 3AEFEB  		LD	A,(CDRIVE)	;reset current drive.
E5F2: C3BDE4  		JP	DSKSEL
              	;
              	;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
              	; the same or we halt....
              	;
E5F5: 1128E7  	VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
E5F8: 2100EC  		LD	HL,PATTRN2	;ditto, but how could they be different?
E5FB: 0606    		LD	B,6		;6 bytes each.
E5FD: 1A      	VERIFY1:LD	A,(DE)
E5FE: BE      		CP	(HL)
E5FF: C2CFE7  		JP	NZ,HALT		;jump to halt routine.
E602: 13      		INC	DE
E603: 23      		INC	HL
E604: 05      		DEC	B
E605: C2FDE5  		JP	NZ,VERIFY1
E608: C9      		RET
              	;
              	;   Print back file name with a '?' to indicate a syntax error.
              	;
E609: CD98E4  	SYNERR:	CALL	CRLF		;end current line.
E60C: 2A8AE4  		LD	HL,(NAMEPNT)	;this points to name in error.
E60F: 7E      	SYNERR1:LD	A,(HL)		;print it until a space or null is found.
E610: FE20    		CP	' '
E612: CA22E6  		JP	Z,SYNERR2
E615: B7      		OR	A
E616: CA22E6  		JP	Z,SYNERR2
E619: E5      		PUSH	HL
E61A: CD8CE4  		CALL	PRINT
E61D: E1      		POP	HL
E61E: 23      		INC	HL
E61F: C30FE6  		JP	SYNERR1
E622: 3E3F    	SYNERR2:LD	A,'?'		;add trailing '?'.
E624: CD8CE4  		CALL	PRINT
E627: CD98E4  		CALL	CRLF
E62A: CDDDE5  		CALL	DELBATCH	;delete any batch file.
E62D: C382E7  		JP	CMMND1		;and restart from console input.
              	;
              	;   Check character at (DE) for legal command input. Note that the
              	; zero flag is set if the character is a delimiter.
              	;
E630: 1A      	CHECK:	LD	A,(DE)
E631: B7      		OR	A
E632: C8      		RET	Z
E633: FE20    		CP	' '		;control characters are not legal here.
E635: DA09E6  		JP	C,SYNERR
E638: C8      		RET	Z		;check for valid delimiter.
E639: FE3D    		CP	'='
E63B: C8      		RET	Z
E63C: FE5F    		CP	'_'
E63E: C8      		RET	Z
E63F: FE2E    		CP	'.'
E641: C8      		RET	Z
E642: FE3A    		CP	':'
E644: C8      		RET	Z
E645: FE3B    		CP	';'
E647: C8      		RET	Z
E648: FE3C    		CP	'<'
E64A: C8      		RET	Z
E64B: FE3E    		CP	'>'
E64D: C8      		RET	Z
E64E: C9      		RET
              	;
              	;   Get the next non-blank character from (DE).
              	;
E64F: 1A      	NONBLANK: LD	A,(DE)
E650: B7      		OR	A		;string ends with a null.
E651: C8      		RET	Z
E652: FE20    		CP	' '
E654: C0      		RET	NZ
E655: 13      		INC	DE
E656: C34FE6  		JP	NONBLANK
              	;
              	;   Add (HL)=(HL)+(A)
              	;
E659: 85      	ADDHL:	ADD	A,L
E65A: 6F      		LD	L,A
E65B: D0      		RET	NC		;take care of any carry.
E65C: 24      		INC	H
E65D: C9      		RET
              	;
              	;   Convert the first name in (FCB).
              	;
E65E: 3E00    	CONVFST:LD	A,0
              	;
              	;   Format a file name (convert * to '?', etc.). On return,
              	; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
E660: 21CDEB  	CONVERT:LD	HL,FCB
E663: CD59E6  		CALL	ADDHL
E666: E5      		PUSH	HL
E667: E5      		PUSH	HL
E668: AF      		XOR	A
E669: 32F0EB  		LD	(CHGDRV),A	;initialize drive change flag.
E66C: 2A88E4  		LD	HL,(INPOINT)	;set (HL) as pointer into input line.
E66F: EB      		EX	DE,HL
E670: CD4FE6  		CALL	NONBLANK	;get next non-blank character.
E673: EB      		EX	DE,HL
E674: 228AE4  		LD	(NAMEPNT),HL	;save pointer here for any error message.
E677: EB      		EX	DE,HL
E678: E1      		POP	HL
E679: 1A      		LD	A,(DE)		;get first character.
E67A: B7      		OR	A
E67B: CA89E6  		JP	Z,CONVRT1
E67E: DE40    		SBC	A,'A'-1		;might be a drive name, convert to binary.
E680: 47      		LD	B,A		;and save.
E681: 13      		INC	DE		;check next character for a ':'.
E682: 1A      		LD	A,(DE)
E683: FE3A    		CP	':'
E685: CA90E6  		JP	Z,CONVRT2
E688: 1B      		DEC	DE		;nope, move pointer back to the start of the line.
E689: 3AEFEB  	CONVRT1:LD	A,(CDRIVE)
E68C: 77      		LD	(HL),A
E68D: C396E6  		JP	CONVRT3
E690: 78      	CONVRT2:LD	A,B
E691: 32F0EB  		LD	(CHGDRV),A	;set change in drives flag.
E694: 70      		LD	(HL),B
E695: 13      		INC	DE
              	;
              	;   Convert the basic file name.
              	;
E696: 0608    	CONVRT3:LD	B,08H
E698: CD30E6  	CONVRT4:CALL	CHECK
E69B: CAB9E6  		JP	Z,CONVRT8
E69E: 23      		INC	HL
E69F: FE2A    		CP	'*'		;note that an '*' will fill the remaining
E6A1: C2A9E6  		JP	NZ,CONVRT5	;field with '?'.
E6A4: 363F    		LD	(HL),'?'
E6A6: C3ABE6  		JP	CONVRT6
E6A9: 77      	CONVRT5:LD	(HL),A
E6AA: 13      		INC	DE
E6AB: 05      	CONVRT6:DEC	B
E6AC: C298E6  		JP	NZ,CONVRT4
E6AF: CD30E6  	CONVRT7:CALL	CHECK		;get next delimiter.
E6B2: CAC0E6  		JP	Z,GETEXT
E6B5: 13      		INC	DE
E6B6: C3AFE6  		JP	CONVRT7
E6B9: 23      	CONVRT8:INC	HL		;blank fill the file name.
E6BA: 3620    		LD	(HL),' '
E6BC: 05      		DEC	B
E6BD: C2B9E6  		JP	NZ,CONVRT8
              	;
              	;   Get the extension and convert it.
              	;
E6C0: 0603    	GETEXT:	LD	B,03H
E6C2: FE2E    		CP	'.'
E6C4: C2E9E6  		JP	NZ,GETEXT5
E6C7: 13      		INC	DE
E6C8: CD30E6  	GETEXT1:CALL	CHECK
E6CB: CAE9E6  		JP	Z,GETEXT5
E6CE: 23      		INC	HL
E6CF: FE2A    		CP	'*'
E6D1: C2D9E6  		JP	NZ,GETEXT2
E6D4: 363F    		LD	(HL),'?'
E6D6: C3DBE6  		JP	GETEXT3
E6D9: 77      	GETEXT2:LD	(HL),A
E6DA: 13      		INC	DE
E6DB: 05      	GETEXT3:DEC	B
E6DC: C2C8E6  		JP	NZ,GETEXT1
E6DF: CD30E6  	GETEXT4:CALL	CHECK
E6E2: CAF0E6  		JP	Z,GETEXT6
E6E5: 13      		INC	DE
E6E6: C3DFE6  		JP	GETEXT4
E6E9: 23      	GETEXT5:INC	HL
E6EA: 3620    		LD	(HL),' '
E6EC: 05      		DEC	B
E6ED: C2E9E6  		JP	NZ,GETEXT5
E6F0: 0603    	GETEXT6:LD	B,3
E6F2: 23      	GETEXT7:INC	HL
E6F3: 3600    		LD	(HL),0
E6F5: 05      		DEC	B
E6F6: C2F2E6  		JP	NZ,GETEXT7
E6F9: EB      		EX	DE,HL
E6FA: 2288E4  		LD	(INPOINT),HL	;save input line pointer.
E6FD: E1      		POP	HL
              	;
              	;   Check to see if this is an ambigeous file name specification.
              	; Set the (A) register to non zero if it is.
              	;
E6FE: 010B00  		LD	BC,11		;set name length.
E701: 23      	GETEXT8:INC	HL
E702: 7E      		LD	A,(HL)
E703: FE3F    		CP	'?'		;any question marks?
E705: C209E7  		JP	NZ,GETEXT9
E708: 04      		INC	B		;count them.
E709: 0D      	GETEXT9:DEC	C
E70A: C201E7  		JP	NZ,GETEXT8
E70D: 78      		LD	A,B
E70E: B7      		OR	A
E70F: C9      		RET
              	;
              	;   CP/M command table. Note commands can be either 3 or 4 characters long.
              	;
0006:         	NUMCMDS EQU	6		;number of commands
E710: 44495220	CMDTBL:	DEFB	'DIR '
E714: 45524120		DEFB	'ERA '
E718: 54595045		DEFB	'TYPE'
E71C: 53415645		DEFB	'SAVE'
E720: 52454E20		DEFB	'REN '
E724: 55534552		DEFB	'USER'
              	;
              	;   The following six bytes must agree with those at (PATTRN2)
              	; or cp/m will HALT. Why?
              	;
E728: 00160000	PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
E72C: 0000    	
              	;
              	;   Search the command table for a match with what has just
              	; been entered. If a match is found, then we jump to the
              	; proper section. Else jump to (UNKNOWN).
              	; On return, the (C) register is set to the command number
              	; that matched (or NUMCMDS+1 if no match).
              	;
E72E: 2110E7  	SEARCH:	LD	HL,CMDTBL
E731: 0E00    		LD	C,0
E733: 79      	SEARCH1:LD	A,C
E734: FE06    		CP	NUMCMDS		;this commands exists.
E736: D0      		RET	NC
E737: 11CEEB  		LD	DE,FCB+1	;check this one.
E73A: 0604    		LD	B,4		;max command length.
E73C: 1A      	SEARCH2:LD	A,(DE)
E73D: BE      		CP	(HL)
E73E: C24FE7  		JP	NZ,SEARCH3	;not a match.
E741: 13      		INC	DE
E742: 23      		INC	HL
E743: 05      		DEC	B
E744: C23CE7  		JP	NZ,SEARCH2
E747: 1A      		LD	A,(DE)		;allow a 3 character command to match.
E748: FE20    		CP	' '
E74A: C254E7  		JP	NZ,SEARCH4
E74D: 79      		LD	A,C		;set return register for this command.
E74E: C9      		RET
E74F: 23      	SEARCH3:INC	HL
E750: 05      		DEC	B
E751: C24FE7  		JP	NZ,SEARCH3
E754: 0C      	SEARCH4:INC	C
E755: C333E7  		JP	SEARCH1
              	;
              	;   Set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
E758: AF      	CLEARBUF: XOR	A
E759: 3207E4  		LD	(INBUFF+1),A	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
E75C: 31ABEB  	COMMAND:LD	SP,CCPSTACK	;setup stack area.
E75F: C5      		PUSH	BC		;note that (C) should be equal to:
E760: 79      		LD	A,C		;(uuuudddd) where 'uuuu' is the user number
E761: 1F      		RRA			;and 'dddd' is the drive number.
E762: 1F      		RRA
E763: 1F      		RRA
E764: 1F      		RRA
E765: E60F    		AND	0FH		;isolate the user number.
E767: 5F      		LD	E,A
E768: CD15E5  		CALL	GETSETUC	;and set it.
E76B: CDB8E4  		CALL	RESDSK		;reset the disk system.
E76E: 32ABEB  		LD	(BATCH),A	;clear batch mode flag.
E771: C1      		POP	BC
E772: 79      		LD	A,C
E773: E60F    		AND	0FH		;isolate the drive number.
E775: 32EFEB  		LD	(CDRIVE),A	;and save.
E778: CDBDE4  		CALL	DSKSEL		;...and select.
E77B: 3A07E4  		LD	A,(INBUFF+1)
E77E: B7      		OR	A		;anything in input buffer already?
E77F: C298E7  		JP	NZ,CMMND2	;yes, we just process it.
              	;
              	;   Entry point to get a command line from the console.
              	;
E782: 31ABEB  	CMMND1:	LD	SP,CCPSTACK	;set stack straight.
E785: CD98E4  		CALL	CRLF		;start a new line on the screen.
E788: CDD0E5  		CALL	GETDSK		;get current drive.
E78B: C661    		ADD	A,'a'
E78D: CD8CE4  		CALL	PRINT		;print current drive.
E790: 3E3E    		LD	A,'>'
E792: CD8CE4  		CALL	PRINT		;and add prompt.
E795: CD39E5  		CALL	GETINP		;get line from user.
              	;
              	;   Process command line here.
              	;
E798: 118000  	CMMND2:	LD	DE,TBUFF
E79B: CDD8E5  		CALL	DMASET		;set standard dma address.
E79E: CDD0E5  		CALL	GETDSK
E7A1: 32EFEB  		LD	(CDRIVE),A	;set current drive.
E7A4: CD5EE6  		CALL	CONVFST		;convert name typed in.
E7A7: C409E6  		CALL	NZ,SYNERR	;wild cards are not allowed.
E7AA: 3AF0EB  		LD	A,(CHGDRV)	;if a change in drives was indicated,
E7AD: B7      		OR	A		;then treat this as an unknown command
E7AE: C2A5EA  		JP	NZ,UNKNOWN	;which gets executed.
E7B1: CD2EE7  		CALL	SEARCH		;else search command table for a match.
              	;
              	;   Note that an unknown command returns
              	; with (A) pointing to the last address
              	; in our table which is (UNKNOWN).
              	;
E7B4: 21C1E7  		LD	HL,CMDADR	;now, look thru our address table for command (A).
E7B7: 5F      		LD	E,A		;set (DE) to command number.
E7B8: 1600    		LD	D,0
E7BA: 19      		ADD	HL,DE
E7BB: 19      		ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
E7BC: 7E      		LD	A,(HL)		;now pick out this address.
E7BD: 23      		INC	HL
E7BE: 66      		LD	H,(HL)
E7BF: 6F      		LD	L,A
E7C0: E9      		JP	(HL)		;now execute it.
              	;
              	;   CP/M command address table.
              	;
E7C1: 77E81FE9	CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE
E7C5: 5DE9ADE9	
E7C9: 10EA8EEA		DEFW	RENAME,USER,UNKNOWN
E7CD: A5EA    	
              	;
              	;   Halt the system. Reason for this is unknown at present.
              	;
E7CF: 21F376  	HALT:	LD	HL,76F3H	;'DI HLT' instructions.
E7D2: 2200E4  		LD	(CBASE),HL
E7D5: 2100E4  		LD	HL,CBASE
E7D8: E9      		JP	(HL)
              	;
              	;   Read error while TYPEing a file.
              	;
E7D9: 01DFE7  	RDERROR:LD	BC,RDERR
E7DC: C3A7E4  		JP	PLINE
E7DF: 52656164	RDERR:	DEFB	'Read error',0
E7E3: 20657272	
E7E7: 6F7200  	
              	;
              	;   Required file was not located.
              	;
E7EA: 01F0E7  	NONE:	LD	BC,NOFILE
E7ED: C3A7E4  		JP	PLINE
E7F0: 4E6F2066	NOFILE:	DEFB	'No file',0
E7F4: 696C6500	
              	;
              	;   Decode a command of the form 'A>filename number{ filename}.
              	; Note that a drive specifier is not allowed on the first file
              	; name. On return, the number is in register (A). Any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
E7F8: CD5EE6  	DECODE:	CALL	CONVFST		;convert filename.
E7FB: 3AF0EB  		LD	A,(CHGDRV)	;do not allow a drive to be specified.
E7FE: B7      		OR	A
E7FF: C209E6  		JP	NZ,SYNERR
E802: 21CEEB  		LD	HL,FCB+1	;convert number now.
E805: 010B00  		LD	BC,11		;(B)=sum register, (C)=max digit count.
E808: 7E      	DECODE1:LD	A,(HL)
E809: FE20    		CP	' '		;a space terminates the numeral.
E80B: CA33E8  		JP	Z,DECODE3
E80E: 23      		INC	HL
E80F: D630    		SUB	'0'		;make binary from ascii.
E811: FE0A    		CP	10		;legal digit?
E813: D209E6  		JP	NC,SYNERR
E816: 57      		LD	D,A		;yes, save it in (D).
E817: 78      		LD	A,B		;compute (B)=(B)*10 and check for overflow.
E818: E6E0    		AND	0E0H
E81A: C209E6  		JP	NZ,SYNERR
E81D: 78      		LD	A,B
E81E: 07      		RLCA
E81F: 07      		RLCA
E820: 07      		RLCA			;(A)=(B)*8
E821: 80      		ADD	A,B		;.......*9
E822: DA09E6  		JP	C,SYNERR
E825: 80      		ADD	A,B		;.......*10
E826: DA09E6  		JP	C,SYNERR
E829: 82      		ADD	A,D		;add in new digit now.
E82A: DA09E6  	DECODE2:JP	C,SYNERR
E82D: 47      		LD	B,A		;and save result.
E82E: 0D      		DEC	C		;only look at 11 digits.
E82F: C208E8  		JP	NZ,DECODE1
E832: C9      		RET
E833: 7E      	DECODE3:LD	A,(HL)		;spaces must follow (why?).
E834: FE20    		CP	' '
E836: C209E6  		JP	NZ,SYNERR
E839: 23      		INC	HL
E83A: 0D      	DECODE4:DEC	C
E83B: C233E8  		JP	NZ,DECODE3
E83E: 78      		LD	A,B		;set (A)=the numeric value entered.
E83F: C9      		RET
              	;
              	;   Move 3 bytes from (HL) to (DE). Note that there is only
              	; one reference to this at (A2D5h).
              	;
E840: 0603    	MOVE3:	LD	B,3
              	;
              	;   Move (B) bytes from (HL) to (DE).
              	;
E842: 7E      	HL2DE:	LD	A,(HL)
E843: 12      		LD	(DE),A
E844: 23      		INC	HL
E845: 13      		INC	DE
E846: 05      		DEC	B
E847: C242E8  		JP	NZ,HL2DE
E84A: C9      		RET
              	;
              	;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
              	;
E84B: 218000  	EXTRACT:LD	HL,TBUFF
E84E: 81      		ADD	A,C
E84F: CD59E6  		CALL	ADDHL
E852: 7E      		LD	A,(HL)
E853: C9      		RET
              	;
              	;  Check drive specified. If it means a change, then the new
              	; drive will be selected. In any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
E854: AF      	DSELECT:XOR	A		;null out first byte of fcb.
E855: 32CDEB  		LD	(FCB),A
E858: 3AF0EB  		LD	A,(CHGDRV)	;a drive change indicated?
E85B: B7      		OR	A
E85C: C8      		RET	Z
E85D: 3D      		DEC	A		;yes, is it the same as the current drive?
E85E: 21EFEB  		LD	HL,CDRIVE
E861: BE      		CP	(HL)
E862: C8      		RET	Z
E863: C3BDE4  		JP	DSKSEL		;no. Select it then.
              	;
              	;   Check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
E866: 3AF0EB  	RESETDR:LD	A,(CHGDRV)	;drive change indicated?
E869: B7      		OR	A
E86A: C8      		RET	Z
E86B: 3D      		DEC	A		;yes, was it a different drive?
E86C: 21EFEB  		LD	HL,CDRIVE
E86F: BE      		CP	(HL)
E870: C8      		RET	Z
E871: 3AEFEB  		LD	A,(CDRIVE)	;yes, re-select our old drive.
E874: C3BDE4  		JP	DSKSEL
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
E877: CD5EE6  	DIRECT:	CALL	CONVFST		;convert file name.
E87A: CD54E8  		CALL	DSELECT		;select indicated drive.
E87D: 21CEEB  		LD	HL,FCB+1	;was any file indicated?
E880: 7E      		LD	A,(HL)
E881: FE20    		CP	' '
E883: C28FE8  		JP	NZ,DIRECT2
E886: 060B    		LD	B,11		;no. Fill field with '?' - same as *.*.
E888: 363F    	DIRECT1:LD	(HL),'?'
E88A: 23      		INC	HL
E88B: 05      		DEC	B
E88C: C288E8  		JP	NZ,DIRECT1
E88F: 1E00    	DIRECT2:LD	E,0		;set initial cursor position.
E891: D5      		PUSH	DE
E892: CDE9E4  		CALL	SRCHFCB		;get first file name.
E895: CCEAE7  		CALL	Z,NONE		;none found at all?
E898: CA1BE9  	DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
E89B: 3AEEEB  		LD	A,(RTNCODE)	;get file's position in segment (0-3).
E89E: 0F      		RRCA
E89F: 0F      		RRCA
E8A0: 0F      		RRCA
E8A1: E660    		AND	60H		;(A)=position*32
E8A3: 4F      		LD	C,A
E8A4: 3E0A    		LD	A,10
E8A6: CD4BE8  		CALL	EXTRACT		;extract the tenth entry in fcb.
E8A9: 17      		RLA			;check system file status bit.
E8AA: DA0FE9  		JP	C,DIRECT8	;we don't list them.
E8AD: D1      		POP	DE
E8AE: 7B      		LD	A,E		;bump name count.
E8AF: 1C      		INC	E
E8B0: D5      		PUSH	DE
E8B1: E603    		AND	03H		;at end of line?
E8B3: F5      		PUSH	AF
E8B4: C2CCE8  		JP	NZ,DIRECT4
E8B7: CD98E4  		CALL	CRLF		;yes, end this line and start another.
E8BA: C5      		PUSH	BC
E8BB: CDD0E5  		CALL	GETDSK		;start line with ('A:').
E8BE: C1      		POP	BC
E8BF: C641    		ADD	A,'A'
E8C1: CD92E4  		CALL	PRINTB
E8C4: 3E3A    		LD	A,':'
E8C6: CD92E4  		CALL	PRINTB
E8C9: C3D4E8  		JP	DIRECT5
E8CC: CDA2E4  	DIRECT4:CALL	SPACE		;add seperator between file names.
E8CF: 3E3A    		LD	A,':'
E8D1: CD92E4  		CALL	PRINTB
E8D4: CDA2E4  	DIRECT5:CALL	SPACE
E8D7: 0601    		LD	B,1		;'extract' each file name character at a time.
E8D9: 78      	DIRECT6:LD	A,B
E8DA: CD4BE8  		CALL	EXTRACT
E8DD: E67F    		AND	7FH		;strip bit 7 (status bit).
E8DF: FE20    		CP	' '		;are we at the end of the name?
E8E1: C2F9E8  		JP	NZ,DRECT65
E8E4: F1      		POP	AF		;yes, don't print spaces at the end of a line.
E8E5: F5      		PUSH	AF
E8E6: FE03    		CP	3
E8E8: C2F7E8  		JP	NZ,DRECT63
E8EB: 3E09    		LD	A,9		;first check for no extension.
E8ED: CD4BE8  		CALL	EXTRACT
E8F0: E67F    		AND	7FH
E8F2: FE20    		CP	' '
E8F4: CA0EE9  		JP	Z,DIRECT7	;don't print spaces.
E8F7: 3E20    	DRECT63:LD	A,' '		;else print them.
E8F9: CD92E4  	DRECT65:CALL	PRINTB
E8FC: 04      		INC	B		;bump to next character psoition.
E8FD: 78      		LD	A,B
E8FE: FE0C    		CP	12		;end of the name?
E900: D20EE9  		JP	NC,DIRECT7
E903: FE09    		CP	9		;nope, starting extension?
E905: C2D9E8  		JP	NZ,DIRECT6
E908: CDA2E4  		CALL	SPACE		;yes, add seperating space.
E90B: C3D9E8  		JP	DIRECT6
E90E: F1      	DIRECT7:POP	AF		;get the next file name.
E90F: CDC2E5  	DIRECT8:CALL	CHKCON		;first check console, quit on anything.
E912: C21BE9  		JP	NZ,DIRECT9
E915: CDE4E4  		CALL	SRCHNXT		;get next name.
E918: C398E8  		JP	DIRECT3		;and continue with our list.
E91B: D1      	DIRECT9:POP	DE		;restore the stack and return to command level.
E91C: C386EB  		JP	GETBACK
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E91F: CD5EE6  	ERASE:	CALL	CONVFST		;convert file name.
E922: FE0B    		CP	11		;was '*.*' entered?
E924: C242E9  		JP	NZ,ERASE1
E927: 0152E9  		LD	BC,YESNO	;yes, ask for confirmation.
E92A: CDA7E4  		CALL	PLINE
E92D: CD39E5  		CALL	GETINP
E930: 2107E4  		LD	HL,INBUFF+1
E933: 35      		DEC	(HL)		;must be exactly 'y'.
E934: C282E7  		JP	NZ,CMMND1
E937: 23      		INC	HL
E938: 7E      		LD	A,(HL)
E939: FE59    		CP	'Y'
E93B: C282E7  		JP	NZ,CMMND1
E93E: 23      		INC	HL
E93F: 2288E4  		LD	(INPOINT),HL	;save input line pointer.
E942: CD54E8  	ERASE1:	CALL	DSELECT		;select desired disk.
E945: 11CDEB  		LD	DE,FCB
E948: CDEFE4  		CALL	DELETE		;delete the file.
E94B: 3C      		INC	A
E94C: CCEAE7  		CALL	Z,NONE		;not there?
E94F: C386EB  		JP	GETBACK		;return to command level now.
E952: 416C6C20	YESNO:	DEFB	'All (y/n)?',0
E956: 28792F6E	
E95A: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E95D: CD5EE6  	TYPE:	CALL	CONVFST		;convert file name.
E960: C209E6  		JP	NZ,SYNERR	;wild cards not allowed.
E963: CD54E8  		CALL	DSELECT		;select indicated drive.
E966: CDD0E4  		CALL	OPENFCB		;open the file.
E969: CAA7E9  		JP	Z,TYPE5		;not there?
E96C: CD98E4  		CALL	CRLF		;ok, start a new line on the screen.
E96F: 21F1EB  		LD	HL,NBYTES	;initialize byte counter.
E972: 36FF    		LD	(HL),0FFH	;set to read first sector.
E974: 21F1EB  	TYPE1:	LD	HL,NBYTES
E977: 7E      	TYPE2:	LD	A,(HL)		;have we written the entire sector?
E978: FE80    		CP	128
E97A: DA87E9  		JP	C,TYPE3
E97D: E5      		PUSH	HL		;yes, read in the next one.
E97E: CDFEE4  		CALL	READFCB
E981: E1      		POP	HL
E982: C2A0E9  		JP	NZ,TYPE4	;end or error?
E985: AF      		XOR	A		;ok, clear byte counter.
E986: 77      		LD	(HL),A
E987: 34      	TYPE3:	INC	(HL)		;count this byte.
E988: 218000  		LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
E98B: CD59E6  		CALL	ADDHL
E98E: 7E      		LD	A,(HL)
E98F: FE1A    		CP	CNTRLZ		;end of file mark?
E991: CA86EB  		JP	Z,GETBACK
E994: CD8CE4  		CALL	PRINT		;no, print it.
E997: CDC2E5  		CALL	CHKCON		;check console, quit if anything ready.
E99A: C286EB  		JP	NZ,GETBACK
E99D: C374E9  		JP	TYPE1
              	;
              	;   Get here on an end of file or read error.
              	;
E9A0: 3D      	TYPE4:	DEC	A		;read error?
E9A1: CA86EB  		JP	Z,GETBACK
E9A4: CDD9E7  		CALL	RDERROR		;yes, print message.
E9A7: CD66E8  	TYPE5:	CALL	RESETDR		;and reset proper drive
E9AA: C309E6  		JP	SYNERR		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E9AD: CDF8E7  	SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
E9B0: F5      		PUSH	AF		;save number of pages to write.
E9B1: CD5EE6  		CALL	CONVFST		;convert file name.
E9B4: C209E6  		JP	NZ,SYNERR	;wild cards not allowed.
E9B7: CD54E8  		CALL	DSELECT		;select specified drive.
E9BA: 11CDEB  		LD	DE,FCB		;now delete this file.
E9BD: D5      		PUSH	DE
E9BE: CDEFE4  		CALL	DELETE
E9C1: D1      		POP	DE
E9C2: CD09E5  		CALL	CREATE		;and create it again.
E9C5: CAFBE9  		JP	Z,SAVE3		;can't create?
E9C8: AF      		XOR	A		;clear record number byte.
E9C9: 32EDEB  		LD	(FCB+32),A
E9CC: F1      		POP	AF		;convert pages to sectors.
E9CD: 6F      		LD	L,A
E9CE: 2600    		LD	H,0
E9D0: 29      		ADD	HL,HL		;(HL)=number of sectors to write.
E9D1: 110001  		LD	DE,TBASE	;and we start from here.
E9D4: 7C      	SAVE1:	LD	A,H		;done yet?
E9D5: B5      		OR	L
E9D6: CAF1E9  		JP	Z,SAVE2
E9D9: 2B      		DEC	HL		;nope, count this and compute the start
E9DA: E5      		PUSH	HL		;of the next 128 byte sector.
E9DB: 218000  		LD	HL,128
E9DE: 19      		ADD	HL,DE
E9DF: E5      		PUSH	HL		;save it and set the transfer address.
E9E0: CDD8E5  		CALL	DMASET
E9E3: 11CDEB  		LD	DE,FCB		;write out this sector now.
E9E6: CD04E5  		CALL	WRTREC
E9E9: D1      		POP	DE		;reset (DE) to the start of the last sector.
E9EA: E1      		POP	HL		;restore sector count.
E9EB: C2FBE9  		JP	NZ,SAVE3	;write error?
E9EE: C3D4E9  		JP	SAVE1
              	;
              	;   Get here after writing all of the file.
              	;
E9F1: 11CDEB  	SAVE2:	LD	DE,FCB		;now close the file.
E9F4: CDDAE4  		CALL	CLOSE
E9F7: 3C      		INC	A		;did it close ok?
E9F8: C201EA  		JP	NZ,SAVE4
              	;
              	;   Print out error message (no space).
              	;
E9FB: 0107EA  	SAVE3:	LD	BC,NOSPACE
E9FE: CDA7E4  		CALL	PLINE
EA01: CDD5E5  	SAVE4:	CALL	STDDMA		;reset the standard dma address.
EA04: C386EB  		JP	GETBACK
EA07: 4E6F2073	NOSPACE:DEFB	'No space',0
EA0B: 70616365	
EA0F: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
EA10: CD5EE6  	RENAME:	CALL	CONVFST		;convert first file name.
EA13: C209E6  		JP	NZ,SYNERR	;wild cards not allowed.
EA16: 3AF0EB  		LD	A,(CHGDRV)	;remember any change in drives specified.
EA19: F5      		PUSH	AF
EA1A: CD54E8  		CALL	DSELECT		;and select this drive.
EA1D: CDE9E4  		CALL	SRCHFCB		;is this file present?
EA20: C279EA  		JP	NZ,RENAME6	;yes, print error message.
EA23: 21CDEB  		LD	HL,FCB		;yes, move this name into second slot.
EA26: 11DDEB  		LD	DE,FCB+16
EA29: 0610    		LD	B,16
EA2B: CD42E8  		CALL	HL2DE
EA2E: 2A88E4  		LD	HL,(INPOINT)	;get input pointer.
EA31: EB      		EX	DE,HL
EA32: CD4FE6  		CALL	NONBLANK	;get next non blank character.
EA35: FE3D    		CP	'='		;only allow an '=' or '_' seperator.
EA37: CA3FEA  		JP	Z,RENAME1
EA3A: FE5F    		CP	'_'
EA3C: C273EA  		JP	NZ,RENAME5
EA3F: EB      	RENAME1:EX	DE,HL
EA40: 23      		INC	HL		;ok, skip seperator.
EA41: 2288E4  		LD	(INPOINT),HL	;save input line pointer.
EA44: CD5EE6  		CALL	CONVFST		;convert this second file name now.
EA47: C273EA  		JP	NZ,RENAME5	;again, no wild cards.
EA4A: F1      		POP	AF		;if a drive was specified, then it
EA4B: 47      		LD	B,A		;must be the same as before.
EA4C: 21F0EB  		LD	HL,CHGDRV
EA4F: 7E      		LD	A,(HL)
EA50: B7      		OR	A
EA51: CA59EA  		JP	Z,RENAME2
EA54: B8      		CP	B
EA55: 70      		LD	(HL),B
EA56: C273EA  		JP	NZ,RENAME5	;they were different, error.
EA59: 70      	RENAME2:LD	(HL),B		;	reset as per the first file specification.
EA5A: AF      		XOR	A
EA5B: 32CDEB  		LD	(FCB),A		;clear the drive byte of the fcb.
EA5E: CDE9E4  	RENAME3:CALL	SRCHFCB		;and go look for second file.
EA61: CA6DEA  		JP	Z,RENAME4	;doesn't exist?
EA64: 11CDEB  		LD	DE,FCB
EA67: CD0EE5  		CALL	RENAM		;ok, rename the file.
EA6A: C386EB  		JP	GETBACK
              	;
              	;   Process rename errors here.
              	;
EA6D: CDEAE7  	RENAME4:CALL	NONE		;file not there.
EA70: C386EB  		JP	GETBACK
EA73: CD66E8  	RENAME5:CALL	RESETDR		;bad command format.
EA76: C309E6  		JP	SYNERR
EA79: 0182EA  	RENAME6:LD	BC,EXISTS	;destination file already exists.
EA7C: CDA7E4  		CALL	PLINE
EA7F: C386EB  		JP	GETBACK
EA82: 46696C65	EXISTS:	DEFB	'File exists',0
EA86: 20657869	
EA8A: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
EA8E: CDF8E7  	USER:	CALL	DECODE		;get numeric value following command.
EA91: FE10    		CP	16		;legal user number?
EA93: D209E6  		JP	NC,SYNERR
EA96: 5F      		LD	E,A		;yes but is there anything else?
EA97: 3ACEEB  		LD	A,(FCB+1)
EA9A: FE20    		CP	' '
EA9C: CA09E6  		JP	Z,SYNERR	;yes, that is not allowed.
EA9F: CD15E5  		CALL	GETSETUC	;ok, set user code.
EAA2: C389EB  		JP	GETBACK1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
EAA5: CDF5E5  	UNKNOWN:CALL	VERIFY		;check for valid system (why?).
EAA8: 3ACEEB  		LD	A,(FCB+1)	;anything to execute?
EAAB: FE20    		CP	' '
EAAD: C2C4EA  		JP	NZ,UNKWN1
EAB0: 3AF0EB  		LD	A,(CHGDRV)	;nope, only a drive change?
EAB3: B7      		OR	A
EAB4: CA89EB  		JP	Z,GETBACK1	;neither???
EAB7: 3D      		DEC	A
EAB8: 32EFEB  		LD	(CDRIVE),A	;ok, store new drive.
EABB: CD29E5  		CALL	MOVECD		;set (TDRIVE) also.
EABE: CDBDE4  		CALL	DSKSEL		;and select this drive.
EAC1: C389EB  		JP	GETBACK1	;then return.
              	;
              	;   Here a file name was typed. Prepare to execute it.
              	;
EAC4: 11D6EB  	UNKWN1:	LD	DE,FCB+9	;an extension specified?
EAC7: 1A      		LD	A,(DE)
EAC8: FE20    		CP	' '
EACA: C209E6  		JP	NZ,SYNERR	;yes, not allowed.
EACD: D5      	UNKWN2:	PUSH	DE
EACE: CD54E8  		CALL	DSELECT		;select specified drive.
EAD1: D1      		POP	DE
EAD2: 2183EB  		LD	HL,COMFILE	;set the extension to 'COM'.
EAD5: CD40E8  		CALL	MOVE3
EAD8: CDD0E4  		CALL	OPENFCB		;and open this file.
EADB: CA6BEB  		JP	Z,UNKWN9	;not present?
              	;
              	;   Load in the program.
              	;
EADE: 210001  		LD	HL,TBASE	;store the program starting here.
EAE1: E5      	UNKWN3:	PUSH	HL
EAE2: EB      		EX	DE,HL
EAE3: CDD8E5  		CALL	DMASET		;set transfer address.
EAE6: 11CDEB  		LD	DE,FCB		;and read the next record.
EAE9: CDF9E4  		CALL	RDREC
EAEC: C201EB  		JP	NZ,UNKWN4	;end of file or read error?
EAEF: E1      		POP	HL		;nope, bump pointer for next sector.
EAF0: 118000  		LD	DE,128
EAF3: 19      		ADD	HL,DE
EAF4: 1100E4  		LD	DE,CBASE	;enough room for the whole file?
EAF7: 7D      		LD	A,L
EAF8: 93      		SUB	E
EAF9: 7C      		LD	A,H
EAFA: 9A      		SBC	A,D
EAFB: D271EB  		JP	NC,UNKWN0	;no, it can't fit.
EAFE: C3E1EA  		JP	UNKWN3
              	;
              	;   Get here after finished reading.
              	;
EB01: E1      	UNKWN4:	POP	HL
EB02: 3D      		DEC	A		;normal end of file?
EB03: C271EB  		JP	NZ,UNKWN0
EB06: CD66E8  		CALL	RESETDR		;yes, reset previous drive.
EB09: CD5EE6  		CALL	CONVFST		;convert the first file name that follows
EB0C: 21F0EB  		LD	HL,CHGDRV	;command name.
EB0F: E5      		PUSH	HL
EB10: 7E      		LD	A,(HL)		;set drive code in default fcb.
EB11: 32CDEB  		LD	(FCB),A
EB14: 3E10    		LD	A,16		;put second name 16 bytes later.
EB16: CD60E6  		CALL	CONVERT		;convert second file name.
EB19: E1      		POP	HL
EB1A: 7E      		LD	A,(HL)		;and set the drive for this second file.
EB1B: 32DDEB  		LD	(FCB+16),A
EB1E: AF      		XOR	A		;clear record byte in fcb.
EB1F: 32EDEB  		LD	(FCB+32),A
EB22: 115C00  		LD	DE,TFCB		;move it into place at(005Ch).
EB25: 21CDEB  		LD	HL,FCB
EB28: 0621    		LD	B,33
EB2A: CD42E8  		CALL	HL2DE
EB2D: 2108E4  		LD	HL,INBUFF+2	;now move the remainder of the input
EB30: 7E      	UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
EB31: B7      		OR	A		;or a null.
EB32: CA3EEB  		JP	Z,UNKWN6
EB35: FE20    		CP	' '
EB37: CA3EEB  		JP	Z,UNKWN6
EB3A: 23      		INC	HL
EB3B: C330EB  		JP	UNKWN5
              	;
              	;   Do the line move now. It ends in a null byte.
              	;
EB3E: 0600    	UNKWN6:	LD	B,0		;keep a character count.
EB40: 118100  		LD	DE,TBUFF+1	;data gets put here.
EB43: 7E      	UNKWN7:	LD	A,(HL)		;move it now.
EB44: 12      		LD	(DE),A
EB45: B7      		OR	A
EB46: CA4FEB  		JP	Z,UNKWN8
EB49: 04      		INC	B
EB4A: 23      		INC	HL
EB4B: 13      		INC	DE
EB4C: C343EB  		JP	UNKWN7
EB4F: 78      	UNKWN8:	LD	A,B		;now store the character count.
EB50: 328000  		LD	(TBUFF),A
EB53: CD98E4  		CALL	CRLF		;clean up the screen.
EB56: CDD5E5  		CALL	STDDMA		;set standard transfer address.
EB59: CD1AE5  		CALL	SETCDRV		;reset current drive.
EB5C: CD0001  		CALL	TBASE		;and execute the program.
              	;
              	;   Transiant programs return here (or reboot).
              	;
EB5F: 31ABEB  		LD	SP,BATCH	;set stack first off.
EB62: CD29E5  		CALL	MOVECD		;move current drive into place (TDRIVE).
EB65: CDBDE4  		CALL	DSKSEL		;and reselect it.
EB68: C382E7  		JP	CMMND1		;back to comand mode.
              	;
              	;   Get here if some error occured.
              	;
EB6B: CD66E8  	UNKWN9:	CALL	RESETDR		;inproper format.
EB6E: C309E6  		JP	SYNERR
EB71: 017AEB  	UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
EB74: CDA7E4  		CALL	PLINE
EB77: C386EB  		JP	GETBACK
EB7A: 42616420	BADLOAD:DEFB	'Bad load',0
EB7E: 6C6F6164	
EB82: 00      	
EB83: 434F4D  	COMFILE:DEFB	'COM'		;command file extension.
              	;
              	;   Get here to return to command level. We will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
EB86: CD66E8  	GETBACK:CALL	RESETDR		;reset previous drive.
EB89: CD5EE6  	GETBACK1: CALL	CONVFST		;convert first name in (FCB).
EB8C: 3ACEEB  		LD	A,(FCB+1)	;if this was just a drive change request,
EB8F: D620    		SUB	' '		;make sure it was valid.
EB91: 21F0EB  		LD	HL,CHGDRV
EB94: B6      		OR	(HL)
EB95: C209E6  		JP	NZ,SYNERR
EB98: C382E7  		JP	CMMND1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
EB9B: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EB9F: 00...   	
EBAB:         	CCPSTACK EQU	$	;end of ccp stack area.
              	;
              	;   Batch (or SUBMIT) processing information storage.
              	;
EBAB: 00      	BATCH:	DEFB	0		;batch mode flag (0=not active).
EBAC: 00242424	BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EBB0: 20202020	
EBB4: 20535542	
EBB8: 00000000	
EBBC: 00...   	
              	;
              	;   File control block setup by the CCP.
              	;
EBCD: 00202020	FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
EBD1: 20202020	
EBD5: 20202020	
EBD9: 00000000	
EBDD: 00202020	
EBE1: 20202020	
EBE5: 20202020	
EBE9: 00000000	
EBED: 00      	
EBEE: 00      	RTNCODE:DEFB	0		;status returned from bdos call.
EBEF: 00      	CDRIVE:	DEFB	0		;currently active drive.
EBF0: 00      	CHGDRV:	DEFB	0		;change in drives flag (0=no change).
EBF1: 0000    	NBYTES:	DEFW	0		;byte counter used by TYPE.
              	;
              	;   Room for expansion?
              	;
EBF3: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0
EBF7: 00...   	
              	;
              	;   Note that the following six bytes must match those at
              	; (PATTRN1) or cp/m will HALT. Why?
              	;
EC00: 00160000	PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
EC04: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
EC06: C311EC  	FBASE:	JP	FBASE1
              	;
              	;   Bdos error table.
              	;
EC09: 99EC    	BADSCTR:DEFW	ERROR1		;bad sector on read or write.
EC0B: A5EC    	BADSLCT:DEFW	ERROR2		;bad disk select.
EC0D: ABEC    	RODISK:	DEFW	ERROR3		;disk is read only.
EC0F: B1EC    	ROFILE:	DEFW	ERROR4		;file is read only.
              	;
              	;   Entry into bdos. (DE) or (E) are the parameters passed. The
              	; function number desired is in register (C).
              	;
EC11: EB      	FBASE1:	EX	DE,HL		;save the (DE) parameters.
EC12: 2243EF  		LD	(PARAMS),HL
EC15: EB      		EX	DE,HL
EC16: 7B      		LD	A,E		;and save register (E) in particular.
EC17: 32D6F9  		LD	(EPARAM),A
EC1A: 210000  		LD	HL,0
EC1D: 2245EF  		LD	(STATUS),HL	;clear return status.
EC20: 39      		ADD	HL,SP
EC21: 220FEF  		LD	(USRSTACK),HL	;save users stack pointer.
EC24: 3141EF  		LD	SP,STKAREA	;and set our own.
EC27: AF      		XOR	A		;clear auto select storage space.
EC28: 32E0F9  		LD	(AUTOFLAG),A
EC2B: 32DEF9  		LD	(AUTO),A
EC2E: 2174F9  		LD	HL,GOBACK	;set return address.
EC31: E5      		PUSH	HL
EC32: 79      		LD	A,C		;get function number.
EC33: FE29    		CP	NFUNCTS		;valid function number?
EC35: D0      		RET	NC
EC36: 4B      		LD	C,E		;keep single register function here.
EC37: 2147EC  		LD	HL,FUNCTNS	;now look thru the function table.
EC3A: 5F      		LD	E,A
EC3B: 1600    		LD	D,0		;(DE)=function number.
EC3D: 19      		ADD	HL,DE
EC3E: 19      		ADD	HL,DE		;(HL)=(start of table)+2*(function number).
EC3F: 5E      		LD	E,(HL)
EC40: 23      		INC	HL
EC41: 56      		LD	D,(HL)		;now (DE)=address for this function.
EC42: 2A43EF  		LD	HL,(PARAMS)	;retrieve parameters.
EC45: EB      		EX	DE,HL		;now (DE) has the original parameters.
EC46: E9      		JP	(HL)		;execute desired function.
              	;
              	;   BDOS function jump table.
              	;
0029:         	NFUNCTS EQU	41		;number of functions in followin table.
              	;
EC47: 03FAC8EE	FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
EC4B: 90EDCEEE	
EC4F: 12FA0FFA	
EC53: D4EEEDEE	
EC57: F3EEF8EE		DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
EC5B: E1EDFEEE	
EC5F: 7EF883F8	
EC63: 45F89CF8	
EC67: A5F8ABF8		DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
EC6B: C8F8D7F8	
EC6F: E0F8E6F8	
EC73: ECF8    	
EC75: F5F8FEF8		DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
EC79: 04F90AF9	
EC7D: 11F92CF1	
EC81: 17F91DF9	
EC85: 26F92DF9		DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
EC89: 41F947F9	
EC8D: 4DF90EF8	
EC91: 53F904EF	
EC95: 04EF9BF9		DEFW	RTN,WTSPECL
              	;
              	;   Bdos error message section.
              	;
EC99: 21CAEC  	ERROR1:	LD	HL,BADSEC	;bad sector message.
EC9C: CDE5EC  		CALL	PRTERR		;print it and get a 1 char responce.
EC9F: FE03    		CP	CNTRLC		;re-boot request (control-c)?
ECA1: CA0000  		JP	Z,0		;yes.
ECA4: C9      		RET			;no, return to retry i/o function.
              	;
ECA5: 21D5EC  	ERROR2:	LD	HL,BADSEL	;bad drive selected.
ECA8: C3B4EC  		JP	ERROR5
              	;
ECAB: 21E1EC  	ERROR3:	LD	HL,DISKRO	;disk is read only.
ECAE: C3B4EC  		JP	ERROR5
              	;
ECB1: 21DCEC  	ERROR4:	LD	HL,FILERO	;file is read only.
              	;
ECB4: CDE5EC  	ERROR5:	CALL	PRTERR
ECB7: C30000  		JP	0		;always reboot on these errors.
              	;
ECBA: 42646F73	BDOSERR:DEFB	'Bdos Err On '
ECBE: 20457272	
ECC2: 204F6E20	
ECC6: 203A2024	BDOSDRV:DEFB	' : $'
ECCA: 42616420	BADSEC:	DEFB	'Bad Sector$'
ECCE: 53656374	
ECD2: 6F7224  	
ECD5: 53656C65	BADSEL:	DEFB	'Select$'
ECD9: 637424  	
ECDC: 46696C65	FILERO:	DEFB	'File '
ECE0: 20      	
ECE1: 522F4F24	DISKRO:	DEFB	'R/O$'
              	;
              	;   Print bdos error message.
              	;
ECE5: E5      	PRTERR:	PUSH	HL		;save second message pointer.
ECE6: CDC9ED  		CALL	OUTCRLF		;send (cr)(lf).
ECE9: 3A42EF  		LD	A,(ACTIVE)	;get active drive.
ECEC: C641    		ADD	A,'A'		;make ascii.
ECEE: 32C6EC  		LD	(BDOSDRV),A	;and put in message.
ECF1: 01BAEC  		LD	BC,BDOSERR	;and print it.
ECF4: CDD3ED  		CALL	PRTMESG
ECF7: C1      		POP	BC		;print second message line now.
ECF8: CDD3ED  		CALL	PRTMESG
              	;
              	;   Get an input character. We will check our 1 character
              	; buffer first. This may be set by the console status routine.
              	;
ECFB: 210EEF  	GETCHAR:LD	HL,CHARBUF	;check character buffer.
ECFE: 7E      		LD	A,(HL)		;anything present already?
ECFF: 3600    		LD	(HL),0		;...either case clear it.
ED01: B7      		OR	A
ED02: C0      		RET	NZ		;yes, use it.
ED03: C309FA  		JP	CONIN		;nope, go get a character responce.
              	;
              	;   Input and echo a character.
              	;
ED06: CDFBEC  	GETECHO:CALL	GETCHAR		;input a character.
ED09: CD14ED  		CALL	CHKCHAR		;carriage control?
ED0C: D8      		RET	C		;no, a regular control char so don't echo.
ED0D: F5      		PUSH	AF		;ok, save character now.
ED0E: 4F      		LD	C,A
ED0F: CD90ED  		CALL	OUTCON		;and echo it.
ED12: F1      		POP	AF		;get character and return.
ED13: C9      		RET
              	;
              	;   Check character in (A). Set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
ED14: FE0D    	CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
ED16: C8      		RET	Z		;or a tab.
ED17: FE0A    		CP	LF
ED19: C8      		RET	Z
ED1A: FE09    		CP	TAB
ED1C: C8      		RET	Z
ED1D: FE08    		CP	BS
ED1F: C8      		RET	Z
ED20: FE20    		CP	' '		;other control char? Set carry flag.
ED22: C9      		RET	
              	;
              	;   Check the console during output. Halt on a control-s, then
              	; reboot on a control-c. If anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
ED23: 3A0EEF  	CKCONSOL: LD	A,(CHARBUF)	;check buffer.
ED26: B7      		OR	A		;if anything, just return without checking.
ED27: C245ED  		JP	NZ,CKCON2
ED2A: CD06FA  		CALL	CONST		;nothing in buffer. Check console.
ED2D: E601    		AND	01H		;look at bit 0.
ED2F: C8      		RET	Z		;return if nothing.
ED30: CD09FA  		CALL	CONIN		;ok, get it.
ED33: FE13    		CP	CNTRLS		;if not control-s, return with zero cleared.
ED35: C242ED  		JP	NZ,CKCON1
ED38: CD09FA  		CALL	CONIN		;halt processing until another char
ED3B: FE03    		CP	CNTRLC		;is typed. Control-c?
ED3D: CA0000  		JP	Z,0		;yes, reboot now.
ED40: AF      		XOR	A		;no, just pretend nothing was ever ready.
ED41: C9      		RET
ED42: 320EEF  	CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
ED45: 3E01    	CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
ED47: C9      		RET
              	;
              	;   Output (C) to the screen. If the printer flip-flop flag
              	; is set, we will send character to printer also. The console
              	; will be checked in the process.
              	;
ED48: 3A0AEF  	OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
ED4B: B7      		OR	A		;anything and we won't generate output.
ED4C: C262ED  		JP	NZ,OUTCHR1
ED4F: C5      		PUSH	BC
ED50: CD23ED  		CALL	CKCONSOL	;check console (we don't care whats there).
ED53: C1      		POP	BC
ED54: C5      		PUSH	BC
ED55: CD0CFA  		CALL	CONOUT		;output (C) to the screen.
ED58: C1      		POP	BC
ED59: C5      		PUSH	BC
ED5A: 3A0DEF  		LD	A,(PRTFLAG)	;check printer flip-flop flag.
ED5D: B7      		OR	A
ED5E: C40FFA  		CALL	NZ,LIST		;print it also if non-zero.
ED61: C1      		POP	BC
ED62: 79      	OUTCHR1:LD	A,C		;update cursors position.
ED63: 210CEF  		LD	HL,CURPOS
ED66: FE7F    		CP	DEL		;rubouts don't do anything here.
ED68: C8      		RET	Z
ED69: 34      		INC	(HL)		;bump line pointer.
ED6A: FE20    		CP	' '		;and return if a normal character.
ED6C: D0      		RET	NC
ED6D: 35      		DEC	(HL)		;restore and check for the start of the line.
ED6E: 7E      		LD	A,(HL)
ED6F: B7      		OR	A
ED70: C8      		RET	Z		;ingnore control characters at the start of the line.
ED71: 79      		LD	A,C
ED72: FE08    		CP	BS		;is it a backspace?
ED74: C279ED  		JP	NZ,OUTCHR2
ED77: 35      		DEC	(HL)		;yes, backup pointer.
ED78: C9      		RET
ED79: FE0A    	OUTCHR2:CP	LF		;is it a line feed?
ED7B: C0      		RET	NZ		;ignore anything else.
ED7C: 3600    		LD	(HL),0		;reset pointer to start of line.
ED7E: C9      		RET
              	;
              	;   Output (A) to the screen. If it is a control character
              	; (other than carriage control), use ^x format.
              	;
ED7F: 79      	SHOWIT:	LD	A,C
ED80: CD14ED  		CALL	CHKCHAR		;check character.
ED83: D290ED  		JP	NC,OUTCON	;not a control, use normal output.
ED86: F5      		PUSH	AF
ED87: 0E5E    		LD	C,'^'		;for a control character, preceed it with '^'.
ED89: CD48ED  		CALL	OUTCHAR
ED8C: F1      		POP	AF
ED8D: F640    		OR	'@'		;and then use the letter equivelant.
ED8F: 4F      		LD	C,A
              	;
              	;   Function to output (C) to the console device and expand tabs
              	; if necessary.
              	;
ED90: 79      	OUTCON:	LD	A,C
ED91: FE09    		CP	TAB		;is it a tab?
ED93: C248ED  		JP	NZ,OUTCHAR	;use regular output.
ED96: 0E20    	OUTCON1:LD	C,' '		;yes it is, use spaces instead.
ED98: CD48ED  		CALL	OUTCHAR
ED9B: 3A0CEF  		LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
              	
ED9E: E607    		AND	07H		;position.
EDA0: C296ED  		JP	NZ,OUTCON1
EDA3: C9      		RET
              	;
              	;   Echo a backspace character. Erase the prevoius character
              	; on the screen.
              	;
EDA4: CDACED  	BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
EDA7: 0E20    		LD	C,' '		;then blank that character.
EDA9: CD0CFA  		CALL	CONOUT
EDAC: 0E08    	BACKUP1:LD	C,BS		;then back space once more.
EDAE: C30CFA  		JP	CONOUT
              	;
              	;   Signal a deleted line. Print a '#' at the end and start
              	; over.
              	;
EDB1: 0E23    	NEWLINE:LD	C,'#'
EDB3: CD48ED  		CALL	OUTCHAR		;print this.
EDB6: CDC9ED  		CALL	OUTCRLF		;start new line.
EDB9: 3A0CEF  	NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
EDBC: 210BEF  		LD	HL,STARTING
EDBF: BE      		CP	(HL)
EDC0: D0      		RET	NC		;there yet?
EDC1: 0E20    		LD	C,' '
EDC3: CD48ED  		CALL	OUTCHAR		;nope, keep going.
EDC6: C3B9ED  		JP	NEWLN1
              	;
              	;   Output a (cr) (lf) to the console device (screen).
              	;
EDC9: 0E0D    	OUTCRLF:LD	C,CR
EDCB: CD48ED  		CALL	OUTCHAR
EDCE: 0E0A    		LD	C,LF
EDD0: C348ED  		JP	OUTCHAR
              	;
              	;   Print message pointed to by (BC). It will end with a '$'.
              	;
EDD3: 0A      	PRTMESG:LD	A,(BC)		;check for terminating character.
EDD4: FE24    		CP	'$'
EDD6: C8      		RET	Z
EDD7: 03      		INC	BC
EDD8: C5      		PUSH	BC		;otherwise, bump pointer and print it.
EDD9: 4F      		LD	C,A
EDDA: CD90ED  		CALL	OUTCON
EDDD: C1      		POP	BC
EDDE: C3D3ED  		JP	PRTMESG
              	;
              	;   Function to execute a buffered read.
              	;
EDE1: 3A0CEF  	RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
EDE4: 320BEF  		LD	(STARTING),A
EDE7: 2A43EF  		LD	HL,(PARAMS)	;get the maximum buffer space.
EDEA: 4E      		LD	C,(HL)
EDEB: 23      		INC	HL		;point to first available space.
EDEC: E5      		PUSH	HL		;and save.
EDED: 0600    		LD	B,0		;keep a character count.
EDEF: C5      	RDBUF1:	PUSH	BC
EDF0: E5      		PUSH	HL
EDF1: CDFBEC  	RDBUF2:	CALL	GETCHAR		;get the next input character.
EDF4: E67F    		AND	7FH		;strip bit 7.
EDF6: E1      		POP	HL		;reset registers.
EDF7: C1      		POP	BC
EDF8: FE0D    		CP	CR		;en of the line?
EDFA: CAC1EE  		JP	Z,RDBUF17
EDFD: FE0A    		CP	LF
EDFF: CAC1EE  		JP	Z,RDBUF17
EE02: FE08    		CP	BS		;how about a backspace?
EE04: C216EE  		JP	NZ,RDBUF3
EE07: 78      		LD	A,B		;yes, but ignore at the beginning of the line.
EE08: B7      		OR	A
EE09: CAEFED  		JP	Z,RDBUF1
EE0C: 05      		DEC	B		;ok, update counter.
EE0D: 3A0CEF  		LD	A,(CURPOS)	;if we backspace to the start of the line,
EE10: 320AEF  		LD	(OUTFLAG),A	;treat as a cancel (control-x).
EE13: C370EE  		JP	RDBUF10
EE16: FE7F    	RDBUF3:	CP	DEL		;user typed a rubout?
EE18: C226EE  		JP	NZ,RDBUF4
EE1B: 78      		LD	A,B		;ignore at the start of the line.
EE1C: B7      		OR	A
EE1D: CAEFED  		JP	Z,RDBUF1
EE20: 7E      		LD	A,(HL)		;ok, echo the prevoius character.
EE21: 05      		DEC	B		;and reset pointers (counters).
EE22: 2B      		DEC	HL
EE23: C3A9EE  		JP	RDBUF15
EE26: FE05    	RDBUF4:	CP	CNTRLE		;physical end of line?
EE28: C237EE  		JP	NZ,RDBUF5
EE2B: C5      		PUSH	BC		;yes, do it.
EE2C: E5      		PUSH	HL
EE2D: CDC9ED  		CALL	OUTCRLF
EE30: AF      		XOR	A		;and update starting position.
EE31: 320BEF  		LD	(STARTING),A
EE34: C3F1ED  		JP	RDBUF2
EE37: FE10    	RDBUF5:	CP	CNTRLP		;control-p?
EE39: C248EE  		JP	NZ,RDBUF6
EE3C: E5      		PUSH	HL		;yes, flip the print flag filp-flop byte.
EE3D: 210DEF  		LD	HL,PRTFLAG
EE40: 3E01    		LD	A,1		;PRTFLAG=1-PRTFLAG
EE42: 96      		SUB	(HL)
EE43: 77      		LD	(HL),A
EE44: E1      		POP	HL
EE45: C3EFED  		JP	RDBUF1
EE48: FE18    	RDBUF6:	CP	CNTRLX		;control-x (cancel)?
EE4A: C25FEE  		JP	NZ,RDBUF8
EE4D: E1      		POP	HL
EE4E: 3A0BEF  	RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
EE51: 210CEF  		LD	HL,CURPOS
EE54: BE      		CP	(HL)
EE55: D2E1ED  		JP	NC,RDBUFF	;done yet?
EE58: 35      		DEC	(HL)		;no, decrement pointer and output back up one space.
EE59: CDA4ED  		CALL	BACKUP
EE5C: C34EEE  		JP	RDBUF7
EE5F: FE15    	RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
EE61: C26BEE  		JP	NZ,RDBUF9
EE64: CDB1ED  		CALL	NEWLINE		;start a new line.
EE67: E1      		POP	HL
EE68: C3E1ED  		JP	RDBUFF
EE6B: FE12    	RDBUF9:	CP	CNTRLR		;control-r?
EE6D: C2A6EE  		JP	NZ,RDBUF14
EE70: C5      	RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
EE71: CDB1ED  		CALL	NEWLINE
EE74: C1      		POP	BC
EE75: E1      		POP	HL
EE76: E5      		PUSH	HL
EE77: C5      		PUSH	BC
EE78: 78      	RDBUF11:LD	A,B		;done whole line yet?
EE79: B7      		OR	A
EE7A: CA8AEE  		JP	Z,RDBUF12
EE7D: 23      		INC	HL		;nope, get next character.
EE7E: 4E      		LD	C,(HL)
EE7F: 05      		DEC	B		;count it.
EE80: C5      		PUSH	BC
EE81: E5      		PUSH	HL
EE82: CD7FED  		CALL	SHOWIT		;and display it.
EE85: E1      		POP	HL
EE86: C1      		POP	BC
EE87: C378EE  		JP	RDBUF11
EE8A: E5      	RDBUF12:PUSH	HL		;done with line. If we were displaying
EE8B: 3A0AEF  		LD	A,(OUTFLAG)	;then update cursor position.
EE8E: B7      		OR	A
EE8F: CAF1ED  		JP	Z,RDBUF2
EE92: 210CEF  		LD	HL,CURPOS	;because this line is shorter, we must
EE95: 96      		SUB	(HL)		;back up the cursor (not the screen however)
EE96: 320AEF  		LD	(OUTFLAG),A	;some number of positions.
EE99: CDA4ED  	RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
EE9C: 210AEF  		LD	HL,OUTFLAG	;zero, the screen will not be changed.
EE9F: 35      		DEC	(HL)
EEA0: C299EE  		JP	NZ,RDBUF13
EEA3: C3F1ED  		JP	RDBUF2		;now just get the next character.
              	;
              	;   Just a normal character, put this in our buffer and echo.
              	;
EEA6: 23      	RDBUF14:INC	HL
EEA7: 77      		LD	(HL),A		;store character.
EEA8: 04      		INC	B		;and count it.
EEA9: C5      	RDBUF15:PUSH	BC
EEAA: E5      		PUSH	HL
EEAB: 4F      		LD	C,A		;echo it now.
EEAC: CD7FED  		CALL	SHOWIT
EEAF: E1      		POP	HL
EEB0: C1      		POP	BC
EEB1: 7E      		LD	A,(HL)		;was it an abort request?
EEB2: FE03    		CP	CNTRLC		;control-c abort?
EEB4: 78      		LD	A,B
EEB5: C2BDEE  		JP	NZ,RDBUF16
EEB8: FE01    		CP	1		;only if at start of line.
EEBA: CA0000  		JP	Z,0
EEBD: B9      	RDBUF16:CP	C		;nope, have we filled the buffer?
EEBE: DAEFED  		JP	C,RDBUF1
EEC1: E1      	RDBUF17:POP	HL		;yes end the line and return.
EEC2: 70      		LD	(HL),B
EEC3: 0E0D    		LD	C,CR
EEC5: C348ED  		JP	OUTCHAR		;output (cr) and return.
              	;
              	;   Function to get a character from the console device.
              	;
EEC8: CD06ED  	GETCON:	CALL	GETECHO		;get and echo.
EECB: C301EF  		JP	SETSTAT		;save status and return.
              	;
              	;   Function to get a character from the tape reader device.
              	;
EECE: CD15FA  	GETRDR:	CALL	READER		;get a character from reader, set status and return.
EED1: C301EF  		JP	SETSTAT
              	;
              	;  Function to perform direct console i/o. If (C) contains (FF)
              	; then this is an input request. If (C) contains (FE) then
              	; this is a status request. Otherwise we are to output (C).
              	;
EED4: 79      	DIRCIO:	LD	A,C		;test for (FF).
EED5: 3C      		INC	A
EED6: CAE0EE  		JP	Z,DIRC1
EED9: 3C      		INC	A		;test for (FE).
EEDA: CA06FA  		JP	Z,CONST
EEDD: C30CFA  		JP	CONOUT		;just output (C).
EEE0: CD06FA  	DIRC1:	CALL	CONST		;this is an input request.
EEE3: B7      		OR	A
EEE4: CA91F9  		JP	Z,GOBACK1	;not ready? Just return (directly).
EEE7: CD09FA  		CALL	CONIN		;yes, get character.
EEEA: C301EF  		JP	SETSTAT		;set status and return.
              	;
              	;   Function to return the i/o byte.
              	;
EEED: 3A0300  	GETIOB:	LD	A,(IOBYTE)
EEF0: C301EF  		JP	SETSTAT
              	;
              	;   Function to set the i/o byte.
              	;
EEF3: 210300  	SETIOB:	LD	HL,IOBYTE
EEF6: 71      		LD	(HL),C
EEF7: C9      		RET
              	;
              	;   Function to print the character string pointed to by (DE)
              	; on the console device. The string ends with a '$'.
              	;
EEF8: EB      	PRTSTR:	EX	DE,HL
EEF9: 4D      		LD	C,L
EEFA: 44      		LD	B,H		;now (BC) points to it.
EEFB: C3D3ED  		JP	PRTMESG
              	;
              	;   Function to interigate the console device.
              	;
EEFE: CD23ED  	GETCSTS:CALL	CKCONSOL
              	;
              	;   Get here to set the status and return to the cleanup
              	; section. Then back to the user.
              	;
EF01: 3245EF  	SETSTAT:LD	(STATUS),A
EF04: C9      	RTN:	RET
              	;
              	;   Set the status to 1 (read or write error code).
              	;
EF05: 3E01    	IOERR1:	LD	A,1
EF07: C301EF  		JP	SETSTAT
              	;
EF0A: 00      	OUTFLAG:DEFB	0		;output flag (non zero means no output).
EF0B: 02      	STARTING: DEFB	2		;starting position for cursor.
EF0C: 00      	CURPOS:	DEFB	0		;cursor position (0=start of line).
EF0D: 00      	PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero.
EF0E: 00      	CHARBUF:DEFB	0		;single input character buffer.
              	;
              	;   Stack area for BDOS calls.
              	;
EF0F: 0000    	USRSTACK: DEFW	0		;save users stack pointer here.
              	;
EF11: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EF15: 00...   	
EF29: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EF2D: 00...   	
EF41:         	STKAREA EQU	$		;end of stack area.
              	;
EF41: 00      	USERNO:	DEFB	0		;current user number.
EF42: 00      	ACTIVE:	DEFB	0		;currently active drive.
EF43: 0000    	PARAMS:	DEFW	0		;save (DE) parameters here on entry.
EF45: 0000    	STATUS:	DEFW	0		;status returned from bdos function.
              	;
              	;   Select error occured, jump to error routine.
              	;
EF47: 210BEC  	SLCTERR:LD	HL,BADSLCT
              	;
              	;   Jump to (HL) indirectly.
              	;
EF4A: 5E      	JUMPHL:	LD	E,(HL)
EF4B: 23      		INC	HL
EF4C: 56      		LD	D,(HL)		;now (DE) contain the desired address.
EF4D: EB      		EX	DE,HL
EF4E: E9      		JP	(HL)
              	;
              	;   Block move. (DE) to (HL), (C) bytes total.
              	;
EF4F: 0C      	DE2HL:	INC	C		;is count down to zero?
EF50: 0D      	DE2HL1:	DEC	C
EF51: C8      		RET	Z		;yes, we are done.
EF52: 1A      		LD	A,(DE)		;no, move one more byte.
EF53: 77      		LD	(HL),A
EF54: 13      		INC	DE
EF55: 23      		INC	HL
EF56: C350EF  		JP	DE2HL1		;and repeat.
              	;
              	;   Select the desired drive.
              	;
EF59: 3A42EF  	SELECT:	LD	A,(ACTIVE)	;get active disk.
EF5C: 4F      		LD	C,A
EF5D: CD1BFA  		CALL	SELDSK		;select it.
EF60: 7C      		LD	A,H		;valid drive?
EF61: B5      		OR	L		;valid drive?
EF62: C8      		RET	Z		;return if not.
              	;
              	;   Here, the BIOS returned the address of the parameter block
              	; in (HL). We will extract the necessary pointers and save them.
              	;
EF63: 5E      		LD	E,(HL)		;yes, get address of translation table into (DE).
EF64: 23      		INC	HL
EF65: 56      		LD	D,(HL)
EF66: 23      		INC	HL
EF67: 22B3F9  		LD	(SCRATCH1),HL	;save pointers to scratch areas.
EF6A: 23      		INC	HL
EF6B: 23      		INC	HL
EF6C: 22B5F9  		LD	(SCRATCH2),HL	;ditto.
EF6F: 23      		INC	HL
EF70: 23      		INC	HL
EF71: 22B7F9  		LD	(SCRATCH3),HL	;ditto.
EF74: 23      		INC	HL
EF75: 23      		INC	HL
EF76: EB      		EX	DE,HL		;now save the translation table address.
EF77: 22D0F9  		LD	(XLATE),HL
EF7A: 21B9F9  		LD	HL,DIRBUF	;put the next 8 bytes here.
EF7D: 0E08    		LD	C,8		;they consist of the directory buffer
EF7F: CD4FEF  		CALL	DE2HL		;pointer, parameter block pointer,
EF82: 2ABBF9  		LD	HL,(DISKPB)	;check and allocation vectors.
EF85: EB      		EX	DE,HL
EF86: 21C1F9  		LD	HL,SECTORS	;move parameter block into our ram.
EF89: 0E0F    		LD	C,15		;it is 15 bytes long.
EF8B: CD4FEF  		CALL	DE2HL
EF8E: 2AC6F9  		LD	HL,(DSKSIZE)	;check disk size.
EF91: 7C      		LD	A,H		;more than 256 blocks on this?
EF92: 21DDF9  		LD	HL,BIGDISK
EF95: 36FF    		LD	(HL),0FFH	;set to samll.
EF97: B7      		OR	A
EF98: CA9DEF  		JP	Z,SELECT1
EF9B: 3600    		LD	(HL),0		;wrong, set to large.
EF9D: 3EFF    	SELECT1:LD	A,0FFH		;clear the zero flag.
EF9F: B7      		OR	A
EFA0: C9      		RET
              	;
              	;   Routine to home the disk track head and clear pointers.
              	;
EFA1: CD18FA  	HOMEDRV:CALL	HOME		;home the head.
EFA4: AF      		XOR	A
EFA5: 2AB5F9  		LD	HL,(SCRATCH2)	;set our track pointer also.
EFA8: 77      		LD	(HL),A
EFA9: 23      		INC	HL
EFAA: 77      		LD	(HL),A
EFAB: 2AB7F9  		LD	HL,(SCRATCH3)	;and our sector pointer.
EFAE: 77      		LD	(HL),A
EFAF: 23      		INC	HL
EFB0: 77      		LD	(HL),A
EFB1: C9      		RET
              	;
              	;   Do the actual disk read and check the error return status.
              	;
EFB2: CD27FA  	DOREAD:	CALL	READ
EFB5: C3BBEF  		JP	IORET
              	;
              	;   Do the actual disk write and handle any bios error.
              	;
EFB8: CD2AFA  	DOWRITE:CALL	WRITE
EFBB: B7      	IORET:	OR	A
EFBC: C8      		RET	Z		;return unless an error occured.
EFBD: 2109EC  		LD	HL,BADSCTR	;bad read/write on this sector.
EFC0: C34AEF  		JP	JUMPHL
              	;
              	;   Routine to select the track and sector that the desired
              	; block number falls in.
              	;
EFC3: 2AEAF9  	TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
EFC6: 0E02    		LD	C,2		;in directory and compute sector #.
EFC8: CDEAF0  		CALL	SHIFTR		;sector #=file-position/4.
EFCB: 22E5F9  		LD	(BLKNMBR),HL	;save this as the block number of interest.
EFCE: 22ECF9  		LD	(CKSUMTBL),HL	;what's it doing here too?
              	;
              	;   if the sector number has already been set (BLKNMBR), enter
              	; at this point.
              	;
EFD1: 21E5F9  	TRKSEC1:LD	HL,BLKNMBR
EFD4: 4E      		LD	C,(HL)		;move sector number into (BC).
EFD5: 23      		INC	HL
EFD6: 46      		LD	B,(HL)
EFD7: 2AB7F9  		LD	HL,(SCRATCH3)	;get current sector number and
EFDA: 5E      		LD	E,(HL)		;move this into (DE).
EFDB: 23      		INC	HL
EFDC: 56      		LD	D,(HL)
EFDD: 2AB5F9  		LD	HL,(SCRATCH2)	;get current track number.
EFE0: 7E      		LD	A,(HL)		;and this into (HL).
EFE1: 23      		INC	HL
EFE2: 66      		LD	H,(HL)
EFE3: 6F      		LD	L,A
EFE4: 79      	TRKSEC2:LD	A,C		;is desired sector before current one?
EFE5: 93      		SUB	E
EFE6: 78      		LD	A,B
EFE7: 9A      		SBC	A,D
EFE8: D2FAEF  		JP	NC,TRKSEC3
EFEB: E5      		PUSH	HL		;yes, decrement sectors by one track.
EFEC: 2AC1F9  		LD	HL,(SECTORS)	;get sectors per track.
EFEF: 7B      		LD	A,E
EFF0: 95      		SUB	L
EFF1: 5F      		LD	E,A
EFF2: 7A      		LD	A,D
EFF3: 9C      		SBC	A,H
EFF4: 57      		LD	D,A		;now we have backed up one full track.
EFF5: E1      		POP	HL
EFF6: 2B      		DEC	HL		;adjust track counter.
EFF7: C3E4EF  		JP	TRKSEC2
EFFA: E5      	TRKSEC3:PUSH	HL		;desired sector is after current one.
EFFB: 2AC1F9  		LD	HL,(SECTORS)	;get sectors per track.
EFFE: 19      		ADD	HL,DE		;bump sector pointer to next track.
EFFF: DA0FF0  		JP	C,TRKSEC4
F002: 79      		LD	A,C		;is desired sector now before current one?
F003: 95      		SUB	L
F004: 78      		LD	A,B
F005: 9C      		SBC	A,H
F006: DA0FF0  		JP	C,TRKSEC4
F009: EB      		EX	DE,HL		;not yes, increment track counter
F00A: E1      		POP	HL		;and continue until it is.
F00B: 23      		INC	HL
F00C: C3FAEF  		JP	TRKSEC3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
F00F: E1      	TRKSEC4:POP	HL		;get track number (HL).
F010: C5      		PUSH	BC
F011: D5      		PUSH	DE
F012: E5      		PUSH	HL
F013: EB      		EX	DE,HL
F014: 2ACEF9  		LD	HL,(OFFSET)	;adjust for first track offset.
F017: 19      		ADD	HL,DE
F018: 44      		LD	B,H
F019: 4D      		LD	C,L
F01A: CD1EFA  		CALL	SETTRK		;select this track.
F01D: D1      		POP	DE		;reset current track pointer.
F01E: 2AB5F9  		LD	HL,(SCRATCH2)
F021: 73      		LD	(HL),E
F022: 23      		INC	HL
F023: 72      		LD	(HL),D
F024: D1      		POP	DE
F025: 2AB7F9  		LD	HL,(SCRATCH3)	;reset the first sector on this track.
F028: 73      		LD	(HL),E
F029: 23      		INC	HL
F02A: 72      		LD	(HL),D
F02B: C1      		POP	BC
F02C: 79      		LD	A,C		;now subtract the desired one.
F02D: 93      		SUB	E		;to make it relative (1-# sectors/track).
F02E: 4F      		LD	C,A
F02F: 78      		LD	A,B
F030: 9A      		SBC	A,D
F031: 47      		LD	B,A
F032: 2AD0F9  		LD	HL,(XLATE)	;translate this sector according to this table.
F035: EB      		EX	DE,HL
F036: CD30FA  		CALL	SECTRN		;let the bios translate it.
F039: 4D      		LD	C,L
F03A: 44      		LD	B,H
F03B: C321FA  		JP	SETSEC		;and select it.
              	;
              	;   Compute block number from record number (SAVNREC) and
              	; extent number (SAVEXT).
              	;
F03E: 21C3F9  	GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
F041: 4E      		LD	C,(HL)		;note that this is base 2 log of ratio.
F042: 3AE3F9  		LD	A,(SAVNREC)	;get record number.
F045: B7      	GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
F046: 1F      		RRA
F047: 0D      		DEC	C
F048: C245F0  		JP	NZ,GETBLK1
F04B: 47      		LD	B,A		;save result in (B).
F04C: 3E08    		LD	A,8
F04E: 96      		SUB	(HL)
F04F: 4F      		LD	C,A		;compute (C)=8-BLKSHFT.
F050: 3AE2F9  		LD	A,(SAVEXT)
F053: 0D      	GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
F054: CA5CF0  		JP	Z,GETBLK3
F057: B7      		OR	A
F058: 17      		RLA
F059: C353F0  		JP	GETBLK2
F05C: 80      	GETBLK3:ADD	A,B
F05D: C9      		RET
              	;
              	;   Routine to extract the (BC) block byte from the fcb pointed
              	; to by (PARAMS). If this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; Number is returned in (HL).
              	;
F05E: 2A43EF  	EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
F061: 111000  		LD	DE,16		;block numbers start 16 bytes into fcb.
F064: 19      		ADD	HL,DE
F065: 09      		ADD	HL,BC
F066: 3ADDF9  		LD	A,(BIGDISK)	;are we using a big-disk?
F069: B7      		OR	A
F06A: CA71F0  		JP	Z,EXTBLK1
F06D: 6E      		LD	L,(HL)		;no, extract an 8 bit number from the fcb.
F06E: 2600    		LD	H,0
F070: C9      		RET
F071: 09      	EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
F072: 5E      		LD	E,(HL)
F073: 23      		INC	HL
F074: 56      		LD	D,(HL)
F075: EB      		EX	DE,HL		;return in (HL).
F076: C9      		RET
              	;
              	;   Compute block number.
              	;
F077: CD3EF0  	COMBLK:	CALL	GETBLOCK
F07A: 4F      		LD	C,A
F07B: 0600    		LD	B,0
F07D: CD5EF0  		CALL	EXTBLK
F080: 22E5F9  		LD	(BLKNMBR),HL
F083: C9      		RET
              	;
              	;   Check for a zero block number (unused).
              	;
F084: 2AE5F9  	CHKBLK:	LD	HL,(BLKNMBR)
F087: 7D      		LD	A,L		;is it zero?
F088: B4      		OR	H
F089: C9      		RET
              	;
              	;   Adjust physical block (BLKNMBR) and convert to logical
              	; sector (LOGSECT). This is the starting sector of this block.
              	; The actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (BLKNMBR). This
              	; will still have to be adjusted for the track number.
              	;
F08A: 3AC3F9  	LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
F08D: 2AE5F9  		LD	HL,(BLKNMBR)	;get physical sector desired.
F090: 29      	LOGICL1:ADD	HL,HL		;compute logical sector number.
F091: 3D      		DEC	A		;note logical sectors are 128 bytes long.
F092: C290F0  		JP	NZ,LOGICL1
F095: 22E7F9  		LD	(LOGSECT),HL	;save logical sector.
F098: 3AC4F9  		LD	A,(BLKMASK)	;get block mask.
F09B: 4F      		LD	C,A
F09C: 3AE3F9  		LD	A,(SAVNREC)	;get next sector to access.
F09F: A1      		AND	C		;extract the relative position within physical block.
F0A0: B5      		OR	L		;and add it too logical sector.
F0A1: 6F      		LD	L,A
F0A2: 22E5F9  		LD	(BLKNMBR),HL	;and store.
F0A5: C9      		RET
              	;
              	;   Set (HL) to point to extent byte in fcb.
              	;
F0A6: 2A43EF  	SETEXT:	LD	HL,(PARAMS)
F0A9: 110C00  		LD	DE,12		;it is the twelth byte.
F0AC: 19      		ADD	HL,DE
F0AD: C9      		RET
              	;
              	;   Set (HL) to point to record count byte in fcb and (DE) to
              	; next record number byte.
              	;
F0AE: 2A43EF  	SETHLDE:LD	HL,(PARAMS)
F0B1: 110F00  		LD	DE,15		;record count byte (#15).
F0B4: 19      		ADD	HL,DE
F0B5: EB      		EX	DE,HL
F0B6: 211100  		LD	HL,17		;next record number (#32).
F0B9: 19      		ADD	HL,DE
F0BA: C9      		RET
              	;
              	;   Save current file data from fcb.
              	;
F0BB: CDAEF0  	STRDATA:CALL	SETHLDE
F0BE: 7E      		LD	A,(HL)		;get and store record count byte.
F0BF: 32E3F9  		LD	(SAVNREC),A
F0C2: EB      		EX	DE,HL
F0C3: 7E      		LD	A,(HL)		;get and store next record number byte.
F0C4: 32E1F9  		LD	(SAVNXT),A
F0C7: CDA6F0  		CALL	SETEXT		;point to extent byte.
F0CA: 3AC5F9  		LD	A,(EXTMASK)	;get extent mask.
F0CD: A6      		AND	(HL)
F0CE: 32E2F9  		LD	(SAVEXT),A	;and save extent here.
F0D1: C9      		RET
              	;
              	;   Set the next record to access. If (MODE) is set to 2, then
              	; the last record byte (SAVNREC) has the correct number to access.
              	; For sequential access, (MODE) will be equal to 1.
              	;
F0D2: CDAEF0  	SETNREC:CALL	SETHLDE
F0D5: 3AD5F9  		LD	A,(MODE)	;get sequential flag (=1).
F0D8: FE02    		CP	2		;a 2 indicates that no adder is needed.
F0DA: C2DEF0  		JP	NZ,STNREC1
F0DD: AF      		XOR	A		;clear adder (random access?).
F0DE: 4F      	STNREC1:LD	C,A
F0DF: 3AE3F9  		LD	A,(SAVNREC)	;get last record number.
F0E2: 81      		ADD	A,C		;increment record count.
F0E3: 77      		LD	(HL),A		;and set fcb's next record byte.
F0E4: EB      		EX	DE,HL
F0E5: 3AE1F9  		LD	A,(SAVNXT)	;get next record byte from storage.
F0E8: 77      		LD	(HL),A		;and put this into fcb as number of records used.
F0E9: C9      		RET
              	;
              	;   Shift (HL) right (C) bits.
              	;
F0EA: 0C      	SHIFTR:	INC	C
F0EB: 0D      	SHIFTR1:DEC	C
F0EC: C8      		RET	Z
F0ED: 7C      		LD	A,H
F0EE: B7      		OR	A
F0EF: 1F      		RRA
F0F0: 67      		LD	H,A
F0F1: 7D      		LD	A,L
F0F2: 1F      		RRA
F0F3: 6F      		LD	L,A
F0F4: C3EBF0  		JP	SHIFTR1
              	;
              	;   Compute the check-sum for the directory buffer. Return
              	; integer sum in (A).
              	;
F0F7: 0E80    	CHECKSUM: LD	C,128		;length of buffer.
F0F9: 2AB9F9  		LD	HL,(DIRBUF)	;get its location.
F0FC: AF      		XOR	A		;clear summation byte.
F0FD: 86      	CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries.
F0FE: 23      		INC	HL
F0FF: 0D      		DEC	C
F100: C2FDF0  		JP	NZ,CHKSUM1
F103: C9      		RET
              	;
              	;   Shift (HL) left (C) bits.
              	;
F104: 0C      	SHIFTL:	INC	C
F105: 0D      	SHIFTL1:DEC	C
F106: C8      		RET	Z
F107: 29      		ADD	HL,HL		;shift left 1 bit.
F108: C305F1  		JP	SHIFTL1
              	;
              	;   Routine to set a bit in a 16 bit value contained in (BC).
              	; The bit set depends on the current drive selection.
              	;
F10B: C5      	SETBIT:	PUSH	BC		;save 16 bit word.
F10C: 3A42EF  		LD	A,(ACTIVE)	;get active drive.
F10F: 4F      		LD	C,A
F110: 210100  		LD	HL,1
F113: CD04F1  		CALL	SHIFTL		;shift bit 0 into place.
F116: C1      		POP	BC		;now 'or' this with the original word.
F117: 79      		LD	A,C
F118: B5      		OR	L
F119: 6F      		LD	L,A		;low byte done, do high byte.
F11A: 78      		LD	A,B
F11B: B4      		OR	H
F11C: 67      		LD	H,A
F11D: C9      		RET
              	;
              	;   Extract the write protect status bit for the current drive.
              	; The result is returned in (A), bit 0.
              	;
F11E: 2AADF9  	GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
F121: 3A42EF  		LD	A,(ACTIVE)	;which drive is current?
F124: 4F      		LD	C,A
F125: CDEAF0  		CALL	SHIFTR		;shift status such that bit 0 is the
F128: 7D      		LD	A,L		;one of interest for this drive.
F129: E601    		AND	01H		;and isolate it.
F12B: C9      		RET
              	;
              	;   Function to write protect the current disk.
              	;
F12C: 21ADF9  	WRTPRTD:LD	HL,WRTPRT	;point to status word.
F12F: 4E      		LD	C,(HL)		;set (BC) equal to the status.
F130: 23      		INC	HL
F131: 46      		LD	B,(HL)
F132: CD0BF1  		CALL	SETBIT		;and set this bit according to current drive.
F135: 22ADF9  		LD	(WRTPRT),HL	;then save.
F138: 2AC8F9  		LD	HL,(DIRSIZE)	;now save directory size limit.
F13B: 23      		INC	HL		;remember the last one.
F13C: EB      		EX	DE,HL
F13D: 2AB3F9  		LD	HL,(SCRATCH1)	;and store it here.
F140: 73      		LD	(HL),E		;put low byte.
F141: 23      		INC	HL
F142: 72      		LD	(HL),D		;then high byte.
F143: C9      		RET
              	;
              	;   Check for a read only file.
              	;
F144: CD5EF1  	CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
F147: 110900  	CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
F14A: 19      		ADD	HL,DE
F14B: 7E      		LD	A,(HL)
F14C: 17      		RLA
F14D: D0      		RET	NC		;return if ok.
F14E: 210FEC  		LD	HL,ROFILE	;else, print error message and terminate.
F151: C34AEF  		JP	JUMPHL
              	;
              	;   Check the write protect status of the active disk.
              	;
F154: CD1EF1  	CHKWPRT:CALL	GETWPRT
F157: C8      		RET	Z		;return if ok.
F158: 210DEC  		LD	HL,RODISK	;else print message and terminate.
F15B: C34AEF  		JP	JUMPHL
              	;
              	;   Routine to set (HL) pointing to the proper entry in the
              	; directory buffer.
              	;
F15E: 2AB9F9  	FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
F161: 3AE9F9  		LD	A,(FCBPOS)	;relative position of file.
              	;
              	;   Routine to add (A) to (HL).
              	;
F164: 85      	ADDA2HL:ADD	A,L
F165: 6F      		LD	L,A
F166: D0      		RET	NC
F167: 24      		INC	H		;take care of any carry.
F168: C9      		RET
              	;
              	;   Routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
F169: 2A43EF  	GETS2:	LD	HL,(PARAMS)	;get address of fcb.
F16C: 110E00  		LD	DE,14		;relative position of 's2'.
F16F: 19      		ADD	HL,DE
F170: 7E      		LD	A,(HL)		;extract this byte.
F171: C9      		RET
              	;
              	;   Clear the 's2' byte in the fcb.
              	;
F172: CD69F1  	CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
F175: 3600    		LD	(HL),0		;now clear it.
F177: C9      		RET
              	;
              	;   Set bit 7 in the 's2' byte of the fcb.
              	;
F178: CD69F1  	SETS2B7:CALL	GETS2		;get the byte.
F17B: F680    		OR	80H		;and set bit 7.
F17D: 77      		LD	(HL),A		;then store.
F17E: C9      		RET
              	;
              	;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
              	; the difference. This checks to see if there are more file
              	; names in the directory. We are at (FILEPOS) and there are
              	; (SCRATCH1) of them to check.
              	;
F17F: 2AEAF9  	MOREFLS:LD	HL,(FILEPOS)	;we are here.
F182: EB      		EX	DE,HL
F183: 2AB3F9  		LD	HL,(SCRATCH1)	;and don't go past here.
F186: 7B      		LD	A,E		;compute difference but don't keep.
F187: 96      		SUB	(HL)
F188: 23      		INC	HL
F189: 7A      		LD	A,D
F18A: 9E      		SBC	A,(HL)		;set carry if no more names.
F18B: C9      		RET
              	;
              	;   Call this routine to prevent (SCRATCH1) from being greater
              	; than (FILEPOS).
              	;
F18C: CD7FF1  	CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
F18F: D8      		RET	C
F190: 13      		INC	DE		;yes, reset it to (FILEPOS).
F191: 72      		LD	(HL),D
F192: 2B      		DEC	HL
F193: 73      		LD	(HL),E
F194: C9      		RET
              	;
              	;   Compute (HL)=(DE)-(HL)
              	;
F195: 7B      	SUBHL:	LD	A,E		;compute difference.
F196: 95      		SUB	L
F197: 6F      		LD	L,A		;store low byte.
F198: 7A      		LD	A,D
F199: 9C      		SBC	A,H
F19A: 67      		LD	H,A		;and then high byte.
F19B: C9      		RET
              	;
              	;   Set the directory checksum byte.
              	;
F19C: 0EFF    	SETDIR:	LD	C,0FFH
              	;
              	;   Routine to set or compare the directory checksum byte. If
              	; (C)=0ffh, then this will set the checksum byte. Else the byte
              	; will be checked. If the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
F19E: 2AECF9  	CHECKDIR: LD	HL,(CKSUMTBL)
F1A1: EB      		EX	DE,HL
F1A2: 2ACCF9  		LD	HL,(ALLOC1)
F1A5: CD95F1  		CALL	SUBHL
F1A8: D0      		RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
F1A9: C5      		PUSH	BC
F1AA: CDF7F0  		CALL	CHECKSUM	;else compute checksum.
F1AD: 2ABDF9  		LD	HL,(CHKVECT)	;get address of checksum table.
F1B0: EB      		EX	DE,HL
F1B1: 2AECF9  		LD	HL,(CKSUMTBL)
F1B4: 19      		ADD	HL,DE		;set (HL) to point to byte for this drive.
F1B5: C1      		POP	BC
F1B6: 0C      		INC	C		;set or check ?
F1B7: CAC4F1  		JP	Z,CHKDIR1
F1BA: BE      		CP	(HL)		;check them.
F1BB: C8      		RET	Z		;return if they are the same.
F1BC: CD7FF1  		CALL	MOREFLS		;not the same, do we care?
F1BF: D0      		RET	NC
F1C0: CD2CF1  		CALL	WRTPRTD		;yes, mark this as write protected.
F1C3: C9      		RET
F1C4: 77      	CHKDIR1:LD	(HL),A		;just set the byte.
F1C5: C9      		RET
              	;
              	;   Do a write to the directory of the current disk.
              	;
F1C6: CD9CF1  	DIRWRITE: CALL	SETDIR		;set checksum byte.
F1C9: CDE0F1  		CALL	DIRDMA		;set directory dma address.
F1CC: 0E01    		LD	C,1		;tell the bios to actually write.
F1CE: CDB8EF  		CALL	DOWRITE		;then do the write.
F1D1: C3DAF1  		JP	DEFDMA
              	;
              	;   Read from the directory.
              	;
F1D4: CDE0F1  	DIRREAD:CALL	DIRDMA		;set the directory dma address.
F1D7: CDB2EF  		CALL	DOREAD		;and read it.
              	;
              	;   Routine to set the dma address to the users choice.
              	;
F1DA: 21B1F9  	DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
F1DD: C3E3F1  		JP	DIRDMA1
              	;
              	;   Routine to set the dma address for directory work.
              	;
F1E0: 21B9F9  	DIRDMA:	LD	HL,DIRBUF
              	;
              	;   Set the dma address. On entry, (HL) points to
              	; word containing the desired dma address.
              	;
F1E3: 4E      	DIRDMA1:LD	C,(HL)
F1E4: 23      		INC	HL
F1E5: 46      		LD	B,(HL)		;setup (BC) and go to the bios to set it.
F1E6: C324FA  		JP	SETDMA
              	;
              	;   Move the directory buffer into user's dma space.
              	;
F1E9: 2AB9F9  	MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
F1EC: EB      		EX	DE,HL
F1ED: 2AB1F9  		LD	HL,(USERDMA)	; put it here.
F1F0: 0E80    		LD	C,128		;this is its length.
F1F2: C34FEF  		JP	DE2HL		;move it now and return.
              	;
              	;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
              	;
F1F5: 21EAF9  	CKFILPOS: LD	HL,FILEPOS
F1F8: 7E      		LD	A,(HL)
F1F9: 23      		INC	HL
F1FA: BE      		CP	(HL)		;are both bytes the same?
F1FB: C0      		RET	NZ
F1FC: 3C      		INC	A		;yes, but are they each 0ffh?
F1FD: C9      		RET
              	;
              	;   Set location (FILEPOS) to 0ffffh.
              	;
F1FE: 21FFFF  	STFILPOS: LD	HL,0FFFFH
F201: 22EAF9  		LD	(FILEPOS),HL
F204: C9      		RET
              	;
              	;   Move on to the next file position within the current
              	; directory buffer. If no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. Enter with (C)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
F205: 2AC8F9  	NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
F208: EB      		EX	DE,HL
F209: 2AEAF9  		LD	HL,(FILEPOS)	;get current count.
F20C: 23      		INC	HL		;go on to the next one.
F20D: 22EAF9  		LD	(FILEPOS),HL
F210: CD95F1  		CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
F213: D219F2  		JP	NC,NXENT1	;is there more room left?
F216: C3FEF1  		JP	STFILPOS	;no. Set this flag and return.
F219: 3AEAF9  	NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
F21C: E603    		AND	03H		;only look within this sector (only 4 entries fit).
F21E: 0605    		LD	B,5		;convert to relative position (32 bytes each).
F220: 87      	NXENT2:	ADD	A,A		;note that this is not efficient code.
F221: 05      		DEC	B		;5 'ADD A's would be better.
F222: C220F2  		JP	NZ,NXENT2
F225: 32E9F9  		LD	(FCBPOS),A	;save it as position of fcb.
F228: B7      		OR	A
F229: C0      		RET	NZ		;return if we are within buffer.
F22A: C5      		PUSH	BC
F22B: CDC3EF  		CALL	TRKSEC		;we need the next directory sector.
F22E: CDD4F1  		CALL	DIRREAD
F231: C1      		POP	BC
F232: C39EF1  		JP	CHECKDIR
              	;
              	;   Routine to to get a bit from the disk space allocation
              	; map. It is returned in (A), bit position 0. On entry to here,
              	; set (BC) to the block number on the disk to check.
              	; On return, (D) will contain the original bit position for
              	; this block number and (HL) will point to the address for it.
              	;
F235: 79      	CKBITMAP: LD	A,C		;determine bit number of interest.
F236: E607    		AND	07H		;compute (D)=(E)=(C and 7)+1.
F238: 3C      		INC	A
F239: 5F      		LD	E,A		;save particular bit number.
F23A: 57      		LD	D,A
              	;
              	;   compute (BC)=(BC)/8.
              	;
F23B: 79      		LD	A,C
F23C: 0F      		RRCA			;now shift right 3 bits.
F23D: 0F      		RRCA
F23E: 0F      		RRCA
F23F: E61F    		AND	1FH		;and clear bits 7,6,5.
F241: 4F      		LD	C,A
F242: 78      		LD	A,B
F243: 87      		ADD	A,A		;now shift (B) into bits 7,6,5.
F244: 87      		ADD	A,A
F245: 87      		ADD	A,A
F246: 87      		ADD	A,A
F247: 87      		ADD	A,A
F248: B1      		OR	C		;and add in (C).
F249: 4F      		LD	C,A		;ok, (C) ha been completed.
F24A: 78      		LD	A,B		;is there a better way of doing this?
F24B: 0F      		RRCA
F24C: 0F      		RRCA
F24D: 0F      		RRCA
F24E: E61F    		AND	1FH
F250: 47      		LD	B,A		;and now (B) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
F251: 2ABFF9  		LD	HL,(ALOCVECT)
F254: 09      		ADD	HL,BC
F255: 7E      		LD	A,(HL)		;now get correct byte.
F256: 07      	CKBMAP1:RLCA			;get correct bit into position 0.
F257: 1D      		DEC	E
F258: C256F2  		JP	NZ,CKBMAP1
F25B: C9      		RET
              	;
              	;   Set or clear the bit map such that block number (BC) will be marked
              	; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
F25C: D5      	STBITMAP: PUSH	DE
F25D: CD35F2  		CALL	CKBITMAP	;get the byte of interest.
F260: E6FE    		AND	0FEH		;clear the affected bit.
F262: C1      		POP	BC
F263: B1      		OR	C		;and now set it acording to (C).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (A) contains the value, (D) contains the bit
              	; position (1-8), and (HL) points to the address within the
              	; space allocation table for this byte.
              	;
F264: 0F      	STBMAP1:RRCA			;restore original bit position.
F265: 15      		DEC	D
F266: C264F2  		JP	NZ,STBMAP1
F269: 77      		LD	(HL),A		;and stor byte in table.
F26A: C9      		RET
              	;
              	;   Set/clear space used bits in allocation map for this file.
              	; On entry, (C)=1 to set the map and (C)=0 to clear it.
              	;
F26B: CD5EF1  	SETFILE:CALL	FCB2HL		;get address of fcb
F26E: 111000  		LD	DE,16
F271: 19      		ADD	HL,DE		;get to block number bytes.
F272: C5      		PUSH	BC
F273: 0E11    		LD	C,17		;check all 17 bytes (max) of table.
F275: D1      	SETFL1:	POP	DE
F276: 0D      		DEC	C		;done all bytes yet?
F277: C8      		RET	Z
F278: D5      		PUSH	DE
F279: 3ADDF9  		LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
F27C: B7      		OR	A
F27D: CA88F2  		JP	Z,SETFL2
F280: C5      		PUSH	BC		;only 8 bit numbers. set (BC) to this one.
F281: E5      		PUSH	HL
F282: 4E      		LD	C,(HL)		;get low byte from table, always
F283: 0600    		LD	B,0		;set high byte to zero.
F285: C38EF2  		JP	SETFL3
F288: 0D      	SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
F289: C5      		PUSH	BC
F28A: 4E      		LD	C,(HL)		;now get both the low and high bytes.
F28B: 23      		INC	HL
F28C: 46      		LD	B,(HL)
F28D: E5      		PUSH	HL
F28E: 79      	SETFL3:	LD	A,C		;block used?
F28F: B0      		OR	B
F290: CA9DF2  		JP	Z,SETFL4
F293: 2AC6F9  		LD	HL,(DSKSIZE)	;is this block number within the
F296: 7D      		LD	A,L		;space on the disk?
F297: 91      		SUB	C
F298: 7C      		LD	A,H
F299: 98      		SBC	A,B
F29A: D45CF2  		CALL	NC,STBITMAP	;yes, set the proper bit.
F29D: E1      	SETFL4:	POP	HL		;point to next block number in fcb.
F29E: 23      		INC	HL
F29F: C1      		POP	BC
F2A0: C375F2  		JP	SETFL1
              	;
              	;   Construct the space used allocation bit map for the active
              	; drive. If a file name starts with '$' and it is under the
              	; current user number, then (STATUS) is set to minus 1. Otherwise
              	; it is not set at all.
              	;
F2A3: 2AC6F9  	BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
F2A6: 0E03    		LD	C,3
F2A8: CDEAF0  		CALL	SHIFTR		;(HL)=(HL)/8.
F2AB: 23      		INC	HL		;at lease 1 byte.
F2AC: 44      		LD	B,H
F2AD: 4D      		LD	C,L		;set (BC) to the allocation table length.
              	;
              	;   Initialize the bitmap for this drive. Right now, the first
              	; two bytes are specified by the disk parameter block. However
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. For example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
F2AE: 2ABFF9  		LD	HL,(ALOCVECT)	;now zero out the table now.
F2B1: 3600    	BITMAP1:LD	(HL),0
F2B3: 23      		INC	HL
F2B4: 0B      		DEC	BC
F2B5: 78      		LD	A,B
F2B6: B1      		OR	C
F2B7: C2B1F2  		JP	NZ,BITMAP1
F2BA: 2ACAF9  		LD	HL,(ALLOC0)	;get initial space used by directory.
F2BD: EB      		EX	DE,HL
F2BE: 2ABFF9  		LD	HL,(ALOCVECT)	;and put this into map.
F2C1: 73      		LD	(HL),E
F2C2: 23      		INC	HL
F2C3: 72      		LD	(HL),D
              	;
              	;   End of initialization portion.
              	;
F2C4: CDA1EF  		CALL	HOMEDRV		;now home the drive.
F2C7: 2AB3F9  		LD	HL,(SCRATCH1)
F2CA: 3603    		LD	(HL),3		;force next directory request to read
F2CC: 23      		INC	HL		;in a sector.
F2CD: 3600    		LD	(HL),0
F2CF: CDFEF1  		CALL	STFILPOS	;clear initial file position also.
F2D2: 0EFF    	BITMAP2:LD	C,0FFH		;read next file name in directory
F2D4: CD05F2  		CALL	NXENTRY		;and set checksum byte.
F2D7: CDF5F1  		CALL	CKFILPOS	;is there another file?
F2DA: C8      		RET	Z
F2DB: CD5EF1  		CALL	FCB2HL		;yes, get its address.
F2DE: 3EE5    		LD	A,0E5H
F2E0: BE      		CP	(HL)		;empty file entry?
F2E1: CAD2F2  		JP	Z,BITMAP2
F2E4: 3A41EF  		LD	A,(USERNO)	;no, correct user number?
F2E7: BE      		CP	(HL)
F2E8: C2F6F2  		JP	NZ,BITMAP3
F2EB: 23      		INC	HL
F2EC: 7E      		LD	A,(HL)		;yes, does name start with a '$'?
F2ED: D624    		SUB	'$'
F2EF: C2F6F2  		JP	NZ,BITMAP3
F2F2: 3D      		DEC	A		;yes, set atatus to minus one.
F2F3: 3245EF  		LD	(STATUS),A
F2F6: 0E01    	BITMAP3:LD	C,1		;now set this file's space as used in bit map.
F2F8: CD6BF2  		CALL	SETFILE
F2FB: CD8CF1  		CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
F2FE: C3D2F2  		JP	BITMAP2
              	;
              	;   Set the status (STATUS) and return.
              	;
F301: 3AD4F9  	STSTATUS: LD	A,(FNDSTAT)
F304: C301EF  		JP	SETSTAT
              	;
              	;   Check extents in (A) and (C). Set the zero flag if they
              	; are the same. The number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (EXTMASK+1).
              	; No registers are modified.
              	;
F307: C5      	SAMEXT:	PUSH	BC
F308: F5      		PUSH	AF
F309: 3AC5F9  		LD	A,(EXTMASK)	;get extent mask and use it to
F30C: 2F      		CPL			;to compare both extent numbers.
F30D: 47      		LD	B,A		;save resulting mask here.
F30E: 79      		LD	A,C		;mask first extent and save in (C).
F30F: A0      		AND	B
F310: 4F      		LD	C,A
F311: F1      		POP	AF		;now mask second extent and compare
F312: A0      		AND	B		;with the first one.
F313: 91      		SUB	C
F314: E61F    		AND	1FH		;(* only check buts 0-4 *)
F316: C1      		POP	BC		;the zero flag is set if they are the same.
F317: C9      		RET			;restore (BC) and return.
              	;
              	;   Search for the first occurence of a file name. On entry,
              	; register (C) should contain the number of bytes of the fcb
              	; that must match.
              	;
F318: 3EFF    	FINDFST:LD	A,0FFH
F31A: 32D4F9  		LD	(FNDSTAT),A
F31D: 21D8F9  		LD	HL,COUNTER	;save character count.
F320: 71      		LD	(HL),C
F321: 2A43EF  		LD	HL,(PARAMS)	;get filename to match.
F324: 22D9F9  		LD	(SAVEFCB),HL	;and save.
F327: CDFEF1  		CALL	STFILPOS	;clear initial file position (set to 0ffffh).
F32A: CDA1EF  		CALL	HOMEDRV		;home the drive.
              	;
              	;   Entry to locate the next occurence of a filename within the
              	; directory. The disk is not expected to have been changed. If
              	; it was, then it will be write protected.
              	;
F32D: 0E00    	FINDNXT:LD	C,0		;write protect the disk if changed.
F32F: CD05F2  		CALL	NXENTRY		;get next filename entry in directory.
F332: CDF5F1  		CALL	CKFILPOS	;is file position = 0ffffh?
F335: CA94F3  		JP	Z,FNDNXT6	;yes, exit now then.
F338: 2AD9F9  		LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
F33B: EB      		EX	DE,HL
F33C: 1A      		LD	A,(DE)
F33D: FEE5    		CP	0E5H		;empty directory entry?
F33F: CA4AF3  		JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
F342: D5      		PUSH	DE
F343: CD7FF1  		CALL	MOREFLS		;more files in directory?
F346: D1      		POP	DE
F347: D294F3  		JP	NC,FNDNXT6	;no more. Exit now.
F34A: CD5EF1  	FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
F34D: 3AD8F9  		LD	A,(COUNTER)	;get number of bytes (characters) to check.
F350: 4F      		LD	C,A
F351: 0600    		LD	B,0		;initialize byte position counter.
F353: 79      	FNDNXT2:LD	A,C		;are we done with the compare?
F354: B7      		OR	A
F355: CA83F3  		JP	Z,FNDNXT5
F358: 1A      		LD	A,(DE)		;no, check next byte.
F359: FE3F    		CP	'?'		;don't care about this character?
F35B: CA7CF3  		JP	Z,FNDNXT4
F35E: 78      		LD	A,B		;get bytes position in fcb.
F35F: FE0D    		CP	13		;don't care about the thirteenth byte either.
F361: CA7CF3  		JP	Z,FNDNXT4
F364: FE0C    		CP	12		;extent byte?
F366: 1A      		LD	A,(DE)
F367: CA73F3  		JP	Z,FNDNXT3
F36A: 96      		SUB	(HL)		;otherwise compare characters.
F36B: E67F    		AND	7FH
F36D: C22DF3  		JP	NZ,FINDNXT	;not the same, check next entry.
F370: C37CF3  		JP	FNDNXT4		;so far so good, keep checking.
F373: C5      	FNDNXT3:PUSH	BC		;check the extent byte here.
F374: 4E      		LD	C,(HL)
F375: CD07F3  		CALL	SAMEXT
F378: C1      		POP	BC
F379: C22DF3  		JP	NZ,FINDNXT	;not the same, look some more.
              	;
              	;   So far the names compare. Bump pointers to the next byte
              	; and continue until all (C) characters have been checked.
              	;
F37C: 13      	FNDNXT4:INC	DE		;bump pointers.
F37D: 23      		INC	HL
F37E: 04      		INC	B
F37F: 0D      		DEC	C		;adjust character counter.
F380: C353F3  		JP	FNDNXT2
F383: 3AEAF9  	FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
F386: E603    		AND	03H
F388: 3245EF  		LD	(STATUS),A
F38B: 21D4F9  		LD	HL,FNDSTAT
F38E: 7E      		LD	A,(HL)
F38F: 17      		RLA
F390: D0      		RET	NC
F391: AF      		XOR	A
F392: 77      		LD	(HL),A
F393: C9      		RET
              	;
              	;   Filename was not found. Set appropriate status.
              	;
F394: CDFEF1  	FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
F397: 3EFF    		LD	A,0FFH		;say not located.
F399: C301EF  		JP	SETSTAT
              	;
              	;   Erase files from the directory. Only the first byte of the
              	; fcb will be affected. It is set to (E5).
              	;
F39C: CD54F1  	ERAFILE:CALL	CHKWPRT		;is disk write protected?
F39F: 0E0C    		LD	C,12		;only compare file names.
F3A1: CD18F3  		CALL	FINDFST		;get first file name.
F3A4: CDF5F1  	ERAFIL1:CALL	CKFILPOS	;any found?
F3A7: C8      		RET	Z		;nope, we must be done.
F3A8: CD44F1  		CALL	CHKROFL		;is file read only?
F3AB: CD5EF1  		CALL	FCB2HL		;nope, get address of fcb and
F3AE: 36E5    		LD	(HL),0E5H	;set first byte to 'empty'.
F3B0: 0E00    		LD	C,0		;clear the space from the bit map.
F3B2: CD6BF2  		CALL	SETFILE
F3B5: CDC6F1  		CALL	DIRWRITE	;now write the directory sector back out.
F3B8: CD2DF3  		CALL	FINDNXT		;find the next file name.
F3BB: C3A4F3  		JP	ERAFIL1		;and repeat process.
              	;
              	;   Look through the space allocation map (bit map) for the
              	; next available block. Start searching at block number (BC-1).
              	; The search procedure is to look for an empty block that is
              	; before the starting block. If not empty, look at a later
              	; block number. In this way, we return the closest empty block
              	; on either side of the 'target' block number. This will speed
              	; access on random devices. For serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   On return, (DE)= block number that is empty and (HL) =0
              	; if no empry block was found.
              	;
F3BE: 50      	FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
F3BF: 59      		LD	E,C
              	;
              	;   Look before target block. Registers (BC) are used as the lower
              	; pointer and (DE) as the upper pointer.
              	;
F3C0: 79      	FNDSPA1:LD	A,C		;is block 0 specified?
F3C1: B0      		OR	B
F3C2: CAD1F3  		JP	Z,FNDSPA2
F3C5: 0B      		DEC	BC		;nope, check previous block.
F3C6: D5      		PUSH	DE
F3C7: C5      		PUSH	BC
F3C8: CD35F2  		CALL	CKBITMAP
F3CB: 1F      		RRA			;is this block empty?
F3CC: D2ECF3  		JP	NC,FNDSPA3	;yes. use this.
              	;
              	;   Note that the above logic gets the first block that it finds
              	; that is empty. Thus a file could be written 'backward' making
              	; it very slow to access. This could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; This should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
F3CF: C1      		POP	BC		;nope, check some more.
F3D0: D1      		POP	DE
              	;
              	;   Now look after target block.
              	;
F3D1: 2AC6F9  	FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
F3D4: 7B      		LD	A,E
F3D5: 95      		SUB	L
F3D6: 7A      		LD	A,D
F3D7: 9C      		SBC	A,H
F3D8: D2F4F3  		JP	NC,FNDSPA4
F3DB: 13      		INC	DE		;yes, move on to next one.
F3DC: C5      		PUSH	BC
F3DD: D5      		PUSH	DE
F3DE: 42      		LD	B,D
F3DF: 4B      		LD	C,E
F3E0: CD35F2  		CALL	CKBITMAP	;check it.
F3E3: 1F      		RRA			;empty?
F3E4: D2ECF3  		JP	NC,FNDSPA3
F3E7: D1      		POP	DE		;nope, continue searching.
F3E8: C1      		POP	BC
F3E9: C3C0F3  		JP	FNDSPA1
              	;
              	;   Empty block found. Set it as used and return with (HL)
              	; pointing to it (true?).
              	;
F3EC: 17      	FNDSPA3:RLA			;reset byte.
F3ED: 3C      		INC	A		;and set bit 0.
F3EE: CD64F2  		CALL	STBMAP1		;update bit map.
F3F1: E1      		POP	HL		;set return registers.
F3F2: D1      		POP	DE
F3F3: C9      		RET
              	;
              	;   Free block was not found. If (BC) is not zero, then we have
              	; not checked all of the disk space.
              	;
F3F4: 79      	FNDSPA4:LD	A,C
F3F5: B0      		OR	B
F3F6: C2C0F3  		JP	NZ,FNDSPA1
F3F9: 210000  		LD	HL,0		;set 'not found' status.
F3FC: C9      		RET
              	;
              	;   Move a complete fcb entry into the directory and write it.
              	;
F3FD: 0E00    	FCBSET:	LD	C,0
F3FF: 1E20    		LD	E,32		;length of each entry.
              	;
              	;   Move (E) bytes from the fcb pointed to by (PARAMS) into
              	; fcb in directory starting at relative byte (C). This updated
              	; directory buffer is then written to the disk.
              	;
F401: D5      	UPDATE:	PUSH	DE
F402: 0600    		LD	B,0		;set (BC) to relative byte position.
F404: 2A43EF  		LD	HL,(PARAMS)	;get address of fcb.
F407: 09      		ADD	HL,BC		;compute starting byte.
F408: EB      		EX	DE,HL
F409: CD5EF1  		CALL	FCB2HL		;get address of fcb to update in directory.
F40C: C1      		POP	BC		;set (C) to number of bytes to change.
F40D: CD4FEF  		CALL	DE2HL
F410: CDC3EF  	UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
F413: C3C6F1  		JP	DIRWRITE	;then write this sector out.
              	;
              	;   Routine to change the name of all files on the disk with a
              	; specified name. The fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
F416: CD54F1  	CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
F419: 0E0C    		LD	C,12		;match first 12 bytes of fcb only.
F41B: CD18F3  		CALL	FINDFST		;get first name.
F41E: 2A43EF  		LD	HL,(PARAMS)	;get address of fcb.
F421: 7E      		LD	A,(HL)		;get user number.
F422: 111000  		LD	DE,16		;move over to desired name.
F425: 19      		ADD	HL,DE
F426: 77      		LD	(HL),A		;keep same user number.
F427: CDF5F1  	CHGNAM1:CALL	CKFILPOS	;any matching file found?
F42A: C8      		RET	Z		;no, we must be done.
F42B: CD44F1  		CALL	CHKROFL		;check for read only file.
F42E: 0E10    		LD	C,16		;start 16 bytes into fcb.
F430: 1E0C    		LD	E,12		;and update the first 12 bytes of directory.
F432: CD01F4  		CALL	UPDATE
F435: CD2DF3  		CALL	FINDNXT		;get te next file name.
F438: C327F4  		JP	CHGNAM1		;and continue.
              	;
              	;   Update a files attributes. The procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). No other changes
              	; are made.
              	;
F43B: 0E0C    	SAVEATTR: LD	C,12		;match first 12 bytes.
F43D: CD18F3  		CALL	FINDFST		;look for first filename.
F440: CDF5F1  	SAVATR1:CALL	CKFILPOS	;was one found?
F443: C8      		RET	Z		;nope, we must be done.
F444: 0E00    		LD	C,0		;yes, update the first 12 bytes now.
F446: 1E0C    		LD	E,12
F448: CD01F4  		CALL	UPDATE		;update filename and write directory.
F44B: CD2DF3  		CALL	FINDNXT		;and get the next file.
F44E: C340F4  		JP	SAVATR1		;then continue until done.
              	;
              	;  Open a file (name specified in fcb).
              	;
F451: 0E0F    	OPENIT:	LD	C,15		;compare the first 15 bytes.
F453: CD18F3  		CALL	FINDFST		;get the first one in directory.
F456: CDF5F1  		CALL	CKFILPOS	;any at all?
F459: C8      		RET	Z
F45A: CDA6F0  	OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
F45D: 7E      		LD	A,(HL)		;and get it.
F45E: F5      		PUSH	AF		;save it and address.
F45F: E5      		PUSH	HL
F460: CD5EF1  		CALL	FCB2HL		;point to fcb in directory.
F463: EB      		EX	DE,HL
F464: 2A43EF  		LD	HL,(PARAMS)	;this is the users copy.
F467: 0E20    		LD	C,32		;move it into users space.
F469: D5      		PUSH	DE
F46A: CD4FEF  		CALL	DE2HL
F46D: CD78F1  		CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
F470: D1      		POP	DE		;now get the extent byte from this fcb.
F471: 210C00  		LD	HL,12
F474: 19      		ADD	HL,DE
F475: 4E      		LD	C,(HL)		;into (C).
F476: 210F00  		LD	HL,15		;now get the record count byte into (B).
F479: 19      		ADD	HL,DE
F47A: 46      		LD	B,(HL)
F47B: E1      		POP	HL		;keep the same extent as the user had originally.
F47C: F1      		POP	AF
F47D: 77      		LD	(HL),A
F47E: 79      		LD	A,C		;is it the same as in the directory fcb?
F47F: BE      		CP	(HL)
F480: 78      		LD	A,B		;if yes, then use the same record count.
F481: CA8BF4  		JP	Z,OPENIT2
F484: 3E00    		LD	A,0		;if the user specified an extent greater than
F486: DA8BF4  		JP	C,OPENIT2	;the one in the directory, then set record count to 0.
F489: 3E80    		LD	A,128		;otherwise set to maximum.
F48B: 2A43EF  	OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
F48E: 110F00  		LD	DE,15
F491: 19      		ADD	HL,DE		;compute relative position.
F492: 77      		LD	(HL),A		;and set the record count.
F493: C9      		RET	
              	;
              	;   Move two bytes from (DE) to (HL) if (and only if) (HL)
              	; point to a zero value (16 bit).
              	;   Return with zero flag set it (DE) was moved. Registers (DE)
              	; and (HL) are not changed. However (A) is.
              	;
F494: 7E      	MOVEWORD: LD	A,(HL)		;check for a zero word.
F495: 23      		INC	HL
F496: B6      		OR	(HL)		;both bytes zero?
F497: 2B      		DEC	HL
F498: C0      		RET	NZ		;nope, just return.
F499: 1A      		LD	A,(DE)		;yes, move two bytes from (DE) into
F49A: 77      		LD	(HL),A		;this zero space.
F49B: 13      		INC	DE
F49C: 23      		INC	HL
F49D: 1A      		LD	A,(DE)
F49E: 77      		LD	(HL),A
F49F: 1B      		DEC	DE		;don't disturb these registers.
F4A0: 2B      		DEC	HL
F4A1: C9      		RET	
              	;
              	;   Get here to close a file specified by (fcb).
              	;
F4A2: AF      	CLOSEIT:XOR	A		;clear status and file position bytes.
F4A3: 3245EF  		LD	(STATUS),A
F4A6: 32EAF9  		LD	(FILEPOS),A
F4A9: 32EBF9  		LD	(FILEPOS+1),A
F4AC: CD1EF1  		CALL	GETWPRT		;get write protect bit for this drive.
F4AF: C0      		RET	NZ		;just return if it is set.
F4B0: CD69F1  		CALL	GETS2		;else get the 's2' byte.
F4B3: E680    		AND	80H		;and look at bit 7 (file unmodified?).
F4B5: C0      		RET	NZ		;just return if set.
F4B6: 0E0F    		LD	C,15		;else look up this file in directory.
F4B8: CD18F3  		CALL	FINDFST
F4BB: CDF5F1  		CALL	CKFILPOS	;was it found?
F4BE: C8      		RET	Z		;just return if not.
F4BF: 011000  		LD	BC,16		;set (HL) pointing to records used section.
F4C2: CD5EF1  		CALL	FCB2HL
F4C5: 09      		ADD	HL,BC
F4C6: EB      		EX	DE,HL
F4C7: 2A43EF  		LD	HL,(PARAMS)	;do the same for users specified fcb.
F4CA: 09      		ADD	HL,BC
F4CB: 0E10    		LD	C,16		;this many bytes are present in this extent.
F4CD: 3ADDF9  	CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
F4D0: B7      		OR	A
F4D1: CAE8F4  		JP	Z,CLOSEIT4
F4D4: 7E      		LD	A,(HL)		;just 8 bit. Get one from users fcb.
F4D5: B7      		OR	A
F4D6: 1A      		LD	A,(DE)		;now get one from directory fcb.
F4D7: C2DBF4  		JP	NZ,CLOSEIT2
F4DA: 77      		LD	(HL),A		;users byte was zero. Update from directory.
F4DB: B7      	CLOSEIT2: OR	A
F4DC: C2E1F4  		JP	NZ,CLOSEIT3
F4DF: 7E      		LD	A,(HL)		;directories byte was zero, update from users fcb.
F4E0: 12      		LD	(DE),A
F4E1: BE      	CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
F4E2: C21FF5  		JP	NZ,CLOSEIT7	;then close error if they are not the same.
F4E5: C3FDF4  		JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
F4E8: CD94F4  	CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
F4EB: EB      		EX	DE,HL
F4EC: CD94F4  		CALL	MOVEWORD	;update directories fcb if it is zero.
F4EF: EB      		EX	DE,HL
F4F0: 1A      		LD	A,(DE)		;if these two values are no different,
F4F1: BE      		CP	(HL)		;then a close error occured.
F4F2: C21FF5  		JP	NZ,CLOSEIT7
F4F5: 13      		INC	DE		;check second byte.
F4F6: 23      		INC	HL
F4F7: 1A      		LD	A,(DE)
F4F8: BE      		CP	(HL)
F4F9: C21FF5  		JP	NZ,CLOSEIT7
F4FC: 0D      		DEC	C		;remember 16 bit values.
F4FD: 13      	CLOSEIT5: INC	DE		;bump to next item in table.
F4FE: 23      		INC	HL
F4FF: 0D      		DEC	C		;there are 16 entries only.
F500: C2CDF4  		JP	NZ,CLOSEIT1	;continue if more to do.
F503: 01ECFF  		LD	BC,0FFECH	;backup 20 places (extent byte).
F506: 09      		ADD	HL,BC
F507: EB      		EX	DE,HL
F508: 09      		ADD	HL,BC
F509: 1A      		LD	A,(DE)
F50A: BE      		CP	(HL)		;directory's extent already greater than the
F50B: DA17F5  		JP	C,CLOSEIT6	;users extent?
F50E: 77      		LD	(HL),A		;no, update directory extent.
F50F: 010300  		LD	BC,3		;and update the record count byte in
F512: 09      		ADD	HL,BC		;directories fcb.
F513: EB      		EX	DE,HL
F514: 09      		ADD	HL,BC
F515: 7E      		LD	A,(HL)		;get from user.
F516: 12      		LD	(DE),A		;and put in directory.
F517: 3EFF    	CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
F519: 32D2F9  		LD	(CLOSEFLG),A
F51C: C310F4  		JP	UPDATE1		;update the directory now.
F51F: 2145EF  	CLOSEIT7: LD	HL,STATUS	;set return status and then return.
F522: 35      		DEC	(HL)
F523: C9      		RET
              	;
              	;   Routine to get the next empty space in the directory. It
              	; will then be cleared for use.
              	;
F524: CD54F1  	GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
F527: 2A43EF  		LD	HL,(PARAMS)	;save current parameters (fcb).
F52A: E5      		PUSH	HL
F52B: 21ACF9  		LD	HL,EMPTYFCB	;use special one for empty space.
F52E: 2243EF  		LD	(PARAMS),HL
F531: 0E01    		LD	C,1		;search for first empty spot in directory.
F533: CD18F3  		CALL	FINDFST		;(* only check first byte *)
F536: CDF5F1  		CALL	CKFILPOS	;none?
F539: E1      		POP	HL
F53A: 2243EF  		LD	(PARAMS),HL	;restore original fcb address.
F53D: C8      		RET	Z		;return if no more space.
F53E: EB      		EX	DE,HL
F53F: 210F00  		LD	HL,15		;point to number of records for this file.
F542: 19      		ADD	HL,DE
F543: 0E11    		LD	C,17		;and clear all of this space.
F545: AF      		XOR	A
F546: 77      	GETMT1:	LD	(HL),A
F547: 23      		INC	HL
F548: 0D      		DEC	C
F549: C246F5  		JP	NZ,GETMT1
F54C: 210D00  		LD	HL,13		;clear the 's1' byte also.
F54F: 19      		ADD	HL,DE
F550: 77      		LD	(HL),A
F551: CD8CF1  		CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
F554: CDFDF3  		CALL	FCBSET		;write out this fcb entry to directory.
F557: C378F1  		JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   Routine to close the current extent and open the next one
              	; for reading.
              	;
F55A: AF      	GETNEXT:XOR	A
F55B: 32D2F9  		LD	(CLOSEFLG),A	;clear close flag.
F55E: CDA2F4  		CALL	CLOSEIT		;close this extent.
F561: CDF5F1  		CALL	CKFILPOS
F564: C8      		RET	Z		;not there???
F565: 2A43EF  		LD	HL,(PARAMS)	;get extent byte.
F568: 010C00  		LD	BC,12
F56B: 09      		ADD	HL,BC
F56C: 7E      		LD	A,(HL)		;and increment it.
F56D: 3C      		INC	A
F56E: E61F    		AND	1FH		;keep within range 0-31.
F570: 77      		LD	(HL),A
F571: CA83F5  		JP	Z,GTNEXT1	;overflow?
F574: 47      		LD	B,A		;mask extent byte.
F575: 3AC5F9  		LD	A,(EXTMASK)
F578: A0      		AND	B
F579: 21D2F9  		LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
F57C: A6      		AND	(HL)
F57D: CA8EF5  		JP	Z,GTNEXT2	;if zero, we must read in next extent.
F580: C3ACF5  		JP	GTNEXT3		;else, it is already in memory.
F583: 010200  	GTNEXT1:LD	BC,2		;Point to the 's2' byte.
F586: 09      		ADD	HL,BC
F587: 34      		INC	(HL)		;and bump it.
F588: 7E      		LD	A,(HL)		;too many extents?
F589: E60F    		AND	0FH
F58B: CAB6F5  		JP	Z,GTNEXT5	;yes, set error code.
              	;
              	;   Get here to open the next extent.
              	;
F58E: 0E0F    	GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
F590: CD18F3  		CALL	FINDFST		;find the first one.
F593: CDF5F1  		CALL	CKFILPOS	;none available?
F596: C2ACF5  		JP	NZ,GTNEXT3
F599: 3AD3F9  		LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
F59C: 3C      		INC	A		;0ffh means reading (so not possible).
F59D: CAB6F5  		JP	Z,GTNEXT5	;or an error.
F5A0: CD24F5  		CALL	GETEMPTY	;we are writing, get an empty entry.
F5A3: CDF5F1  		CALL	CKFILPOS	;none?
F5A6: CAB6F5  		JP	Z,GTNEXT5	;error if true.
F5A9: C3AFF5  		JP	GTNEXT4		;else we are almost done.
F5AC: CD5AF4  	GTNEXT3:CALL	OPENIT1		;open this extent.
F5AF: CDBBF0  	GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
F5B2: AF      		XOR	A		;clear status and return.
F5B3: C301EF  		JP	SETSTAT
              	;
              	;   Error in extending the file. Too many extents were needed
              	; or not enough space on the disk.
              	;
F5B6: CD05EF  	GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
F5B9: C378F1  		JP	SETS2B7		;so this is not written on a close.
              	;
              	;   Read a sequential file.
              	;
F5BC: 3E01    	RDSEQ:	LD	A,1		;set sequential access mode.
F5BE: 32D5F9  		LD	(MODE),A
F5C1: 3EFF    	RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
F5C3: 32D3F9  		LD	(RDWRTFLG),A
F5C6: CDBBF0  		CALL	STRDATA		;put rec# and ext# into fcb.
F5C9: 3AE3F9  		LD	A,(SAVNREC)	;get next record to read.
F5CC: 21E1F9  		LD	HL,SAVNXT	;get number of records in extent.
F5CF: BE      		CP	(HL)		;within this extent?
F5D0: DAE6F5  		JP	C,RDSEQ2
F5D3: FE80    		CP	128		;no. Is this extent fully used?
F5D5: C2FBF5  		JP	NZ,RDSEQ3	;no. End-of-file.
F5D8: CD5AF5  		CALL	GETNEXT		;yes, open the next one.
F5DB: AF      		XOR	A		;reset next record to read.
F5DC: 32E3F9  		LD	(SAVNREC),A
F5DF: 3A45EF  		LD	A,(STATUS)	;check on open, successful?
F5E2: B7      		OR	A
F5E3: C2FBF5  		JP	NZ,RDSEQ3	;no, error.
F5E6: CD77F0  	RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
F5E9: CD84F0  		CALL	CHKBLK		;check it. Within bounds?
F5EC: CAFBF5  		JP	Z,RDSEQ3	;no, error.
F5EF: CD8AF0  		CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
F5F2: CDD1EF  		CALL	TRKSEC1		;set the track and sector for this block #.
F5F5: CDB2EF  		CALL	DOREAD		;and read it.
F5F8: C3D2F0  		JP	SETNREC		;and set the next record to be accessed.
              	;
              	;   Read error occured. Set status and return.
              	;
F5FB: C305EF  	RDSEQ3:	JP	IOERR1
              	;
              	;   Write the next sequential record.
              	;
F5FE: 3E01    	WTSEQ:	LD	A,1		;set sequential access mode.
F600: 32D5F9  		LD	(MODE),A
F603: 3E00    	WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
F605: 32D3F9  		LD	(RDWRTFLG),A
F608: CD54F1  		CALL	CHKWPRT		;check write protect status.
F60B: 2A43EF  		LD	HL,(PARAMS)
F60E: CD47F1  		CALL	CKROF1		;check for read only file, (HL) already set to fcb.
F611: CDBBF0  		CALL	STRDATA		;put updated data into fcb.
F614: 3AE3F9  		LD	A,(SAVNREC)	;get record number to write.
F617: FE80    		CP	128		;within range?
F619: D205EF  		JP	NC,IOERR1	;no, error(?).
F61C: CD77F0  		CALL	COMBLK		;compute block number.
F61F: CD84F0  		CALL	CHKBLK		;check number.
F622: 0E00    		LD	C,0		;is there one to write to?
F624: C26EF6  		JP	NZ,WTSEQ6	;yes, go do it.
F627: CD3EF0  		CALL	GETBLOCK	;get next block number within fcb to use.
F62A: 32D7F9  		LD	(RELBLOCK),A	;and save.
F62D: 010000  		LD	BC,0		;start looking for space from the start
F630: B7      		OR	A		;if none allocated as yet.
F631: CA3BF6  		JP	Z,WTSEQ2
F634: 4F      		LD	C,A		;extract previous block number from fcb
F635: 0B      		DEC	BC		;so we can be closest to it.
F636: CD5EF0  		CALL	EXTBLK
F639: 44      		LD	B,H
F63A: 4D      		LD	C,L
F63B: CDBEF3  	WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
F63E: 7D      		LD	A,L		;check for a zero number.
F63F: B4      		OR	H
F640: C248F6  		JP	NZ,WTSEQ3
F643: 3E02    		LD	A,2		;no more space?
F645: C301EF  		JP	SETSTAT
F648: 22E5F9  	WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
F64B: EB      		EX	DE,HL		;put block number into (DE).
F64C: 2A43EF  		LD	HL,(PARAMS)	;now we must update the fcb for this
F64F: 011000  		LD	BC,16		;newly allocated block.
F652: 09      		ADD	HL,BC
F653: 3ADDF9  		LD	A,(BIGDISK)	;8 or 16 bit block numbers?
F656: B7      		OR	A
F657: 3AD7F9  		LD	A,(RELBLOCK)	;(* update this entry *)
F65A: CA64F6  		JP	Z,WTSEQ4	;zero means 16 bit ones.
F65D: CD64F1  		CALL	ADDA2HL		;(HL)=(HL)+(A)
F660: 73      		LD	(HL),E		;store new block number.
F661: C36CF6  		JP	WTSEQ5
F664: 4F      	WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
F665: 0600    		LD	B,0
F667: 09      		ADD	HL,BC
F668: 09      		ADD	HL,BC
F669: 73      		LD	(HL),E		;stuff block number (DE) there.
F66A: 23      		INC	HL
F66B: 72      		LD	(HL),D
F66C: 0E02    	WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
F66E: 3A45EF  	WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
F671: B7      		OR	A
F672: C0      		RET	NZ
F673: C5      		PUSH	BC		;yes, save write flag for bios (register C).
F674: CD8AF0  		CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
F677: 3AD5F9  		LD	A,(MODE)	;get access mode flag (1=sequential,
F67A: 3D      		DEC	A		;0=random, 2=special?).
F67B: 3D      		DEC	A
F67C: C2BBF6  		JP	NZ,WTSEQ9
              	;
              	;   Special random i/o from function #40. Maybe for M/PM, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
F67F: C1      		POP	BC
F680: C5      		PUSH	BC
F681: 79      		LD	A,C		;get write status flag (2=writing unused space).
F682: 3D      		DEC	A
F683: 3D      		DEC	A
F684: C2BBF6  		JP	NZ,WTSEQ9
F687: E5      		PUSH	HL
F688: 2AB9F9  		LD	HL,(DIRBUF)	;zero out the directory buffer.
F68B: 57      		LD	D,A		;note that (A) is zero here.
F68C: 77      	WTSEQ7:	LD	(HL),A
F68D: 23      		INC	HL
F68E: 14      		INC	D		;do 128 bytes.
F68F: F28CF6  		JP	P,WTSEQ7
F692: CDE0F1  		CALL	DIRDMA		;tell the bios the dma address for directory access.
F695: 2AE7F9  		LD	HL,(LOGSECT)	;get sector that starts current block.
F698: 0E02    		LD	C,2		;set 'writing to unused space' flag.
F69A: 22E5F9  	WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
F69D: C5      		PUSH	BC
F69E: CDD1EF  		CALL	TRKSEC1		;determine its track and sector numbers.
F6A1: C1      		POP	BC
F6A2: CDB8EF  		CALL	DOWRITE		;now write out 128 bytes of zeros.
F6A5: 2AE5F9  		LD	HL,(BLKNMBR)	;get sector number.
F6A8: 0E00    		LD	C,0		;set normal write flag.
F6AA: 3AC4F9  		LD	A,(BLKMASK)	;determine if we have written the entire
F6AD: 47      		LD	B,A		;physical block.
F6AE: A5      		AND	L
F6AF: B8      		CP	B
F6B0: 23      		INC	HL		;prepare for the next one.
F6B1: C29AF6  		JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
F6B4: E1      		POP	HL		;reset next sector number.
F6B5: 22E5F9  		LD	(BLKNMBR),HL
F6B8: CDDAF1  		CALL	DEFDMA		;and reset dma address.
              	;
              	;   Normal disk write. Set the desired track and sector then
              	; do the actual write.
              	;
F6BB: CDD1EF  	WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
F6BE: C1      		POP	BC		;get write status flag.
F6BF: C5      		PUSH	BC
F6C0: CDB8EF  		CALL	DOWRITE		;and write this out.
F6C3: C1      		POP	BC
F6C4: 3AE3F9  		LD	A,(SAVNREC)	;get number of records in file.
F6C7: 21E1F9  		LD	HL,SAVNXT	;get last record written.
F6CA: BE      		CP	(HL)
F6CB: DAD2F6  		JP	C,WTSEQ10
F6CE: 77      		LD	(HL),A		;we have to update record count.
F6CF: 34      		INC	(HL)
F6D0: 0E02    		LD	C,2
              	;
              	;*   This area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the BIOS.
              	;
F6D2: 00      	WTSEQ10:NOP			;was 'dcr c'
F6D3: 00      		NOP			;was 'dcr c'
F6D4: 210000  		LD	HL,0		;was 'jnz wtseq99'
              	;
              	; *   End of patch.
              	;
F6D7: F5      		PUSH	AF
F6D8: CD69F1  		CALL	GETS2		;set 'extent written to' flag.
F6DB: E67F    		AND	7FH		;(* clear bit 7 *)
F6DD: 77      		LD	(HL),A
F6DE: F1      		POP	AF		;get record count for this extent.
F6DF: FE7F    	WTSEQ99:CP	127		;is it full?
F6E1: C200F7  		JP	NZ,WTSEQ12
F6E4: 3AD5F9  		LD	A,(MODE)	;yes, are we in sequential mode?
F6E7: FE01    		CP	1
F6E9: C200F7  		JP	NZ,WTSEQ12
F6EC: CDD2F0  		CALL	SETNREC		;yes, set next record number.
F6EF: CD5AF5  		CALL	GETNEXT		;and get next empty space in directory.
F6F2: 2145EF  		LD	HL,STATUS	;ok?
F6F5: 7E      		LD	A,(HL)
F6F6: B7      		OR	A
F6F7: C2FEF6  		JP	NZ,WTSEQ11
F6FA: 3D      		DEC	A		;yes, set record count to -1.
F6FB: 32E3F9  		LD	(SAVNREC),A
F6FE: 3600    	WTSEQ11:LD	(HL),0		;clear status.
F700: C3D2F0  	WTSEQ12:JP	SETNREC		;set next record to access.
              	;
              	;   For random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   On entry, register (C) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. Otherwise,
              	; another extent will be opened (for writing) if required.
              	;
F703: AF      	POSITION: XOR	A		;set random i/o flag.
F704: 32D5F9  		LD	(MODE),A
              	;
              	;   Special entry (function #40). M/PM ?
              	;
F707: C5      	POSITN1:PUSH	BC		;save read/write flag.
F708: 2A43EF  		LD	HL,(PARAMS)	;get address of fcb.
F70B: EB      		EX	DE,HL
F70C: 212100  		LD	HL,33		;now get byte 'r0'.
F70F: 19      		ADD	HL,DE
F710: 7E      		LD	A,(HL)
F711: E67F    		AND	7FH		;keep bits 0-6 for the record number to access.
F713: F5      		PUSH	AF
F714: 7E      		LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
F715: 17      		RLA
F716: 23      		INC	HL
F717: 7E      		LD	A,(HL)
F718: 17      		RLA
F719: E61F    		AND	1FH		;and save this in bits 0-4 of (C).
F71B: 4F      		LD	C,A		;this is the extent byte.
F71C: 7E      		LD	A,(HL)		;now get the extra extent byte.
F71D: 1F      		RRA
F71E: 1F      		RRA
F71F: 1F      		RRA
F720: 1F      		RRA
F721: E60F    		AND	0FH
F723: 47      		LD	B,A		;and save it in (B).
F724: F1      		POP	AF		;get record number back to (A).
F725: 23      		INC	HL		;check overflow byte 'r2'.
F726: 6E      		LD	L,(HL)
F727: 2C      		INC	L
F728: 2D      		DEC	L
F729: 2E06    		LD	L,6		;prepare for error.
F72B: C28BF7  		JP	NZ,POSITN5	;out of disk space error.
F72E: 212000  		LD	HL,32		;store record number into fcb.
F731: 19      		ADD	HL,DE
F732: 77      		LD	(HL),A
F733: 210C00  		LD	HL,12		;and now check the extent byte.
F736: 19      		ADD	HL,DE
F737: 79      		LD	A,C
F738: 96      		SUB	(HL)		;same extent as before?
F739: C247F7  		JP	NZ,POSITN2
F73C: 210E00  		LD	HL,14		;yes, check extra extent byte 's2' also.
F73F: 19      		ADD	HL,DE
F740: 78      		LD	A,B
F741: 96      		SUB	(HL)
F742: E67F    		AND	7FH
F744: CA7FF7  		JP	Z,POSITN3	;same, we are almost done then.
              	;
              	;  Get here when another extent is required.
              	;
F747: C5      	POSITN2:PUSH	BC
F748: D5      		PUSH	DE
F749: CDA2F4  		CALL	CLOSEIT		;close current extent.
F74C: D1      		POP	DE
F74D: C1      		POP	BC
F74E: 2E03    		LD	L,3		;prepare for error.
F750: 3A45EF  		LD	A,(STATUS)
F753: 3C      		INC	A
F754: CA84F7  		JP	Z,POSITN4	;close error.
F757: 210C00  		LD	HL,12		;put desired extent into fcb now.
F75A: 19      		ADD	HL,DE
F75B: 71      		LD	(HL),C
F75C: 210E00  		LD	HL,14		;and store extra extent byte 's2'.
F75F: 19      		ADD	HL,DE
F760: 70      		LD	(HL),B
F761: CD51F4  		CALL	OPENIT		;try and get this extent.
F764: 3A45EF  		LD	A,(STATUS)	;was it there?
F767: 3C      		INC	A
F768: C27FF7  		JP	NZ,POSITN3
F76B: C1      		POP	BC		;no. can we create a new one (writing?).
F76C: C5      		PUSH	BC
F76D: 2E04    		LD	L,4		;prepare for error.
F76F: 0C      		INC	C
F770: CA84F7  		JP	Z,POSITN4	;nope, reading unwritten space error.
F773: CD24F5  		CALL	GETEMPTY	;yes we can, try to find space.
F776: 2E05    		LD	L,5		;prepare for error.
F778: 3A45EF  		LD	A,(STATUS)
F77B: 3C      		INC	A
F77C: CA84F7  		JP	Z,POSITN4	;out of space?
              	;
              	;   Normal return location. Clear error code and return.
              	;
F77F: C1      	POSITN3:POP	BC		;restore stack.
F780: AF      		XOR	A		;and clear error code byte.
F781: C301EF  		JP	SETSTAT
              	;
              	;   Error. Set the 's2' byte to indicate this (why?).
              	;
F784: E5      	POSITN4:PUSH	HL
F785: CD69F1  		CALL	GETS2
F788: 36C0    		LD	(HL),0C0H
F78A: E1      		POP	HL
              	;
              	;   Return with error code (presently in L).
              	;
F78B: C1      	POSITN5:POP	BC
F78C: 7D      		LD	A,L		;get error code.
F78D: 3245EF  		LD	(STATUS),A
F790: C378F1  		JP	SETS2B7
              	;
              	;   Read a random record.
              	;
F793: 0EFF    	READRAN:LD	C,0FFH		;set 'read' status.
F795: CD03F7  		CALL	POSITION	;position the file to proper record.
F798: CCC1F5  		CALL	Z,RDSEQ1	;and read it as usual (if no errors).
F79B: C9      		RET
              	;
              	;   Write to a random record.
              	;
F79C: 0E00    	WRITERAN: LD	C,0		;set 'writing' flag.
F79E: CD03F7  		CALL	POSITION	;position the file to proper record.
F7A1: CC03F6  		CALL	Z,WTSEQ1	;and write as usual (if no errors).
F7A4: C9      		RET
              	;
              	;   Compute the random record number. Enter with (HL) pointing
              	; to a fcb an (DE) contains a relative location of a record
              	; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
              	; byte, and (A) the 'r2' byte.
              	;
              	;   On return, the zero flag is set if the record is within
              	; bounds. Otherwise, an overflow occured.
              	;
F7A5: EB      	COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
F7A6: 19      		ADD	HL,DE		;compute relative position of record #.
F7A7: 4E      		LD	C,(HL)		;get record number into (BC).
F7A8: 0600    		LD	B,0
F7AA: 210C00  		LD	HL,12		;now get extent.
F7AD: 19      		ADD	HL,DE
F7AE: 7E      		LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
F7AF: 0F      		RRCA			;move lower bit into bit 7.
F7B0: E680    		AND	80H		;and ignore all other bits.
F7B2: 81      		ADD	A,C		;add to our record number.
F7B3: 4F      		LD	C,A
F7B4: 3E00    		LD	A,0		;take care of any carry.
F7B6: 88      		ADC	A,B
F7B7: 47      		LD	B,A
F7B8: 7E      		LD	A,(HL)		;now get the upper bits of extent into
F7B9: 0F      		RRCA			;bit positions 0-3.
F7BA: E60F    		AND	0FH		;and ignore all others.
F7BC: 80      		ADD	A,B		;add this in to 'r1' byte.
F7BD: 47      		LD	B,A
F7BE: 210E00  		LD	HL,14		;get the 's2' byte (extra extent).
F7C1: 19      		ADD	HL,DE
F7C2: 7E      		LD	A,(HL)
F7C3: 87      		ADD	A,A		;and shift it left 4 bits (bits 4-7).
F7C4: 87      		ADD	A,A
F7C5: 87      		ADD	A,A
F7C6: 87      		ADD	A,A
F7C7: F5      		PUSH	AF		;save carry flag (bit 0 of flag byte).
F7C8: 80      		ADD	A,B		;now add extra extent into 'r1'.
F7C9: 47      		LD	B,A
F7CA: F5      		PUSH	AF		;and save carry (overflow byte 'r2').
F7CB: E1      		POP	HL		;bit 0 of (L) is the overflow indicator.
F7CC: 7D      		LD	A,L
F7CD: E1      		POP	HL		;and same for first carry flag.
F7CE: B5      		OR	L		;either one of these set?
F7CF: E601    		AND	01H		;only check the carry flags.
F7D1: C9      		RET
              	;
              	;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; This reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. Then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. This is used to compute the space used
              	; by a random file.
              	;
F7D2: 0E0C    	RANSIZE:LD	C,12		;look thru directory for first entry with
F7D4: CD18F3  		CALL	FINDFST		;this name.
F7D7: 2A43EF  		LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
F7DA: 112100  		LD	DE,33
F7DD: 19      		ADD	HL,DE
F7DE: E5      		PUSH	HL
F7DF: 72      		LD	(HL),D		;note that (D)=0.
F7E0: 23      		INC	HL
F7E1: 72      		LD	(HL),D
F7E2: 23      		INC	HL
F7E3: 72      		LD	(HL),D
F7E4: CDF5F1  	RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
F7E7: CA0CF8  		JP	Z,RANSIZ3	;no, we are done.
F7EA: CD5EF1  		CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
F7ED: 110F00  		LD	DE,15		;point to last record in extent.
F7F0: CDA5F7  		CALL	COMPRAND	;and compute random parameters.
F7F3: E1      		POP	HL
F7F4: E5      		PUSH	HL		;now check these values against those
F7F5: 5F      		LD	E,A		;already in fcb.
F7F6: 79      		LD	A,C		;the carry flag will be set if those
F7F7: 96      		SUB	(HL)		;in the fcb represent a larger size than
F7F8: 23      		INC	HL		;this extent does.
F7F9: 78      		LD	A,B
F7FA: 9E      		SBC	A,(HL)
F7FB: 23      		INC	HL
F7FC: 7B      		LD	A,E
F7FD: 9E      		SBC	A,(HL)
F7FE: DA06F8  		JP	C,RANSIZ2
F801: 73      		LD	(HL),E		;we found a larger (in size) extent.
F802: 2B      		DEC	HL		;stuff these values into fcb.
F803: 70      		LD	(HL),B
F804: 2B      		DEC	HL
F805: 71      		LD	(HL),C
F806: CD2DF3  	RANSIZ2:CALL	FINDNXT		;now get the next extent.
F809: C3E4F7  		JP	RANSIZ1		;continue til all done.
F80C: E1      	RANSIZ3:POP	HL		;we are done, restore the stack and
F80D: C9      		RET			;return.
              	;
              	;   Function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
F80E: 2A43EF  	SETRAN:	LD	HL,(PARAMS)	;point to fcb.
F811: 112000  		LD	DE,32		;and to last used record.
F814: CDA5F7  		CALL	COMPRAND	;compute random position.
F817: 212100  		LD	HL,33		;now stuff these values into fcb.
F81A: 19      		ADD	HL,DE
F81B: 71      		LD	(HL),C		;move 'r0'.
F81C: 23      		INC	HL
F81D: 70      		LD	(HL),B		;and 'r1'.
F81E: 23      		INC	HL
F81F: 77      		LD	(HL),A		;and lastly 'r2'.
F820: C9      		RET
              	;
              	;   This routine select the drive specified in (ACTIVE) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
F821: 2AAFF9  	LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
F824: 3A42EF  		LD	A,(ACTIVE)	;get the default drive.
F827: 4F      		LD	C,A
F828: CDEAF0  		CALL	SHIFTR		;position active bit for this drive
F82B: E5      		PUSH	HL		;into bit 0.
F82C: EB      		EX	DE,HL
F82D: CD59EF  		CALL	SELECT		;select this drive.
F830: E1      		POP	HL
F831: CC47EF  		CALL	Z,SLCTERR	;valid drive?
F834: 7D      		LD	A,L		;is this a newly activated drive?
F835: 1F      		RRA
F836: D8      		RET	C
F837: 2AAFF9  		LD	HL,(LOGIN)	;yes, update the login vector.
F83A: 4D      		LD	C,L
F83B: 44      		LD	B,H
F83C: CD0BF1  		CALL	SETBIT
F83F: 22AFF9  		LD	(LOGIN),HL	;and save.
F842: C3A3F2  		JP	BITMAP		;now update the bitmap.
              	;
              	;   Function to set the active disk number.
              	;
F845: 3AD6F9  	SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
F848: 2142EF  		LD	HL,ACTIVE	;represents a change in drives.
F84B: BE      		CP	(HL)
F84C: C8      		RET	Z
F84D: 77      		LD	(HL),A		;yes it does, log it in.
F84E: C321F8  		JP	LOGINDRV
              	;
              	;   This is the 'auto disk select' routine. The firsst byte
              	; of the fcb is examined for a drive specification. If non
              	; zero then the drive will be selected and loged in.
              	;
F851: 3EFF    	AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
F853: 32DEF9  		LD	(AUTO),A
F856: 2A43EF  		LD	HL,(PARAMS)	;get drive specified.
F859: 7E      		LD	A,(HL)
F85A: E61F    		AND	1FH		;look at lower 5 bits.
F85C: 3D      		DEC	A		;adjust for (1=A, 2=B) etc.
F85D: 32D6F9  		LD	(EPARAM),A	;and save for the select routine.
F860: FE1E    		CP	1EH		;check for 'no change' condition.
F862: D275F8  		JP	NC,AUTOSL1	;yes, don't change.
F865: 3A42EF  		LD	A,(ACTIVE)	;we must change, save currently active
F868: 32DFF9  		LD	(OLDDRV),A	;drive.
F86B: 7E      		LD	A,(HL)		;and save first byte of fcb also.
F86C: 32E0F9  		LD	(AUTOFLAG),A	;this must be non-zero.
F86F: E6E0    		AND	0E0H		;whats this for (bits 6,7 are used for
F871: 77      		LD	(HL),A		;something)?
F872: CD45F8  		CALL	SETDSK		;select and log in this drive.
F875: 3A41EF  	AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
F878: 2A43EF  		LD	HL,(PARAMS)	;(* upper half of first byte *)
F87B: B6      		OR	(HL)
F87C: 77      		LD	(HL),A
F87D: C9      		RET			;and return (all done).
              	;
              	;   Function to return the current cp/m version number.
              	;
F87E: 3E22    	GETVER:	LD	A,022H		;version 2.2
F880: C301EF  		JP	SETSTAT
              	;
              	;   Function to reset the disk system.
              	;
F883: 210000  	RSTDSK:	LD	HL,0		;clear write protect status and log
F886: 22ADF9  		LD	(WRTPRT),HL	;in vector.
F889: 22AFF9  		LD	(LOGIN),HL
F88C: AF      		XOR	A		;select drive 'A'.
F88D: 3242EF  		LD	(ACTIVE),A
F890: 218000  		LD	HL,TBUFF	;setup default dma address.
F893: 22B1F9  		LD	(USERDMA),HL
F896: CDDAF1  		CALL	DEFDMA
F899: C321F8  		JP	LOGINDRV	;now log in drive 'A'.
              	;
              	;   Function to open a specified file.
              	;
F89C: CD72F1  	OPENFIL:CALL	CLEARS2		;clear 's2' byte.
F89F: CD51F8  		CALL	AUTOSEL		;select proper disk.
F8A2: C351F4  		JP	OPENIT		;and open the file.
              	;
              	;   Function to close a specified file.
              	;
F8A5: CD51F8  	CLOSEFIL: CALL	AUTOSEL		;select proper disk.
F8A8: C3A2F4  		JP	CLOSEIT		;and close the file.
              	;
              	;   Function to return the first occurence of a specified file
              	; name. If the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
F8AB: 0E00    	GETFST:	LD	C,0		;prepare for special search.
F8AD: EB      		EX	DE,HL
F8AE: 7E      		LD	A,(HL)		;is first byte a '?'?
F8AF: FE3F    		CP	'?'
F8B1: CAC2F8  		JP	Z,GETFST1	;yes, just get very first entry (zero length match).
F8B4: CDA6F0  		CALL	SETEXT		;get the extension byte from fcb.
F8B7: 7E      		LD	A,(HL)		;is it '?'? if yes, then we want
F8B8: FE3F    		CP	'?'		;an entry with a specific 's2' byte.
F8BA: C472F1  		CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
F8BD: CD51F8  		CALL	AUTOSEL		;select proper drive.
F8C0: 0E0F    		LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
F8C2: CD18F3  	GETFST1:CALL	FINDFST		;find an entry and then move it into
F8C5: C3E9F1  		JP	MOVEDIR		;the users dma space.
              	;
              	;   Function to return the next occurence of a file name.
              	;
F8C8: 2AD9F9  	GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
F8CB: 2243EF  		LD	(PARAMS),HL	;other dbos calls are allowed.
F8CE: CD51F8  		CALL	AUTOSEL		;no error will be returned, but the
F8D1: CD2DF3  		CALL	FINDNXT		;results will be wrong.
F8D4: C3E9F1  		JP	MOVEDIR
              	;
              	;   Function to delete a file by name.
              	;
F8D7: CD51F8  	DELFILE:CALL	AUTOSEL		;select proper drive.
F8DA: CD9CF3  		CALL	ERAFILE		;erase the file.
F8DD: C301F3  		JP	STSTATUS	;set status and return.
              	;
              	;   Function to execute a sequential read of the specified
              	; record number.
              	;
F8E0: CD51F8  	READSEQ:CALL	AUTOSEL		;select proper drive then read.
F8E3: C3BCF5  		JP	RDSEQ
              	;
              	;   Function to write the net sequential record.
              	;
F8E6: CD51F8  	WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
F8E9: C3FEF5  		JP	WTSEQ
              	;
              	;   Create a file function.
              	;
F8EC: CD72F1  	FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
F8EF: CD51F8  		CALL	AUTOSEL		;select proper drive and get the next
F8F2: C324F5  		JP	GETEMPTY	;empty directory space.
              	;
              	;   Function to rename a file.
              	;
F8F5: CD51F8  	RENFILE:CALL	AUTOSEL		;select proper drive and then switch
F8F8: CD16F4  		CALL	CHGNAMES	;file names.
F8FB: C301F3  		JP	STSTATUS
              	;
              	;   Function to return the login vector.
              	;
F8FE: 2AAFF9  	GETLOG:	LD	HL,(LOGIN)
F901: C329F9  		JP	GETPRM1
              	;
              	;   Function to return the current disk assignment.
              	;
F904: 3A42EF  	GETCRNT:LD	A,(ACTIVE)
F907: C301EF  		JP	SETSTAT
              	;
              	;   Function to set the dma address.
              	;
F90A: EB      	PUTDMA:	EX	DE,HL
F90B: 22B1F9  		LD	(USERDMA),HL	;save in our space and then get to
F90E: C3DAF1  		JP	DEFDMA		;the bios with this also.
              	;
              	;   Function to return the allocation vector.
              	;
F911: 2ABFF9  	GETALOC:LD	HL,(ALOCVECT)
F914: C329F9  		JP	GETPRM1
              	;
              	;   Function to return the read-only status vector.
              	;
F917: 2AADF9  	GETROV:	LD	HL,(WRTPRT)
F91A: C329F9  		JP	GETPRM1
              	;
              	;   Function to set the file attributes (read-only, system).
              	;
F91D: CD51F8  	SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
F920: CD3BF4  		CALL	SAVEATTR
F923: C301F3  		JP	STSTATUS
              	;
              	;   Function to return the address of the disk parameter block
              	; for the current drive.
              	;
F926: 2ABBF9  	GETPARM:LD	HL,(DISKPB)
F929: 2245EF  	GETPRM1:LD	(STATUS),HL
F92C: C9      		RET
              	;
              	;   Function to get or set the user number. If (E) was (FF)
              	; then this is a request to return the current user number.
              	; Else set the user number from (E).
              	;
F92D: 3AD6F9  	GETUSER:LD	A,(EPARAM)	;get parameter.
F930: FEFF    		CP	0FFH		;get user number?
F932: C23BF9  		JP	NZ,SETUSER
F935: 3A41EF  		LD	A,(USERNO)	;yes, just do it.
F938: C301EF  		JP	SETSTAT
F93B: E61F    	SETUSER:AND	1FH		;no, we should set it instead. keep low
F93D: 3241EF  		LD	(USERNO),A	;bits (0-4) only.
F940: C9      		RET
              	;
              	;   Function to read a random record from a file.
              	;
F941: CD51F8  	RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
F944: C393F7  		JP	READRAN
              	;
              	;   Function to compute the file size for random files.
              	;
F947: CD51F8  	WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
F94A: C39CF7  		JP	WRITERAN
              	;
              	;   Function to compute the size of a random file.
              	;
F94D: CD51F8  	FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
F950: C3D2F7  		JP	RANSIZE
              	;
              	;   Function #37. This allows a program to log off any drives.
              	; On entry, set (DE) to contain a word with bits set for those
              	; drives that are to be logged off. The log-in vector and the
              	; write protect vector will be updated. This must be a M/PM
              	; special function.
              	;
F953: 2A43EF  	LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
F956: 7D      		LD	A,L		;for each bit that is set, we want
F957: 2F      		CPL			;to clear that bit in (LOGIN)
F958: 5F      		LD	E,A		;and (WRTPRT).
F959: 7C      		LD	A,H
F95A: 2F      		CPL
F95B: 2AAFF9  		LD	HL,(LOGIN)	;reset the login vector.
F95E: A4      		AND	H
F95F: 57      		LD	D,A
F960: 7D      		LD	A,L
F961: A3      		AND	E
F962: 5F      		LD	E,A
F963: 2AADF9  		LD	HL,(WRTPRT)
F966: EB      		EX	DE,HL
F967: 22AFF9  		LD	(LOGIN),HL	;and save.
F96A: 7D      		LD	A,L		;now do the write protect vector.
F96B: A3      		AND	E
F96C: 6F      		LD	L,A
F96D: 7C      		LD	A,H
F96E: A2      		AND	D
F96F: 67      		LD	H,A
F970: 22ADF9  		LD	(WRTPRT),HL	;and save. all done.
F973: C9      		RET
              	;
              	;   Get here to return to the user.
              	;
F974: 3ADEF9  	GOBACK:	LD	A,(AUTO)	;was auto select activated?
F977: B7      		OR	A
F978: CA91F9  		JP	Z,GOBACK1
F97B: 2A43EF  		LD	HL,(PARAMS)	;yes, but was a change made?
F97E: 3600    		LD	(HL),0		;(* reset first byte of fcb *)
F980: 3AE0F9  		LD	A,(AUTOFLAG)
F983: B7      		OR	A
F984: CA91F9  		JP	Z,GOBACK1
F987: 77      		LD	(HL),A		;yes, reset first byte properly.
F988: 3ADFF9  		LD	A,(OLDDRV)	;and get the old drive and select it.
F98B: 32D6F9  		LD	(EPARAM),A
F98E: CD45F8  		CALL	SETDSK
F991: 2A0FEF  	GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
F994: F9      		LD	SP,HL
F995: 2A45EF  		LD	HL,(STATUS)	;get return status.
F998: 7D      		LD	A,L		;force version 1.4 compatability.
F999: 44      		LD	B,H
F99A: C9      		RET			;and go back to user.
              	;
              	;   Function #40. This is a special entry to do random i/o.
              	; For the case where we are writing to unused disk space, this
              	; space will be zeroed out first. This must be a M/PM special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
F99B: CD51F8  	WTSPECL:CALL	AUTOSEL		;select proper drive.
F99E: 3E02    		LD	A,2		;use special write mode.
F9A0: 32D5F9  		LD	(MODE),A
F9A3: 0E00    		LD	C,0		;set write indicator.
F9A5: CD07F7  		CALL	POSITN1		;position the file.
F9A8: CC03F6  		CALL	Z,WTSEQ1	;and write (if no errors).
F9AB: C9      		RET
              	;
              	;**************************************************************
              	;*
              	;*     BDOS data storage pool.
              	;*
              	;**************************************************************
              	;
F9AC: E5      	EMPTYFCB: DEFB	0E5H		;empty directory segment indicator.
F9AD: 0000    	WRTPRT:	DEFW	0		;write protect status for all 16 drives.
F9AF: 0000    	LOGIN:	DEFW	0		;drive active word (1 bit per drive).
F9B1: 8000    	USERDMA:DEFW	080H		;user's dma address (defaults to 80h).
              	;
              	;   Scratch areas from parameter block.
              	;
F9B3: 0000    	SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3).
F9B5: 0000    	SCRATCH2: DEFW	0		;last selected track number.
F9B7: 0000    	SCRATCH3: DEFW	0		;last selected sector number.
              	;
              	;   Disk storage areas from parameter block.
              	;
F9B9: 0000    	DIRBUF:	DEFW	0		;address of directory buffer to use.
F9BB: 0000    	DISKPB:	DEFW	0		;contains address of disk parameter block.
F9BD: 0000    	CHKVECT:DEFW	0		;address of check vector.
F9BF: 0000    	ALOCVECT: DEFW	0		;address of allocation vector (bit map).
              	;
              	;   Parameter block returned from the bios.
              	;
F9C1: 0000    	SECTORS:DEFW	0		;sectors per track from bios.
F9C3: 00      	BLKSHFT:DEFB	0		;block shift.
F9C4: 00      	BLKMASK:DEFB	0		;block mask.
F9C5: 00      	EXTMASK:DEFB	0		;extent mask.
F9C6: 0000    	DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1).
F9C8: 0000    	DIRSIZE:DEFW	0		;directory size.
F9CA: 0000    	ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used).
F9CC: 0000    	ALLOC1:	DEFW	0
F9CE: 0000    	OFFSET:	DEFW	0		;first usable track number.
F9D0: 0000    	XLATE:	DEFW	0		;sector translation table address.
              	;
              	;
F9D2: 00      	CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok).
F9D3: 00      	RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write).
F9D4: 00      	FNDSTAT:DEFB	0		;filename found status (0=found first entry).
F9D5: 00      	MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
F9D6: 00      	EPARAM:	DEFB	0		;storage for register (E) on entry to bdos.
F9D7: 00      	RELBLOCK: DEFB	0		;relative position within fcb of block number written.
F9D8: 00      	COUNTER:DEFB	0		;byte counter for directory name searches.
F9D9: 00000000	SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches).
F9DD: 00      	BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long.
F9DE: 00      	AUTO:	DEFB	0		;if non-zero, then auto select activated.
F9DF: 00      	OLDDRV:	DEFB	0		;on auto select, storage for previous drive.
F9E0: 00      	AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives.
F9E1: 00      	SAVNXT:	DEFB	0		;storage for next record number to access.
F9E2: 00      	SAVEXT:	DEFB	0		;storage for extent number of file.
F9E3: 0000    	SAVNREC:DEFW	0		;storage for number of records in file.
F9E5: 0000    	BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect
F9E7: 0000    	LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector).
F9E9: 00      	FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest.
F9EA: 0000    	FILEPOS:DEFW	0		;files position within directory (0 to max entries -1).
              	;
              	;   Disk directory buffer checksum bytes. One for each of the
              	; 16 possible drives.
              	;
F9EC: 00000000	CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F9F0: 00...   	
              	;
              	;   Extra space ?
              	;
F9FC: 00000000		DEFB	0,0,0,0
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   J U M P   T A B L E
              	;*
              	;**************************************************************
              	;
FA00: C333FA  	BOOT:	JP	DUMMY
FA03: C333FA  	WBOOT:	JP	DUMMY
FA06: C349FA  	CONST:	JP	RZ80_CONSTAT
FA09: C334FA  	CONIN:	JP	RZ80_CONIN
FA0C: C33FFA  	CONOUT:	JP	RZ80_CONOUT
FA0F: C333FA  	LIST:	JP	DUMMY
FA12: C333FA  	PUNCH:	JP	DUMMY
FA15: C333FA  	READER:	JP	DUMMY
FA18: C333FA  	HOME:	JP	DUMMY
FA1B: C35CFA  	SELDSK:	JP	RZ80_SELDSK
FA1E: C375FA  	SETTRK:	JP	RZ80_SETTRK
FA21: C37AFA  	SETSEC:	JP	RZ80_SETSEC
FA24: C356FA  	SETDMA:	JP	RZ80_SETDMA
FA27: C37FFA  	READ:	JP	RZ80_READ
FA2A: C380FA  	WRITE:	JP	RZ80_WRITE
FA2D: C333FA  	PRSTAT:	JP	DUMMY
FA30: C333FA  	SECTRN:	JP	DUMMY
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	;****************** REICHEL RZ80 BIOS *************************
              	;
0004:         	#define DISKS 4
              	
FA33:         	DUMMY:
FA33: C9      		RET
              	
FA34:         	RZ80_CONIN:
FA34: DB01    		IN A, (1)
FA36: E601    		AND A, 1
FA38: 20FA    		JR NZ, RZ80_CONIN
FA3A: DB00    		IN A, (0)
FA3C: E67F    		AND 7Fh
FA3E: C9      		RET
              	
FA3F:         	RZ80_CONOUT:
FA3F: DB01    		IN A, (1)
FA41: E602    		AND A, 2
FA43: 20FA    		JR NZ, RZ80_CONOUT
FA45: 79      		LD A, C
FA46: D300    		OUT (0), A
FA48: C9      		RET
              	
FA49:         	RZ80_CONSTAT:
FA49: DB01    		IN A, (1)
FA4B: E601    		AND A, 1
FA4D: C253FA  		JP NZ, RZ80CONSTAT_NOCHAR
FA50: 3EFF    		LD A, 0FFh
FA52: C9      		RET
FA53:         	RZ80CONSTAT_NOCHAR:
FA53: 3E00    		LD A, 00h
FA55: C9      		RET
              	
FA56:         	RZ80_SETDMA:
FA56: 69      		LD L, C
FA57: 60      		LD H, B
FA58: 2286FA  		LD (dmaad), HL
FA5B: C9      		RET
              	
FA5C:         	RZ80_SELDSK:
FA5C: 210000  		LD HL, 0
FA5F: 79      		LD A, C
FA60: 3285FA  		LD (diskno), A
FA63: FE04    		CP DISKS
FA65: D0      		RET NC
FA66: 3A85FA  		LD A, (diskno)
FA69: 6F      		LD L, A
FA6A: 2600    		LD H, 0
FA6C: 29      		ADD HL, HL
FA6D: 29      		ADD HL, HL
FA6E: 29      		ADD HL, HL
FA6F: 29      		ADD HL, HL
FA70: 1188FA  		LD DE, dpbase
FA73: 19      		ADD HL, DE
FA74: C9      		RET
              	
FA75:         	RZ80_SETTRK:
FA75: 79      		LD A, C
FA76: 3281FA  		LD (track), A
FA79: C9      		RET
              	
FA7A:         	RZ80_SETSEC:
FA7A: 79      		LD A, C
FA7B: 3283FA  		LD (sector), A
FA7E: C9      		RET
              	
FA7F:         	RZ80_READ:
FA7F: C9      		RET
              	
FA80:         	RZ80_WRITE:
FA80: C9      		RET
              	
FA81: 0000    	track: DEFW 0
FA83: 0000    	sector: DEFW 0
FA85: 00      	diskno: DEFB 0
FA86: 0000    	dmaad: DEFW 0
              	
              	; ibm-compatible 8" disks
              	; no translations
              	;
              	; disk Parameter header for disk 00
FA88: 00000000	dpbase: 	defw  	0000h, 0000h
FA8C: 00000000		defw 	0000h, 0000h
FA90: F1FAE2FA		defw 	dirbf, dpblk
FA94: EDFB71FB		defw 	chk00, all00
              	; disk parameter header for disk 01
FA98: 00000000	          	defw 	0000h, 0000h
FA9C: 00000000		defw  	0000h, 0000h
FAA0: F1FAE2FA		defw 	dirbf, dpblk
FAA4: FDFB90FB		defw 	chk01, all01
              	; disk parameter header for disk 02
FAA8: 00000000	          	defw 	0000h, 0000h
FAAC: 00000000		defw  	0000h, 0000h
FAB0: F1FAE2FA		defw 	dirbf, dpblk
FAB4: 0DFCAFFB		defw 	chk02, all02
              	; disk parameter header for disk 03
FAB8: 00000000	          	defw 	0000h, 0000h
FABC: 00000000		defw  	0000h, 0000h
FAC0: F1FAE2FA		defw 	dirbf, dpblk
FAC4: 1DFCCEFB		defw 	chk03, all03
              	;
              	; sector translate vector
FAC8: 01070D13	trans: 	defm  	1, 7, 13, 19 	;sectors 1, 2, 3, 4
FACC: 19050B11		defm 	25, 5, 11, 17 	;sectors 5, 6, 7, 6
FAD0: 1703090F		defm 	23, 3, 9, 15 	;sectors 9, 10, 11, 12
FAD4: 1502080E		defm 	21, 2, 8, 14 	;sectors 13, 14, 15, 16
FAD8: 141A060C		defm 	20, 26, 6, 12  	;sectors 17, 18, 19, 20
FADC: 1218040A		defm 	18, 24, 4, 10 	;sectors 21, 22, 23, 24
FAE0: 1016    		defm 	16, 22 	;sectors 25, 26
              	;
FAE2:         	dpblk: ;disk parameter block for all disks.
FAE2: 1A00    	          	defw  	26 	;sectors per track
FAE4: 03      		defm 	3 	;block shift factor
FAE5: 07      		defm 	7 	;block mask
FAE6: 00      		defm 	0 	;null mask
FAE7: F200    		defw 	242  	;disk size-1
FAE9: 3F00    		defw 	63 	;directory max
FAEB: C0      		defm 	192 	;alloc 0
FAEC: 00      		defm 	0 	;alloc 1
FAED: 0000    		defw 	0 	;check size
FAEF: 0200    		defw 	2 	;track offset
              	;
              	; end of fixed tables
              	;
FAF1: FFFFFFFF	dirbf: defs 128
FAF5: FF...   	
FB71: FFFFFFFF	all00: defs 31
FB75: FF...   	
FB90: FFFFFFFF	all01: defs 31
FB94: FF...   	
FBAF: FFFFFFFF	all02: defs 31
FBB3: FF...   	
FBCE: FFFFFFFF	all03: defs 31
FBD2: FF...   	
FBED: FFFFFFFF	chk00: defs 16
FBF1: FF...   	
FBFD: FFFFFFFF	chk01: defs 16
FC01: FF...   	
FC0D: FFFFFFFF	chk02: defs 16
FC11: FF...   	
FC1D: FFFFFFFF	chk03: defs 16
FC21: FF...   	
              	
              	


total time: 0.0424 sec.
no errors
