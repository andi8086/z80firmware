              	; --------------------------------------
              	; zasm: assemble "cpm.s"
              	; date: 2019-12-06 20:23:25
              	; --------------------------------------


              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*	    adapted by A. J. Reichel in 2019
              	;**************************************************************
              	;
              	;   Set memory limit here. This is the amount of contigeous
              	; ram starting from 0000. CP/M will reside at the end of this space.
              	;
0040:         	MEM	EQU	64		;for a 62k system (TS802 TEST - WORKS OK).
              	;
0003:         	IOBYTE	EQU	3		;i/o definition byte.
0004:         	TDRIVE	EQU	4		;current drive name and user number.
EC14:         	ENTRY	EQU	FBASE		;entry point for the cp/m bdos.
005C:         	TFCB	EQU	5CH		;default file control block.
0080:         	TBUFF	EQU	80H		;i/o buffer and command line storage.
0100:         	TBASE	EQU	100H		;transiant program storage area.
              	;
              	;   Set control character equates.
              	;
0003:         	CNTRLC	EQU	3		;control-c
0005:         	CNTRLE	EQU	05H		;control-e
0008:         	BS	EQU	08H		;backspace
0009:         	TAB	EQU	09H		;tab
000A:         	LF	EQU	0AH		;line feed
000C:         	FF	EQU	0CH		;form feed
000D:         	CR	EQU	0DH		;carriage return
0010:         	CNTRLP	EQU	10H		;control-p
0012:         	CNTRLR	EQU	12H		;control-r
0013:         	CNTRLS	EQU	13H		;control-s
0015:         	CNTRLU	EQU	15H		;control-u
0018:         	CNTRLX	EQU	18H		;control-x
001A:         	CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
007F:         	DEL	EQU	7FH		;rubout
              	;
              	;   Set origin for CP/M
              	;
E400:         		ORG	(MEM-7)*1024
              	
E400: 113BFC  	CBASE:  LD	DE, WELCOME_MSG
E403: CD06EF  		CALL	PRTSTR
E406: 1116E4  		LD	DE, COPYRIGHT
E409: CD06EF  		CALL	PRTSTR
E40C: 0E00    		LD	C, 00000000b	; UUUUDDDD, u=user, d=drive
E40E: C36AE7  		JP	COMMAND		;execute command processor (ccp).
E411: C366E7  		JP	CLEARBUF	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   Standard cp/m ccp input buffer. Format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
E414: 7F      	INBUFF:	DEFB	127		;length of input buffer.
E415: 00      		DEFB	0		;current length of contents.
E416:         	COPYRIGHT:
E416: 436F7079		DEFB	'Copyright'
E41A: 72696768	
E41E: 74      	
E41F: 20313937		DEFB	' 1979 (c) by Digital Research   ',0Ah,0Dh,'$'
E423: 39202863	
E427: 29206279	
E42B: 20446967	
E42F: 6974616C	
E433: 20526573	
E437: 65617263	
E43B: 68202020	
E43F: 0A0D24  	
E442: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E446: 00...   	
E459: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E45D: 00...   	
E470: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E474: 00...   	
E487: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E48B: 00...   	
E496: 16E4    	INPOINT:DEFW	INBUFF+2	;input line pointer
E498: 0000    	NAMEPNT:DEFW	0		;input line pointer used for error message. Points to
              	;			;start of name in error.
              	;
              	;   Routine to print (A) on the console. All registers used.
              	;
E49A: 5F      	PRINT:	LD	E,A		;setup bdos call.
E49B: 0E02    		LD	C,2
E49D: C314EC  		JP	ENTRY
              	;
              	;   Routine to print (A) on the console and to save (BC).
              	;
E4A0: C5      	PRINTB:	PUSH	BC
E4A1: CD9AE4  		CALL	PRINT
E4A4: C1      		POP	BC
E4A5: C9      		RET
              	;
              	;   Routine to send a carriage return, line feed combination
              	; to the console.
              	;
E4A6: 3E0D    	CRLF:	LD	A,CR
E4A8: CDA0E4  		CALL	PRINTB
E4AB: 3E0A    		LD	A,LF
E4AD: C3A0E4  		JP	PRINTB
              	;
              	;   Routine to send one space to the console and save (BC).
              	;
E4B0: 3E20    	SPACE:	LD	A,' '
E4B2: C3A0E4  		JP	PRINTB
              	;
              	;   Routine to print character string pointed to be (BC) on the
              	; console. It must terminate with a null byte.
              	;
E4B5: C5      	PLINE:	PUSH	BC
E4B6: CDA6E4  		CALL	CRLF
E4B9: E1      		POP	HL
E4BA: 7E      	PLINE2:	LD	A,(HL)
E4BB: B7      		OR	A
E4BC: C8      		RET	Z
E4BD: 23      		INC	HL
E4BE: E5      		PUSH	HL
E4BF: CD9AE4  		CALL	PRINT
E4C2: E1      		POP	HL
E4C3: C3BAE4  		JP	PLINE2
              	;
              	;   Routine to reset the disk system.
              	;
E4C6: 0E0D    	RESDSK:	LD	C,13
E4C8: C314EC  		JP	ENTRY
              	;
              	;   Routine to select disk (A).
              	;
E4CB: 5F      	DSKSEL:	LD	E,A
E4CC: 0E0E    		LD	C,14
E4CE: C314EC  		JP	ENTRY
              	;
              	;   Routine to call bdos and save the return code. The zero
              	; flag is set on a return of 0ffh.
              	;
E4D1: CD14EC  	ENTRY1:	CALL	ENTRY
E4D4: 32FCEB  		LD	(RTNCODE),A	;save return code.
E4D7: 3C      		INC	A		;set zero if 0ffh returned.
E4D8: C9      		RET
              	;
              	;   Routine to open a file. (DE) must point to the FCB.
              	;
E4D9: 0E0F    	OPEN:	LD	C,15
E4DB: C3D1E4  		JP	ENTRY1
              	;
              	;   Routine to open file at (FCB).
              	;
E4DE: AF      	OPENFCB:XOR	A		;clear the record number byte at fcb+32
E4DF: 32FBEB  		LD	(FCB+32),A
E4E2: 11DBEB  		LD	DE,FCB
E4E5: C3D9E4  		JP	OPEN
              	;
              	;   Routine to close a file. (DE) points to FCB.
              	;
E4E8: 0E10    	CLOSE:	LD	C,16
E4EA: C3D1E4  		JP	ENTRY1
              	;
              	;   Routine to search for the first file with ambigueous name
              	; (DE).
              	;
E4ED: 0E11    	SRCHFST:LD	C,17
E4EF: C3D1E4  		JP	ENTRY1
              	;
              	;   Search for the next ambigeous file name.
              	;
E4F2: 0E12    	SRCHNXT:LD	C,18
E4F4: C3D1E4  		JP	ENTRY1
              	;
              	;   Search for file at (FCB).
              	;
E4F7: 11DBEB  	SRCHFCB:LD	DE,FCB
E4FA: C3EDE4  		JP	SRCHFST
              	;
              	;   Routine to delete a file pointed to by (DE).
              	;
E4FD: 0E13    	DELETE:	LD	C,19
E4FF: C314EC  		JP	ENTRY
              	;
              	;   Routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
E502: CD14EC  	ENTRY2:	CALL	ENTRY
E505: B7      		OR	A		;set zero flag if appropriate.
E506: C9      		RET
              	;
              	;   Routine to read the next record from a sequential file.
              	; (DE) points to the FCB.
              	;
E507: 0E14    	RDREC:	LD	C,20
E509: C302E5  		JP	ENTRY2
              	;
              	;   Routine to read file at (FCB).
              	;
E50C: 11DBEB  	READFCB:LD	DE,FCB
E50F: C307E5  		JP	RDREC
              	;
              	;   Routine to write the next record of a sequential file.
              	; (DE) points to the FCB.
              	;
E512: 0E15    	WRTREC:	LD	C,21
E514: C302E5  		JP	ENTRY2
              	;
              	;   Routine to create the file pointed to by (DE).
              	;
E517: 0E16    	CREATE:	LD	C,22
E519: C3D1E4  		JP	ENTRY1
              	;
              	;   Routine to rename the file pointed to by (DE). Note that
              	; the new name starts at (DE+16).
              	;
E51C: 0E17    	RENAM:	LD	C,23
E51E: C314EC  		JP	ENTRY
              	;
              	;   Get the current user code.
              	;
E521: 1EFF    	GETUSR:	LD	E,0FFH
              	;
              	;   Routne to get or set the current user code.
              	; If (E) is FF then this is a GET, else it is a SET.
              	;
E523: 0E20    	GETSETUC: LD	C,32
E525: C314EC  		JP	ENTRY
              	;
              	;   Routine to set the current drive byte at (TDRIVE).
              	;
E528: CD21E5  	SETCDRV:CALL	GETUSR		;get user number
E52B: 87      		ADD	A,A		;and shift into the upper 4 bits.
E52C: 87      		ADD	A,A
E52D: 87      		ADD	A,A
E52E: 87      		ADD	A,A
E52F: 21FDEB  		LD	HL,CDRIVE	;now add in the current drive number.
E532: B6      		OR	(HL)
E533: 320400  		LD	(TDRIVE),A	;and save.
E536: C9      		RET
              	;
              	;   Move currently active drive down to (TDRIVE).
              	;
E537: 3AFDEB  	MOVECD:	LD	A,(CDRIVE)
E53A: 320400  		LD	(TDRIVE),A
E53D: C9      		RET
              	;
              	;   Routine to convert (A) into upper case ascii. Only letters
              	; are affected.
              	;
E53E: FE61    	UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
E540: D8      		RET	C
E541: FE7B    		CP	'{'
E543: D0      		RET	NC
E544: E65F    		AND	5FH		;convert it if found.
E546: C9      		RET
              	;
              	;   Routine to get a line of input. We must check to see if the
              	; user is in (BATCH) mode. If so, then read the input from file
              	; ($$$.SUB). At the end, reset to console input.
              	;
E547: 3AB9EB  	GETINP:	LD	A,(BATCH)	;if =0, then use console input.
E54A: B7      		OR	A
E54B: CAA4E5  		JP	Z,GETINP1
              	;
              	;   Use the submit file ($$$.sub) which is prepared by a
              	; SUBMIT run. It must be on drive (A) and it will be deleted
              	; if and error occures (like eof).
              	;
E54E: 3AFDEB  		LD	A,(CDRIVE)	;select drive 0 if need be.
E551: B7      		OR	A
E552: 3E00    		LD	A,0		;always use drive A for submit.
E554: C4CBE4  		CALL	NZ,DSKSEL	;select it if required.
E557: 11BAEB  		LD	DE,BATCHFCB
E55A: CDD9E4  		CALL	OPEN		;look for it.
E55D: CAA4E5  		JP	Z,GETINP1	;if not there, use normal input.
E560: 3AC9EB  		LD	A,(BATCHFCB+15)	;get last record number+1.
E563: 3D      		DEC	A
E564: 32DAEB  		LD	(BATCHFCB+32),A
E567: 11BAEB  		LD	DE,BATCHFCB
E56A: CD07E5  		CALL	RDREC		;read last record.
E56D: C2A4E5  		JP	NZ,GETINP1	;quit on end of file.
              	;
              	;   Move this record into input buffer.
              	;
E570: 1115E4  		LD	DE,INBUFF+1
E573: 218000  		LD	HL,TBUFF	;data was read into buffer here.
E576: 0680    		LD	B,128		;all 128 characters may be used.
E578: CD50E8  		CALL	HL2DE		;(HL) to (DE), (B) bytes.
E57B: 21C8EB  		LD	HL,BATCHFCB+14
E57E: 3600    		LD	(HL),0		;zero out the 's2' byte.
E580: 23      		INC	HL		;and decrement the record count.
E581: 35      		DEC	(HL)
E582: 11BAEB  		LD	DE,BATCHFCB	;close the batch file now.
E585: CDE8E4  		CALL	CLOSE
E588: CAA4E5  		JP	Z,GETINP1	;quit on an error.
E58B: 3AFDEB  		LD	A,(CDRIVE)	;re-select previous drive if need be.
E58E: B7      		OR	A
E58F: C4CBE4  		CALL	NZ,DSKSEL	;don't do needless selects.
              	;
              	;   Print line just read on console.
              	;
E592: 2116E4  		LD	HL,INBUFF+2
E595: CDBAE4  		CALL	PLINE2
E598: CDD0E5  		CALL	CHKCON		;check console, quit on a key.
E59B: CAB5E5  		JP	Z,GETINP2	;jump if no key is pressed.
              	;
              	;   Terminate the submit job on any keyboard input. Delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
E59E: CDEBE5  		CALL	DELBATCH	;delete the batch file.
E5A1: C390E7  		JP	CMMND1		;and restart command input.
              	;
              	;   Get here for normal keyboard input. Delete the submit file
              	; incase there was one.
              	;
E5A4: CDEBE5  	GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
E5A7: CD28E5  		CALL	SETCDRV		;reset active disk.
E5AA: 0E0A    		LD	C,10		;get line from console device.
E5AC: 1114E4  		LD	DE,INBUFF
E5AF: CD14EC  		CALL	ENTRY
E5B2: CD37E5  		CALL	MOVECD		;reset current drive (again).
              	;
              	;   Convert input line to upper case.
              	;
E5B5: 2115E4  	GETINP2:LD	HL,INBUFF+1
E5B8: 46      		LD	B,(HL)		;(B)=character counter.
E5B9: 23      	GETINP3:INC	HL
E5BA: 78      		LD	A,B		;end of the line?
E5BB: B7      		OR	A
E5BC: CAC8E5  		JP	Z,GETINP4
E5BF: 7E      		LD	A,(HL)		;convert to upper case.
E5C0: CD3EE5  		CALL	UPPER
E5C3: 77      		LD	(HL),A
E5C4: 05      		DEC	B		;adjust character count.
E5C5: C3B9E5  		JP	GETINP3
E5C8: 77      	GETINP4:LD	(HL),A		;add trailing null.
E5C9: 2116E4  		LD	HL,INBUFF+2
E5CC: 2296E4  		LD	(INPOINT),HL	;reset input line pointer.
E5CF: C9      		RET
              	;
              	;   Routine to check the console for a key pressed. The zero
              	; flag is set is none, else the character is returned in (A).
              	;
E5D0: 0E0B    	CHKCON:	LD	C,11		;check console.
E5D2: CD14EC  		CALL	ENTRY
E5D5: B7      		OR	A
E5D6: C8      		RET	Z		;return if nothing.
E5D7: 0E01    		LD	C,1		;else get character.
E5D9: CD14EC  		CALL	ENTRY
E5DC: B7      		OR	A		;clear zero flag and return.
E5DD: C9      		RET
              	;
              	;   Routine to get the currently active drive number.
              	;
E5DE: 0E19    	GETDSK:	LD	C,25
E5E0: C314EC  		JP	ENTRY
              	;
              	;   Set the stabdard dma address.
              	;
E5E3: 118000  	STDDMA:	LD	DE,TBUFF
              	;
              	;   Routine to set the dma address to (DE).
              	;
E5E6: 0E1A    	DMASET:	LD	C,26
E5E8: C314EC  		JP	ENTRY
              	;
              	;  Delete the batch file created by SUBMIT.
              	;
E5EB: 21B9EB  	DELBATCH: LD	HL,BATCH	;is batch active?
E5EE: 7E      		LD	A,(HL)
E5EF: B7      		OR	A
E5F0: C8      		RET	Z
E5F1: 3600    		LD	(HL),0		;yes, de-activate it.
E5F3: AF      		XOR	A
E5F4: CDCBE4  		CALL	DSKSEL		;select drive 0 for sure.
E5F7: 11BAEB  		LD	DE,BATCHFCB	;and delete this file.
E5FA: CDFDE4  		CALL	DELETE
E5FD: 3AFDEB  		LD	A,(CDRIVE)	;reset current drive.
E600: C3CBE4  		JP	DSKSEL
              	;
              	;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
              	; the same or we halt....
              	;
E603: 1136E7  	VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
E606: 210EEC  		LD	HL,PATTRN2	;ditto, but how could they be different?
E609: 0606    		LD	B,6		;6 bytes each.
E60B: 1A      	VERIFY1:LD	A,(DE)
E60C: BE      		CP	(HL)
E60D: C2DDE7  		JP	NZ,HALT		;jump to halt routine.
E610: 13      		INC	DE
E611: 23      		INC	HL
E612: 05      		DEC	B
E613: C20BE6  		JP	NZ,VERIFY1
E616: C9      		RET
              	;
              	;   Print back file name with a '?' to indicate a syntax error.
              	;
E617: CDA6E4  	SYNERR:	CALL	CRLF		;end current line.
E61A: 2A98E4  		LD	HL,(NAMEPNT)	;this points to name in error.
E61D: 7E      	SYNERR1:LD	A,(HL)		;print it until a space or null is found.
E61E: FE20    		CP	' '
E620: CA30E6  		JP	Z,SYNERR2
E623: B7      		OR	A
E624: CA30E6  		JP	Z,SYNERR2
E627: E5      		PUSH	HL
E628: CD9AE4  		CALL	PRINT
E62B: E1      		POP	HL
E62C: 23      		INC	HL
E62D: C31DE6  		JP	SYNERR1
E630: 3E3F    	SYNERR2:LD	A,'?'		;add trailing '?'.
E632: CD9AE4  		CALL	PRINT
E635: CDA6E4  		CALL	CRLF
E638: CDEBE5  		CALL	DELBATCH	;delete any batch file.
E63B: C390E7  		JP	CMMND1		;and restart from console input.
              	;
              	;   Check character at (DE) for legal command input. Note that the
              	; zero flag is set if the character is a delimiter.
              	;
E63E: 1A      	CHECK:	LD	A,(DE)
E63F: B7      		OR	A
E640: C8      		RET	Z
E641: FE20    		CP	' '		;control characters are not legal here.
E643: DA17E6  		JP	C,SYNERR
E646: C8      		RET	Z		;check for valid delimiter.
E647: FE3D    		CP	'='
E649: C8      		RET	Z
E64A: FE5F    		CP	'_'
E64C: C8      		RET	Z
E64D: FE2E    		CP	'.'
E64F: C8      		RET	Z
E650: FE3A    		CP	':'
E652: C8      		RET	Z
E653: FE3B    		CP	';'
E655: C8      		RET	Z
E656: FE3C    		CP	'<'
E658: C8      		RET	Z
E659: FE3E    		CP	'>'
E65B: C8      		RET	Z
E65C: C9      		RET
              	;
              	;   Get the next non-blank character from (DE).
              	;
E65D: 1A      	NONBLANK: LD	A,(DE)
E65E: B7      		OR	A		;string ends with a null.
E65F: C8      		RET	Z
E660: FE20    		CP	' '
E662: C0      		RET	NZ
E663: 13      		INC	DE
E664: C35DE6  		JP	NONBLANK
              	;
              	;   Add (HL)=(HL)+(A)
              	;
E667: 85      	ADDHL:	ADD	A,L
E668: 6F      		LD	L,A
E669: D0      		RET	NC		;take care of any carry.
E66A: 24      		INC	H
E66B: C9      		RET
              	;
              	;   Convert the first name in (FCB).
              	;
E66C: 3E00    	CONVFST:LD	A,0
              	;
              	;   Format a file name (convert * to '?', etc.). On return,
              	; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
E66E: 21DBEB  	CONVERT:LD	HL,FCB
E671: CD67E6  		CALL	ADDHL
E674: E5      		PUSH	HL
E675: E5      		PUSH	HL
E676: AF      		XOR	A
E677: 32FEEB  		LD	(CHGDRV),A	;initialize drive change flag.
E67A: 2A96E4  		LD	HL,(INPOINT)	;set (HL) as pointer into input line.
E67D: EB      		EX	DE,HL
E67E: CD5DE6  		CALL	NONBLANK	;get next non-blank character.
E681: EB      		EX	DE,HL
E682: 2298E4  		LD	(NAMEPNT),HL	;save pointer here for any error message.
E685: EB      		EX	DE,HL
E686: E1      		POP	HL
E687: 1A      		LD	A,(DE)		;get first character.
E688: B7      		OR	A
E689: CA97E6  		JP	Z,CONVRT1
E68C: DE40    		SBC	A,'A'-1		;might be a drive name, convert to binary.
E68E: 47      		LD	B,A		;and save.
E68F: 13      		INC	DE		;check next character for a ':'.
E690: 1A      		LD	A,(DE)
E691: FE3A    		CP	':'
E693: CA9EE6  		JP	Z,CONVRT2
E696: 1B      		DEC	DE		;nope, move pointer back to the start of the line.
E697: 3AFDEB  	CONVRT1:LD	A,(CDRIVE)
E69A: 77      		LD	(HL),A
E69B: C3A4E6  		JP	CONVRT3
E69E: 78      	CONVRT2:LD	A,B
E69F: 32FEEB  		LD	(CHGDRV),A	;set change in drives flag.
E6A2: 70      		LD	(HL),B
E6A3: 13      		INC	DE
              	;
              	;   Convert the basic file name.
              	;
E6A4: 0608    	CONVRT3:LD	B,08H
E6A6: CD3EE6  	CONVRT4:CALL	CHECK
E6A9: CAC7E6  		JP	Z,CONVRT8
E6AC: 23      		INC	HL
E6AD: FE2A    		CP	'*'		;note that an '*' will fill the remaining
E6AF: C2B7E6  		JP	NZ,CONVRT5	;field with '?'.
E6B2: 363F    		LD	(HL),'?'
E6B4: C3B9E6  		JP	CONVRT6
E6B7: 77      	CONVRT5:LD	(HL),A
E6B8: 13      		INC	DE
E6B9: 05      	CONVRT6:DEC	B
E6BA: C2A6E6  		JP	NZ,CONVRT4
E6BD: CD3EE6  	CONVRT7:CALL	CHECK		;get next delimiter.
E6C0: CACEE6  		JP	Z,GETEXT
E6C3: 13      		INC	DE
E6C4: C3BDE6  		JP	CONVRT7
E6C7: 23      	CONVRT8:INC	HL		;blank fill the file name.
E6C8: 3620    		LD	(HL),' '
E6CA: 05      		DEC	B
E6CB: C2C7E6  		JP	NZ,CONVRT8
              	;
              	;   Get the extension and convert it.
              	;
E6CE: 0603    	GETEXT:	LD	B,03H
E6D0: FE2E    		CP	'.'
E6D2: C2F7E6  		JP	NZ,GETEXT5
E6D5: 13      		INC	DE
E6D6: CD3EE6  	GETEXT1:CALL	CHECK
E6D9: CAF7E6  		JP	Z,GETEXT5
E6DC: 23      		INC	HL
E6DD: FE2A    		CP	'*'
E6DF: C2E7E6  		JP	NZ,GETEXT2
E6E2: 363F    		LD	(HL),'?'
E6E4: C3E9E6  		JP	GETEXT3
E6E7: 77      	GETEXT2:LD	(HL),A
E6E8: 13      		INC	DE
E6E9: 05      	GETEXT3:DEC	B
E6EA: C2D6E6  		JP	NZ,GETEXT1
E6ED: CD3EE6  	GETEXT4:CALL	CHECK
E6F0: CAFEE6  		JP	Z,GETEXT6
E6F3: 13      		INC	DE
E6F4: C3EDE6  		JP	GETEXT4
E6F7: 23      	GETEXT5:INC	HL
E6F8: 3620    		LD	(HL),' '
E6FA: 05      		DEC	B
E6FB: C2F7E6  		JP	NZ,GETEXT5
E6FE: 0603    	GETEXT6:LD	B,3
E700: 23      	GETEXT7:INC	HL
E701: 3600    		LD	(HL),0
E703: 05      		DEC	B
E704: C200E7  		JP	NZ,GETEXT7
E707: EB      		EX	DE,HL
E708: 2296E4  		LD	(INPOINT),HL	;save input line pointer.
E70B: E1      		POP	HL
              	;
              	;   Check to see if this is an ambigeous file name specification.
              	; Set the (A) register to non zero if it is.
              	;
E70C: 010B00  		LD	BC,11		;set name length.
E70F: 23      	GETEXT8:INC	HL
E710: 7E      		LD	A,(HL)
E711: FE3F    		CP	'?'		;any question marks?
E713: C217E7  		JP	NZ,GETEXT9
E716: 04      		INC	B		;count them.
E717: 0D      	GETEXT9:DEC	C
E718: C20FE7  		JP	NZ,GETEXT8
E71B: 78      		LD	A,B
E71C: B7      		OR	A
E71D: C9      		RET
              	;
              	;   CP/M command table. Note commands can be either 3 or 4 characters long.
              	;
0006:         	NUMCMDS EQU	6		;number of commands
E71E: 44495220	CMDTBL:	DEFB	'DIR '
E722: 45524120		DEFB	'ERA '
E726: 54595045		DEFB	'TYPE'
E72A: 53415645		DEFB	'SAVE'
E72E: 52454E20		DEFB	'REN '
E732: 55534552		DEFB	'USER'
              	;
              	;   The following six bytes must agree with those at (PATTRN2)
              	; or cp/m will HALT. Why?
              	;
E736: 00160000	PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
E73A: 0000    	
              	;
              	;   Search the command table for a match with what has just
              	; been entered. If a match is found, then we jump to the
              	; proper section. Else jump to (UNKNOWN).
              	; On return, the (C) register is set to the command number
              	; that matched (or NUMCMDS+1 if no match).
              	;
E73C: 211EE7  	SEARCH:	LD	HL,CMDTBL
E73F: 0E00    		LD	C,0
E741: 79      	SEARCH1:LD	A,C
E742: FE06    		CP	NUMCMDS		;this commands exists.
E744: D0      		RET	NC
E745: 11DCEB  		LD	DE,FCB+1	;check this one.
E748: 0604    		LD	B,4		;max command length.
E74A: 1A      	SEARCH2:LD	A,(DE)
E74B: BE      		CP	(HL)
E74C: C25DE7  		JP	NZ,SEARCH3	;not a match.
E74F: 13      		INC	DE
E750: 23      		INC	HL
E751: 05      		DEC	B
E752: C24AE7  		JP	NZ,SEARCH2
E755: 1A      		LD	A,(DE)		;allow a 3 character command to match.
E756: FE20    		CP	' '
E758: C262E7  		JP	NZ,SEARCH4
E75B: 79      		LD	A,C		;set return register for this command.
E75C: C9      		RET
E75D: 23      	SEARCH3:INC	HL
E75E: 05      		DEC	B
E75F: C25DE7  		JP	NZ,SEARCH3
E762: 0C      	SEARCH4:INC	C
E763: C341E7  		JP	SEARCH1
              	;
              	;   Set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
E766: AF      	CLEARBUF: XOR	A
E767: 3215E4  		LD	(INBUFF+1),A	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
E76A: 31B9EB  	COMMAND:LD	SP,CCPSTACK	;setup stack area.
E76D: C5      		PUSH	BC		;note that (C) should be equal to:
E76E: 79      		LD	A,C		;(uuuudddd) where 'uuuu' is the user number
E76F: 1F      		RRA			;and 'dddd' is the drive number.
E770: 1F      		RRA
E771: 1F      		RRA
E772: 1F      		RRA
E773: E60F    		AND	0FH		;isolate the user number.
E775: 5F      		LD	E,A
E776: CD23E5  		CALL	GETSETUC	;and set it.
E779: CDC6E4  		CALL	RESDSK		;reset the disk system.
E77C: 32B9EB  		LD	(BATCH),A	;clear batch mode flag.
E77F: C1      		POP	BC
E780: 79      		LD	A,C
E781: E60F    		AND	0FH		;isolate the drive number.
E783: 32FDEB  		LD	(CDRIVE),A	;and save.
E786: CDCBE4  		CALL	DSKSEL		;...and select.
E789: 3A15E4  		LD	A,(INBUFF+1)
E78C: B7      		OR	A		;anything in input buffer already?
E78D: C2A6E7  		JP	NZ,CMMND2	;yes, we just process it.
              	;
              	;   Entry point to get a command line from the console.
              	;
E790: 31B9EB  	CMMND1:	LD	SP,CCPSTACK	;set stack straight.
E793: CDA6E4  		CALL	CRLF		;start a new line on the screen.
E796: CDDEE5  		CALL	GETDSK		;get current drive.
E799: C661    		ADD	A,'a'
E79B: CD9AE4  		CALL	PRINT		;print current drive.
E79E: 3E3E    		LD	A,'>'
E7A0: CD9AE4  		CALL	PRINT		;and add prompt.
E7A3: CD47E5  		CALL	GETINP		;get line from user.
              	;
              	;   Process command line here.
              	;
E7A6: 118000  	CMMND2:	LD	DE,TBUFF
E7A9: CDE6E5  		CALL	DMASET		;set standard dma address.
E7AC: CDDEE5  		CALL	GETDSK
E7AF: 32FDEB  		LD	(CDRIVE),A	;set current drive.
E7B2: CD6CE6  		CALL	CONVFST		;convert name typed in.
E7B5: C417E6  		CALL	NZ,SYNERR	;wild cards are not allowed.
E7B8: 3AFEEB  		LD	A,(CHGDRV)	;if a change in drives was indicated,
E7BB: B7      		OR	A		;then treat this as an unknown command
E7BC: C2B3EA  		JP	NZ,UNKNOWN	;which gets executed.
E7BF: CD3CE7  		CALL	SEARCH		;else search command table for a match.
              	;
              	;   Note that an unknown command returns
              	; with (A) pointing to the last address
              	; in our table which is (UNKNOWN).
              	;
E7C2: 21CFE7  		LD	HL,CMDADR	;now, look thru our address table for command (A).
E7C5: 5F      		LD	E,A		;set (DE) to command number.
E7C6: 1600    		LD	D,0
E7C8: 19      		ADD	HL,DE
E7C9: 19      		ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
E7CA: 7E      		LD	A,(HL)		;now pick out this address.
E7CB: 23      		INC	HL
E7CC: 66      		LD	H,(HL)
E7CD: 6F      		LD	L,A
E7CE: E9      		JP	(HL)		;now execute it.
              	;
              	;   CP/M command address table.
              	;
E7CF: 85E82DE9	CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE
E7D3: 6BE9BBE9	
E7D7: 1EEA9CEA		DEFW	RENAME,USER,UNKNOWN
E7DB: B3EA    	
              	;
              	;   Halt the system. Reason for this is unknown at present.
              	;
E7DD: 21F376  	HALT:	LD	HL,76F3H	;'DI HLT' instructions.
E7E0: 2200E4  		LD	(CBASE),HL
E7E3: 2100E4  		LD	HL,CBASE
E7E6: E9      		JP	(HL)
              	;
              	;   Read error while TYPEing a file.
              	;
E7E7: 01EDE7  	RDERROR:LD	BC,RDERR
E7EA: C3B5E4  		JP	PLINE
E7ED: 52656164	RDERR:	DEFB	'Read error',0
E7F1: 20657272	
E7F5: 6F7200  	
              	;
              	;   Required file was not located.
              	;
E7F8: 01FEE7  	NONE:	LD	BC,NOFILE
E7FB: C3B5E4  		JP	PLINE
E7FE: 4E6F2066	NOFILE:	DEFB	'No file',0
E802: 696C6500	
              	;
              	;   Decode a command of the form 'A>filename number{ filename}.
              	; Note that a drive specifier is not allowed on the first file
              	; name. On return, the number is in register (A). Any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
E806: CD6CE6  	DECODE:	CALL	CONVFST		;convert filename.
E809: 3AFEEB  		LD	A,(CHGDRV)	;do not allow a drive to be specified.
E80C: B7      		OR	A
E80D: C217E6  		JP	NZ,SYNERR
E810: 21DCEB  		LD	HL,FCB+1	;convert number now.
E813: 010B00  		LD	BC,11		;(B)=sum register, (C)=max digit count.
E816: 7E      	DECODE1:LD	A,(HL)
E817: FE20    		CP	' '		;a space terminates the numeral.
E819: CA41E8  		JP	Z,DECODE3
E81C: 23      		INC	HL
E81D: D630    		SUB	'0'		;make binary from ascii.
E81F: FE0A    		CP	10		;legal digit?
E821: D217E6  		JP	NC,SYNERR
E824: 57      		LD	D,A		;yes, save it in (D).
E825: 78      		LD	A,B		;compute (B)=(B)*10 and check for overflow.
E826: E6E0    		AND	0E0H
E828: C217E6  		JP	NZ,SYNERR
E82B: 78      		LD	A,B
E82C: 07      		RLCA
E82D: 07      		RLCA
E82E: 07      		RLCA			;(A)=(B)*8
E82F: 80      		ADD	A,B		;.......*9
E830: DA17E6  		JP	C,SYNERR
E833: 80      		ADD	A,B		;.......*10
E834: DA17E6  		JP	C,SYNERR
E837: 82      		ADD	A,D		;add in new digit now.
E838: DA17E6  	DECODE2:JP	C,SYNERR
E83B: 47      		LD	B,A		;and save result.
E83C: 0D      		DEC	C		;only look at 11 digits.
E83D: C216E8  		JP	NZ,DECODE1
E840: C9      		RET
E841: 7E      	DECODE3:LD	A,(HL)		;spaces must follow (why?).
E842: FE20    		CP	' '
E844: C217E6  		JP	NZ,SYNERR
E847: 23      		INC	HL
E848: 0D      	DECODE4:DEC	C
E849: C241E8  		JP	NZ,DECODE3
E84C: 78      		LD	A,B		;set (A)=the numeric value entered.
E84D: C9      		RET
              	;
              	;   Move 3 bytes from (HL) to (DE). Note that there is only
              	; one reference to this at (A2D5h).
              	;
E84E: 0603    	MOVE3:	LD	B,3
              	;
              	;   Move (B) bytes from (HL) to (DE).
              	;
E850: 7E      	HL2DE:	LD	A,(HL)
E851: 12      		LD	(DE),A
E852: 23      		INC	HL
E853: 13      		INC	DE
E854: 05      		DEC	B
E855: C250E8  		JP	NZ,HL2DE
E858: C9      		RET
              	;
              	;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
              	;
E859: 218000  	EXTRACT:LD	HL,TBUFF
E85C: 81      		ADD	A,C
E85D: CD67E6  		CALL	ADDHL
E860: 7E      		LD	A,(HL)
E861: C9      		RET
              	;
              	;  Check drive specified. If it means a change, then the new
              	; drive will be selected. In any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
E862: AF      	DSELECT:XOR	A		;null out first byte of fcb.
E863: 32DBEB  		LD	(FCB),A
E866: 3AFEEB  		LD	A,(CHGDRV)	;a drive change indicated?
E869: B7      		OR	A
E86A: C8      		RET	Z
E86B: 3D      		DEC	A		;yes, is it the same as the current drive?
E86C: 21FDEB  		LD	HL,CDRIVE
E86F: BE      		CP	(HL)
E870: C8      		RET	Z
E871: C3CBE4  		JP	DSKSEL		;no. Select it then.
              	;
              	;   Check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
E874: 3AFEEB  	RESETDR:LD	A,(CHGDRV)	;drive change indicated?
E877: B7      		OR	A
E878: C8      		RET	Z
E879: 3D      		DEC	A		;yes, was it a different drive?
E87A: 21FDEB  		LD	HL,CDRIVE
E87D: BE      		CP	(HL)
E87E: C8      		RET	Z
E87F: 3AFDEB  		LD	A,(CDRIVE)	;yes, re-select our old drive.
E882: C3CBE4  		JP	DSKSEL
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
E885: CD6CE6  	DIRECT:	CALL	CONVFST		;convert file name.
E888: CD62E8  		CALL	DSELECT		;select indicated drive.
E88B: 21DCEB  		LD	HL,FCB+1	;was any file indicated?
E88E: 7E      		LD	A,(HL)
E88F: FE20    		CP	' '
E891: C29DE8  		JP	NZ,DIRECT2
E894: 060B    		LD	B,11		;no. Fill field with '?' - same as *.*.
E896: 363F    	DIRECT1:LD	(HL),'?'
E898: 23      		INC	HL
E899: 05      		DEC	B
E89A: C296E8  		JP	NZ,DIRECT1
E89D: 1E00    	DIRECT2:LD	E,0		;set initial cursor position.
E89F: D5      		PUSH	DE
E8A0: CDF7E4  		CALL	SRCHFCB		;get first file name.
E8A3: CCF8E7  		CALL	Z,NONE		;none found at all?
E8A6: CA29E9  	DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
E8A9: 3AFCEB  		LD	A,(RTNCODE)	;get file's position in segment (0-3).
E8AC: 0F      		RRCA
E8AD: 0F      		RRCA
E8AE: 0F      		RRCA
E8AF: E660    		AND	60H		;(A)=position*32
E8B1: 4F      		LD	C,A
E8B2: 3E0A    		LD	A,10
E8B4: CD59E8  		CALL	EXTRACT		;extract the tenth entry in fcb.
E8B7: 17      		RLA			;check system file status bit.
E8B8: DA1DE9  		JP	C,DIRECT8	;we don't list them.
E8BB: D1      		POP	DE
E8BC: 7B      		LD	A,E		;bump name count.
E8BD: 1C      		INC	E
E8BE: D5      		PUSH	DE
E8BF: E603    		AND	03H		;at end of line?
E8C1: F5      		PUSH	AF
E8C2: C2DAE8  		JP	NZ,DIRECT4
E8C5: CDA6E4  		CALL	CRLF		;yes, end this line and start another.
E8C8: C5      		PUSH	BC
E8C9: CDDEE5  		CALL	GETDSK		;start line with ('A:').
E8CC: C1      		POP	BC
E8CD: C641    		ADD	A,'A'
E8CF: CDA0E4  		CALL	PRINTB
E8D2: 3E3A    		LD	A,':'
E8D4: CDA0E4  		CALL	PRINTB
E8D7: C3E2E8  		JP	DIRECT5
E8DA: CDB0E4  	DIRECT4:CALL	SPACE		;add seperator between file names.
E8DD: 3E3A    		LD	A,':'
E8DF: CDA0E4  		CALL	PRINTB
E8E2: CDB0E4  	DIRECT5:CALL	SPACE
E8E5: 0601    		LD	B,1		;'extract' each file name character at a time.
E8E7: 78      	DIRECT6:LD	A,B
E8E8: CD59E8  		CALL	EXTRACT
E8EB: E67F    		AND	7FH		;strip bit 7 (status bit).
E8ED: FE20    		CP	' '		;are we at the end of the name?
E8EF: C207E9  		JP	NZ,DRECT65
E8F2: F1      		POP	AF		;yes, don't print spaces at the end of a line.
E8F3: F5      		PUSH	AF
E8F4: FE03    		CP	3
E8F6: C205E9  		JP	NZ,DRECT63
E8F9: 3E09    		LD	A,9		;first check for no extension.
E8FB: CD59E8  		CALL	EXTRACT
E8FE: E67F    		AND	7FH
E900: FE20    		CP	' '
E902: CA1CE9  		JP	Z,DIRECT7	;don't print spaces.
E905: 3E20    	DRECT63:LD	A,' '		;else print them.
E907: CDA0E4  	DRECT65:CALL	PRINTB
E90A: 04      		INC	B		;bump to next character psoition.
E90B: 78      		LD	A,B
E90C: FE0C    		CP	12		;end of the name?
E90E: D21CE9  		JP	NC,DIRECT7
E911: FE09    		CP	9		;nope, starting extension?
E913: C2E7E8  		JP	NZ,DIRECT6
E916: CDB0E4  		CALL	SPACE		;yes, add seperating space.
E919: C3E7E8  		JP	DIRECT6
E91C: F1      	DIRECT7:POP	AF		;get the next file name.
E91D: CDD0E5  	DIRECT8:CALL	CHKCON		;first check console, quit on anything.
E920: C229E9  		JP	NZ,DIRECT9
E923: CDF2E4  		CALL	SRCHNXT		;get next name.
E926: C3A6E8  		JP	DIRECT3		;and continue with our list.
E929: D1      	DIRECT9:POP	DE		;restore the stack and return to command level.
E92A: C394EB  		JP	GETBACK
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E92D: CD6CE6  	ERASE:	CALL	CONVFST		;convert file name.
E930: FE0B    		CP	11		;was '*.*' entered?
E932: C250E9  		JP	NZ,ERASE1
E935: 0160E9  		LD	BC,YESNO	;yes, ask for confirmation.
E938: CDB5E4  		CALL	PLINE
E93B: CD47E5  		CALL	GETINP
E93E: 2115E4  		LD	HL,INBUFF+1
E941: 35      		DEC	(HL)		;must be exactly 'y'.
E942: C290E7  		JP	NZ,CMMND1
E945: 23      		INC	HL
E946: 7E      		LD	A,(HL)
E947: FE59    		CP	'Y'
E949: C290E7  		JP	NZ,CMMND1
E94C: 23      		INC	HL
E94D: 2296E4  		LD	(INPOINT),HL	;save input line pointer.
E950: CD62E8  	ERASE1:	CALL	DSELECT		;select desired disk.
E953: 11DBEB  		LD	DE,FCB
E956: CDFDE4  		CALL	DELETE		;delete the file.
E959: 3C      		INC	A
E95A: CCF8E7  		CALL	Z,NONE		;not there?
E95D: C394EB  		JP	GETBACK		;return to command level now.
E960: 416C6C20	YESNO:	DEFB	'All (y/n)?',0
E964: 28792F6E	
E968: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E96B: CD6CE6  	TYPE:	CALL	CONVFST		;convert file name.
E96E: C217E6  		JP	NZ,SYNERR	;wild cards not allowed.
E971: CD62E8  		CALL	DSELECT		;select indicated drive.
E974: CDDEE4  		CALL	OPENFCB		;open the file.
E977: CAB5E9  		JP	Z,TYPE5		;not there?
E97A: CDA6E4  		CALL	CRLF		;ok, start a new line on the screen.
E97D: 21FFEB  		LD	HL,NBYTES	;initialize byte counter.
E980: 36FF    		LD	(HL),0FFH	;set to read first sector.
E982: 21FFEB  	TYPE1:	LD	HL,NBYTES
E985: 7E      	TYPE2:	LD	A,(HL)		;have we written the entire sector?
E986: FE80    		CP	128
E988: DA95E9  		JP	C,TYPE3
E98B: E5      		PUSH	HL		;yes, read in the next one.
E98C: CD0CE5  		CALL	READFCB
E98F: E1      		POP	HL
E990: C2AEE9  		JP	NZ,TYPE4	;end or error?
E993: AF      		XOR	A		;ok, clear byte counter.
E994: 77      		LD	(HL),A
E995: 34      	TYPE3:	INC	(HL)		;count this byte.
E996: 218000  		LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
E999: CD67E6  		CALL	ADDHL
E99C: 7E      		LD	A,(HL)
E99D: FE1A    		CP	CNTRLZ		;end of file mark?
E99F: CA94EB  		JP	Z,GETBACK
E9A2: CD9AE4  		CALL	PRINT		;no, print it.
E9A5: CDD0E5  		CALL	CHKCON		;check console, quit if anything ready.
E9A8: C294EB  		JP	NZ,GETBACK
E9AB: C382E9  		JP	TYPE1
              	;
              	;   Get here on an end of file or read error.
              	;
E9AE: 3D      	TYPE4:	DEC	A		;read error?
E9AF: CA94EB  		JP	Z,GETBACK
E9B2: CDE7E7  		CALL	RDERROR		;yes, print message.
E9B5: CD74E8  	TYPE5:	CALL	RESETDR		;and reset proper drive
E9B8: C317E6  		JP	SYNERR		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E9BB: CD06E8  	SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
E9BE: F5      		PUSH	AF		;save number of pages to write.
E9BF: CD6CE6  		CALL	CONVFST		;convert file name.
E9C2: C217E6  		JP	NZ,SYNERR	;wild cards not allowed.
E9C5: CD62E8  		CALL	DSELECT		;select specified drive.
E9C8: 11DBEB  		LD	DE,FCB		;now delete this file.
E9CB: D5      		PUSH	DE
E9CC: CDFDE4  		CALL	DELETE
E9CF: D1      		POP	DE
E9D0: CD17E5  		CALL	CREATE		;and create it again.
E9D3: CA09EA  		JP	Z,SAVE3		;can't create?
E9D6: AF      		XOR	A		;clear record number byte.
E9D7: 32FBEB  		LD	(FCB+32),A
E9DA: F1      		POP	AF		;convert pages to sectors.
E9DB: 6F      		LD	L,A
E9DC: 2600    		LD	H,0
E9DE: 29      		ADD	HL,HL		;(HL)=number of sectors to write.
E9DF: 110001  		LD	DE,TBASE	;and we start from here.
E9E2: 7C      	SAVE1:	LD	A,H		;done yet?
E9E3: B5      		OR	L
E9E4: CAFFE9  		JP	Z,SAVE2
E9E7: 2B      		DEC	HL		;nope, count this and compute the start
E9E8: E5      		PUSH	HL		;of the next 128 byte sector.
E9E9: 218000  		LD	HL,128
E9EC: 19      		ADD	HL,DE
E9ED: E5      		PUSH	HL		;save it and set the transfer address.
E9EE: CDE6E5  		CALL	DMASET
E9F1: 11DBEB  		LD	DE,FCB		;write out this sector now.
E9F4: CD12E5  		CALL	WRTREC
E9F7: D1      		POP	DE		;reset (DE) to the start of the last sector.
E9F8: E1      		POP	HL		;restore sector count.
E9F9: C209EA  		JP	NZ,SAVE3	;write error?
E9FC: C3E2E9  		JP	SAVE1
              	;
              	;   Get here after writing all of the file.
              	;
E9FF: 11DBEB  	SAVE2:	LD	DE,FCB		;now close the file.
EA02: CDE8E4  		CALL	CLOSE
EA05: 3C      		INC	A		;did it close ok?
EA06: C20FEA  		JP	NZ,SAVE4
              	;
              	;   Print out error message (no space).
              	;
EA09: 0115EA  	SAVE3:	LD	BC,NOSPACE
EA0C: CDB5E4  		CALL	PLINE
EA0F: CDE3E5  	SAVE4:	CALL	STDDMA		;reset the standard dma address.
EA12: C394EB  		JP	GETBACK
EA15: 4E6F2073	NOSPACE:DEFB	'No space',0
EA19: 70616365	
EA1D: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
EA1E: CD6CE6  	RENAME:	CALL	CONVFST		;convert first file name.
EA21: C217E6  		JP	NZ,SYNERR	;wild cards not allowed.
EA24: 3AFEEB  		LD	A,(CHGDRV)	;remember any change in drives specified.
EA27: F5      		PUSH	AF
EA28: CD62E8  		CALL	DSELECT		;and select this drive.
EA2B: CDF7E4  		CALL	SRCHFCB		;is this file present?
EA2E: C287EA  		JP	NZ,RENAME6	;yes, print error message.
EA31: 21DBEB  		LD	HL,FCB		;yes, move this name into second slot.
EA34: 11EBEB  		LD	DE,FCB+16
EA37: 0610    		LD	B,16
EA39: CD50E8  		CALL	HL2DE
EA3C: 2A96E4  		LD	HL,(INPOINT)	;get input pointer.
EA3F: EB      		EX	DE,HL
EA40: CD5DE6  		CALL	NONBLANK	;get next non blank character.
EA43: FE3D    		CP	'='		;only allow an '=' or '_' seperator.
EA45: CA4DEA  		JP	Z,RENAME1
EA48: FE5F    		CP	'_'
EA4A: C281EA  		JP	NZ,RENAME5
EA4D: EB      	RENAME1:EX	DE,HL
EA4E: 23      		INC	HL		;ok, skip seperator.
EA4F: 2296E4  		LD	(INPOINT),HL	;save input line pointer.
EA52: CD6CE6  		CALL	CONVFST		;convert this second file name now.
EA55: C281EA  		JP	NZ,RENAME5	;again, no wild cards.
EA58: F1      		POP	AF		;if a drive was specified, then it
EA59: 47      		LD	B,A		;must be the same as before.
EA5A: 21FEEB  		LD	HL,CHGDRV
EA5D: 7E      		LD	A,(HL)
EA5E: B7      		OR	A
EA5F: CA67EA  		JP	Z,RENAME2
EA62: B8      		CP	B
EA63: 70      		LD	(HL),B
EA64: C281EA  		JP	NZ,RENAME5	;they were different, error.
EA67: 70      	RENAME2:LD	(HL),B		;	reset as per the first file specification.
EA68: AF      		XOR	A
EA69: 32DBEB  		LD	(FCB),A		;clear the drive byte of the fcb.
EA6C: CDF7E4  	RENAME3:CALL	SRCHFCB		;and go look for second file.
EA6F: CA7BEA  		JP	Z,RENAME4	;doesn't exist?
EA72: 11DBEB  		LD	DE,FCB
EA75: CD1CE5  		CALL	RENAM		;ok, rename the file.
EA78: C394EB  		JP	GETBACK
              	;
              	;   Process rename errors here.
              	;
EA7B: CDF8E7  	RENAME4:CALL	NONE		;file not there.
EA7E: C394EB  		JP	GETBACK
EA81: CD74E8  	RENAME5:CALL	RESETDR		;bad command format.
EA84: C317E6  		JP	SYNERR
EA87: 0190EA  	RENAME6:LD	BC,EXISTS	;destination file already exists.
EA8A: CDB5E4  		CALL	PLINE
EA8D: C394EB  		JP	GETBACK
EA90: 46696C65	EXISTS:	DEFB	'File exists',0
EA94: 20657869	
EA98: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
EA9C: CD06E8  	USER:	CALL	DECODE		;get numeric value following command.
EA9F: FE10    		CP	16		;legal user number?
EAA1: D217E6  		JP	NC,SYNERR
EAA4: 5F      		LD	E,A		;yes but is there anything else?
EAA5: 3ADCEB  		LD	A,(FCB+1)
EAA8: FE20    		CP	' '
EAAA: CA17E6  		JP	Z,SYNERR	;yes, that is not allowed.
EAAD: CD23E5  		CALL	GETSETUC	;ok, set user code.
EAB0: C397EB  		JP	GETBACK1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
EAB3: CD03E6  	UNKNOWN:CALL	VERIFY		;check for valid system (why?).
EAB6: 3ADCEB  		LD	A,(FCB+1)	;anything to execute?
EAB9: FE20    		CP	' '
EABB: C2D2EA  		JP	NZ,UNKWN1
EABE: 3AFEEB  		LD	A,(CHGDRV)	;nope, only a drive change?
EAC1: B7      		OR	A
EAC2: CA97EB  		JP	Z,GETBACK1	;neither???
EAC5: 3D      		DEC	A
EAC6: 32FDEB  		LD	(CDRIVE),A	;ok, store new drive.
EAC9: CD37E5  		CALL	MOVECD		;set (TDRIVE) also.
EACC: CDCBE4  		CALL	DSKSEL		;and select this drive.
EACF: C397EB  		JP	GETBACK1	;then return.
              	;
              	;   Here a file name was typed. Prepare to execute it.
              	;
EAD2: 11E4EB  	UNKWN1:	LD	DE,FCB+9	;an extension specified?
EAD5: 1A      		LD	A,(DE)
EAD6: FE20    		CP	' '
EAD8: C217E6  		JP	NZ,SYNERR	;yes, not allowed.
EADB: D5      	UNKWN2:	PUSH	DE
EADC: CD62E8  		CALL	DSELECT		;select specified drive.
EADF: D1      		POP	DE
EAE0: 2191EB  		LD	HL,COMFILE	;set the extension to 'COM'.
EAE3: CD4EE8  		CALL	MOVE3
EAE6: CDDEE4  		CALL	OPENFCB		;and open this file.
EAE9: CA79EB  		JP	Z,UNKWN9	;not present?
              	;
              	;   Load in the program.
              	;
EAEC: 210001  		LD	HL,TBASE	;store the program starting here.
EAEF: E5      	UNKWN3:	PUSH	HL
EAF0: EB      		EX	DE,HL
EAF1: CDE6E5  		CALL	DMASET		;set transfer address.
EAF4: 11DBEB  		LD	DE,FCB		;and read the next record.
EAF7: CD07E5  		CALL	RDREC
EAFA: C20FEB  		JP	NZ,UNKWN4	;end of file or read error?
EAFD: E1      		POP	HL		;nope, bump pointer for next sector.
EAFE: 118000  		LD	DE,128
EB01: 19      		ADD	HL,DE
EB02: 1100E4  		LD	DE,CBASE	;enough room for the whole file?
EB05: 7D      		LD	A,L
EB06: 93      		SUB	E
EB07: 7C      		LD	A,H
EB08: 9A      		SBC	A,D
EB09: D27FEB  		JP	NC,UNKWN0	;no, it can't fit.
EB0C: C3EFEA  		JP	UNKWN3
              	;
              	;   Get here after finished reading.
              	;
EB0F: E1      	UNKWN4:	POP	HL
EB10: 3D      		DEC	A		;normal end of file?
EB11: C27FEB  		JP	NZ,UNKWN0
EB14: CD74E8  		CALL	RESETDR		;yes, reset previous drive.
EB17: CD6CE6  		CALL	CONVFST		;convert the first file name that follows
EB1A: 21FEEB  		LD	HL,CHGDRV	;command name.
EB1D: E5      		PUSH	HL
EB1E: 7E      		LD	A,(HL)		;set drive code in default fcb.
EB1F: 32DBEB  		LD	(FCB),A
EB22: 3E10    		LD	A,16		;put second name 16 bytes later.
EB24: CD6EE6  		CALL	CONVERT		;convert second file name.
EB27: E1      		POP	HL
EB28: 7E      		LD	A,(HL)		;and set the drive for this second file.
EB29: 32EBEB  		LD	(FCB+16),A
EB2C: AF      		XOR	A		;clear record byte in fcb.
EB2D: 32FBEB  		LD	(FCB+32),A
EB30: 115C00  		LD	DE,TFCB		;move it into place at(005Ch).
EB33: 21DBEB  		LD	HL,FCB
EB36: 0621    		LD	B,33
EB38: CD50E8  		CALL	HL2DE
EB3B: 2116E4  		LD	HL,INBUFF+2	;now move the remainder of the input
EB3E: 7E      	UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
EB3F: B7      		OR	A		;or a null.
EB40: CA4CEB  		JP	Z,UNKWN6
EB43: FE20    		CP	' '
EB45: CA4CEB  		JP	Z,UNKWN6
EB48: 23      		INC	HL
EB49: C33EEB  		JP	UNKWN5
              	;
              	;   Do the line move now. It ends in a null byte.
              	;
EB4C: 0600    	UNKWN6:	LD	B,0		;keep a character count.
EB4E: 118100  		LD	DE,TBUFF+1	;data gets put here.
EB51: 7E      	UNKWN7:	LD	A,(HL)		;move it now.
EB52: 12      		LD	(DE),A
EB53: B7      		OR	A
EB54: CA5DEB  		JP	Z,UNKWN8
EB57: 04      		INC	B
EB58: 23      		INC	HL
EB59: 13      		INC	DE
EB5A: C351EB  		JP	UNKWN7
EB5D: 78      	UNKWN8:	LD	A,B		;now store the character count.
EB5E: 328000  		LD	(TBUFF),A
EB61: CDA6E4  		CALL	CRLF		;clean up the screen.
EB64: CDE3E5  		CALL	STDDMA		;set standard transfer address.
EB67: CD28E5  		CALL	SETCDRV		;reset current drive.
EB6A: CD0001  		CALL	TBASE		;and execute the program.
              	;
              	;   Transiant programs return here (or reboot).
              	;
EB6D: 31B9EB  		LD	SP,BATCH	;set stack first off.
EB70: CD37E5  		CALL	MOVECD		;move current drive into place (TDRIVE).
EB73: CDCBE4  		CALL	DSKSEL		;and reselect it.
EB76: C390E7  		JP	CMMND1		;back to comand mode.
              	;
              	;   Get here if some error occured.
              	;
EB79: CD74E8  	UNKWN9:	CALL	RESETDR		;inproper format.
EB7C: C317E6  		JP	SYNERR
EB7F: 0188EB  	UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
EB82: CDB5E4  		CALL	PLINE
EB85: C394EB  		JP	GETBACK
EB88: 42616420	BADLOAD:DEFB	'Bad load',0
EB8C: 6C6F6164	
EB90: 00      	
EB91: 434F4D  	COMFILE:DEFB	'COM'		;command file extension.
              	;
              	;   Get here to return to command level. We will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
EB94: CD74E8  	GETBACK:CALL	RESETDR		;reset previous drive.
EB97: CD6CE6  	GETBACK1: CALL	CONVFST		;convert first name in (FCB).
EB9A: 3ADCEB  		LD	A,(FCB+1)	;if this was just a drive change request,
EB9D: D620    		SUB	' '		;make sure it was valid.
EB9F: 21FEEB  		LD	HL,CHGDRV
EBA2: B6      		OR	(HL)
EBA3: C217E6  		JP	NZ,SYNERR
EBA6: C390E7  		JP	CMMND1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
EBA9: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EBAD: 00...   	
EBB9:         	CCPSTACK EQU	$	;end of ccp stack area.
              	;
              	;   Batch (or SUBMIT) processing information storage.
              	;
EBB9: 00      	BATCH:	DEFB	0		;batch mode flag (0=not active).
EBBA: 00242424	BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EBBE: 20202020	
EBC2: 20535542	
EBC6: 00000000	
EBCA: 00...   	
              	;
              	;   File control block setup by the CCP.
              	;
EBDB: 00202020	FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
EBDF: 20202020	
EBE3: 20202020	
EBE7: 00000000	
EBEB: 00202020	
EBEF: 20202020	
EBF3: 20202020	
EBF7: 00000000	
EBFB: 00      	
EBFC: 00      	RTNCODE:DEFB	0		;status returned from bdos call.
EBFD: 00      	CDRIVE:	DEFB	0		;currently active drive.
EBFE: 00      	CHGDRV:	DEFB	0		;change in drives flag (0=no change).
EBFF: 0000    	NBYTES:	DEFW	0		;byte counter used by TYPE.
              	;
              	;   Room for expansion?
              	;
EC01: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0
EC05: 00...   	
              	;
              	;   Note that the following six bytes must match those at
              	; (PATTRN1) or cp/m will HALT. Why?
              	;
EC0E: 00160000	PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
EC12: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
EC14: C31FEC  	FBASE:	JP	FBASE1
              	;
              	;   Bdos error table.
              	;
EC17: A7EC    	BADSCTR:DEFW	ERROR1		;bad sector on read or write.
EC19: B3EC    	BADSLCT:DEFW	ERROR2		;bad disk select.
EC1B: B9EC    	RODISK:	DEFW	ERROR3		;disk is read only.
EC1D: BFEC    	ROFILE:	DEFW	ERROR4		;file is read only.
              	;
              	;   Entry into bdos. (DE) or (E) are the parameters passed. The
              	; function number desired is in register (C).
              	;
EC1F: EB      	FBASE1:	EX	DE,HL		;save the (DE) parameters.
EC20: 2251EF  		LD	(PARAMS),HL
EC23: EB      		EX	DE,HL
EC24: 7B      		LD	A,E		;and save register (E) in particular.
EC25: 32E4F9  		LD	(EPARAM),A
EC28: 210000  		LD	HL,0
EC2B: 2253EF  		LD	(STATUS),HL	;clear return status.
EC2E: 39      		ADD	HL,SP
EC2F: 221DEF  		LD	(USRSTACK),HL	;save users stack pointer.
EC32: 314FEF  		LD	SP,STKAREA	;and set our own.
EC35: AF      		XOR	A		;clear auto select storage space.
EC36: 32EEF9  		LD	(AUTOFLAG),A
EC39: 32ECF9  		LD	(AUTO),A
EC3C: 2182F9  		LD	HL,GOBACK	;set return address.
EC3F: E5      		PUSH	HL
EC40: 79      		LD	A,C		;get function number.
EC41: FE29    		CP	NFUNCTS		;valid function number?
EC43: D0      		RET	NC
EC44: 4B      		LD	C,E		;keep single register function here.
EC45: 2155EC  		LD	HL,FUNCTNS	;now look thru the function table.
EC48: 5F      		LD	E,A
EC49: 1600    		LD	D,0		;(DE)=function number.
EC4B: 19      		ADD	HL,DE
EC4C: 19      		ADD	HL,DE		;(HL)=(start of table)+2*(function number).
EC4D: 5E      		LD	E,(HL)
EC4E: 23      		INC	HL
EC4F: 56      		LD	D,(HL)		;now (DE)=address for this function.
EC50: 2A51EF  		LD	HL,(PARAMS)	;retrieve parameters.
EC53: EB      		EX	DE,HL		;now (DE) has the original parameters.
EC54: E9      		JP	(HL)		;execute desired function.
              	;
              	;   BDOS function jump table.
              	;
0029:         	NFUNCTS EQU	41		;number of functions in followin table.
              	;
EC55: 11FAD6EE	FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
EC59: 9EEDDCEE	
EC5D: 20FA1DFA	
EC61: E2EEFBEE	
EC65: 01EF06EF		DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
EC69: EFED0CEF	
EC6D: 8CF891F8	
EC71: 53F8AAF8	
EC75: B3F8B9F8		DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
EC79: D6F8E5F8	
EC7D: EEF8F4F8	
EC81: FAF8    	
EC83: 03F90CF9		DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
EC87: 12F918F9	
EC8B: 1FF93AF1	
EC8F: 25F92BF9	
EC93: 34F93BF9		DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
EC97: 4FF955F9	
EC9B: 5BF91CF8	
EC9F: 61F912EF	
ECA3: 12EFA9F9		DEFW	RTN,WTSPECL
              	;
              	;   Bdos error message section.
              	;
ECA7: 21D8EC  	ERROR1:	LD	HL,BADSEC	;bad sector message.
ECAA: CDF3EC  		CALL	PRTERR		;print it and get a 1 char responce.
ECAD: FE03    		CP	CNTRLC		;re-boot request (control-c)?
ECAF: CA0000  		JP	Z,0		;yes.
ECB2: C9      		RET			;no, return to retry i/o function.
              	;
ECB3: 21E3EC  	ERROR2:	LD	HL,BADSEL	;bad drive selected.
ECB6: C3C2EC  		JP	ERROR5
              	;
ECB9: 21EFEC  	ERROR3:	LD	HL,DISKRO	;disk is read only.
ECBC: C3C2EC  		JP	ERROR5
              	;
ECBF: 21EAEC  	ERROR4:	LD	HL,FILERO	;file is read only.
              	;
ECC2: CDF3EC  	ERROR5:	CALL	PRTERR
ECC5: C30000  		JP	0		;always reboot on these errors.
              	;
ECC8: 42646F73	BDOSERR:DEFB	'Bdos Err On '
ECCC: 20457272	
ECD0: 204F6E20	
ECD4: 203A2024	BDOSDRV:DEFB	' : $'
ECD8: 42616420	BADSEC:	DEFB	'Bad Sector$'
ECDC: 53656374	
ECE0: 6F7224  	
ECE3: 53656C65	BADSEL:	DEFB	'Select$'
ECE7: 637424  	
ECEA: 46696C65	FILERO:	DEFB	'File '
ECEE: 20      	
ECEF: 522F4F24	DISKRO:	DEFB	'R/O$'
              	;
              	;   Print bdos error message.
              	;
ECF3: E5      	PRTERR:	PUSH	HL		;save second message pointer.
ECF4: CDD7ED  		CALL	OUTCRLF		;send (cr)(lf).
ECF7: 3A50EF  		LD	A,(ACTIVE)	;get active drive.
ECFA: C641    		ADD	A,'A'		;make ascii.
ECFC: 32D4EC  		LD	(BDOSDRV),A	;and put in message.
ECFF: 01C8EC  		LD	BC,BDOSERR	;and print it.
ED02: CDE1ED  		CALL	PRTMESG
ED05: C1      		POP	BC		;print second message line now.
ED06: CDE1ED  		CALL	PRTMESG
              	;
              	;   Get an input character. We will check our 1 character
              	; buffer first. This may be set by the console status routine.
              	;
ED09: 211CEF  	GETCHAR:LD	HL,CHARBUF	;check character buffer.
ED0C: 7E      		LD	A,(HL)		;anything present already?
ED0D: 3600    		LD	(HL),0		;...either case clear it.
ED0F: B7      		OR	A
ED10: C0      		RET	NZ		;yes, use it.
ED11: C317FA  		JP	CONIN		;nope, go get a character responce.
              	;
              	;   Input and echo a character.
              	;
ED14: CD09ED  	GETECHO:CALL	GETCHAR		;input a character.
ED17: CD22ED  		CALL	CHKCHAR		;carriage control?
ED1A: D8      		RET	C		;no, a regular control char so don't echo.
ED1B: F5      		PUSH	AF		;ok, save character now.
ED1C: 4F      		LD	C,A
ED1D: CD9EED  		CALL	OUTCON		;and echo it.
ED20: F1      		POP	AF		;get character and return.
ED21: C9      		RET
              	;
              	;   Check character in (A). Set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
ED22: FE0D    	CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
ED24: C8      		RET	Z		;or a tab.
ED25: FE0A    		CP	LF
ED27: C8      		RET	Z
ED28: FE09    		CP	TAB
ED2A: C8      		RET	Z
ED2B: FE08    		CP	BS
ED2D: C8      		RET	Z
ED2E: FE20    		CP	' '		;other control char? Set carry flag.
ED30: C9      		RET	
              	;
              	;   Check the console during output. Halt on a control-s, then
              	; reboot on a control-c. If anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
ED31: 3A1CEF  	CKCONSOL: LD	A,(CHARBUF)	;check buffer.
ED34: B7      		OR	A		;if anything, just return without checking.
ED35: C253ED  		JP	NZ,CKCON2
ED38: CD14FA  		CALL	CONST		;nothing in buffer. Check console.
ED3B: E601    		AND	01H		;look at bit 0.
ED3D: C8      		RET	Z		;return if nothing.
ED3E: CD17FA  		CALL	CONIN		;ok, get it.
ED41: FE13    		CP	CNTRLS		;if not control-s, return with zero cleared.
ED43: C250ED  		JP	NZ,CKCON1
ED46: CD17FA  		CALL	CONIN		;halt processing until another char
ED49: FE03    		CP	CNTRLC		;is typed. Control-c?
ED4B: CA0000  		JP	Z,0		;yes, reboot now.
ED4E: AF      		XOR	A		;no, just pretend nothing was ever ready.
ED4F: C9      		RET
ED50: 321CEF  	CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
ED53: 3E01    	CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
ED55: C9      		RET
              	;
              	;   Output (C) to the screen. If the printer flip-flop flag
              	; is set, we will send character to printer also. The console
              	; will be checked in the process.
              	;
ED56: 3A18EF  	OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
ED59: B7      		OR	A		;anything and we won't generate output.
ED5A: C270ED  		JP	NZ,OUTCHR1
ED5D: C5      		PUSH	BC
ED5E: CD31ED  		CALL	CKCONSOL	;check console (we don't care whats there).
ED61: C1      		POP	BC
ED62: C5      		PUSH	BC
ED63: CD1AFA  		CALL	CONOUT		;output (C) to the screen.
ED66: C1      		POP	BC
ED67: C5      		PUSH	BC
ED68: 3A1BEF  		LD	A,(PRTFLAG)	;check printer flip-flop flag.
ED6B: B7      		OR	A
ED6C: C41DFA  		CALL	NZ,LIST		;print it also if non-zero.
ED6F: C1      		POP	BC
ED70: 79      	OUTCHR1:LD	A,C		;update cursors position.
ED71: 211AEF  		LD	HL,CURPOS
ED74: FE7F    		CP	DEL		;rubouts don't do anything here.
ED76: C8      		RET	Z
ED77: 34      		INC	(HL)		;bump line pointer.
ED78: FE20    		CP	' '		;and return if a normal character.
ED7A: D0      		RET	NC
ED7B: 35      		DEC	(HL)		;restore and check for the start of the line.
ED7C: 7E      		LD	A,(HL)
ED7D: B7      		OR	A
ED7E: C8      		RET	Z		;ingnore control characters at the start of the line.
ED7F: 79      		LD	A,C
ED80: FE08    		CP	BS		;is it a backspace?
ED82: C287ED  		JP	NZ,OUTCHR2
ED85: 35      		DEC	(HL)		;yes, backup pointer.
ED86: C9      		RET
ED87: FE0A    	OUTCHR2:CP	LF		;is it a line feed?
ED89: C0      		RET	NZ		;ignore anything else.
ED8A: 3600    		LD	(HL),0		;reset pointer to start of line.
ED8C: C9      		RET
              	;
              	;   Output (A) to the screen. If it is a control character
              	; (other than carriage control), use ^x format.
              	;
ED8D: 79      	SHOWIT:	LD	A,C
ED8E: CD22ED  		CALL	CHKCHAR		;check character.
ED91: D29EED  		JP	NC,OUTCON	;not a control, use normal output.
ED94: F5      		PUSH	AF
ED95: 0E5E    		LD	C,'^'		;for a control character, preceed it with '^'.
ED97: CD56ED  		CALL	OUTCHAR
ED9A: F1      		POP	AF
ED9B: F640    		OR	'@'		;and then use the letter equivelant.
ED9D: 4F      		LD	C,A
              	;
              	;   Function to output (C) to the console device and expand tabs
              	; if necessary.
              	;
ED9E: 79      	OUTCON:	LD	A,C
ED9F: FE09    		CP	TAB		;is it a tab?
EDA1: C256ED  		JP	NZ,OUTCHAR	;use regular output.
EDA4: 0E20    	OUTCON1:LD	C,' '		;yes it is, use spaces instead.
EDA6: CD56ED  		CALL	OUTCHAR
EDA9: 3A1AEF  		LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
              	
EDAC: E607    		AND	07H		;position.
EDAE: C2A4ED  		JP	NZ,OUTCON1
EDB1: C9      		RET
              	;
              	;   Echo a backspace character. Erase the prevoius character
              	; on the screen.
              	;
EDB2: CDBAED  	BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
EDB5: 0E20    		LD	C,' '		;then blank that character.
EDB7: CD1AFA  		CALL	CONOUT
EDBA: 0E08    	BACKUP1:LD	C,BS		;then back space once more.
EDBC: C31AFA  		JP	CONOUT
              	;
              	;   Signal a deleted line. Print a '#' at the end and start
              	; over.
              	;
EDBF: 0E23    	NEWLINE:LD	C,'#'
EDC1: CD56ED  		CALL	OUTCHAR		;print this.
EDC4: CDD7ED  		CALL	OUTCRLF		;start new line.
EDC7: 3A1AEF  	NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
EDCA: 2119EF  		LD	HL,STARTING
EDCD: BE      		CP	(HL)
EDCE: D0      		RET	NC		;there yet?
EDCF: 0E20    		LD	C,' '
EDD1: CD56ED  		CALL	OUTCHAR		;nope, keep going.
EDD4: C3C7ED  		JP	NEWLN1
              	;
              	;   Output a (cr) (lf) to the console device (screen).
              	;
EDD7: 0E0D    	OUTCRLF:LD	C,CR
EDD9: CD56ED  		CALL	OUTCHAR
EDDC: 0E0A    		LD	C,LF
EDDE: C356ED  		JP	OUTCHAR
              	;
              	;   Print message pointed to by (BC). It will end with a '$'.
              	;
EDE1: 0A      	PRTMESG:LD	A,(BC)		;check for terminating character.
EDE2: FE24    		CP	'$'
EDE4: C8      		RET	Z
EDE5: 03      		INC	BC
EDE6: C5      		PUSH	BC		;otherwise, bump pointer and print it.
EDE7: 4F      		LD	C,A
EDE8: CD9EED  		CALL	OUTCON
EDEB: C1      		POP	BC
EDEC: C3E1ED  		JP	PRTMESG
              	;
              	;   Function to execute a buffered read.
              	;
EDEF: 3A1AEF  	RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
EDF2: 3219EF  		LD	(STARTING),A
EDF5: 2A51EF  		LD	HL,(PARAMS)	;get the maximum buffer space.
EDF8: 4E      		LD	C,(HL)
EDF9: 23      		INC	HL		;point to first available space.
EDFA: E5      		PUSH	HL		;and save.
EDFB: 0600    		LD	B,0		;keep a character count.
EDFD: C5      	RDBUF1:	PUSH	BC
EDFE: E5      		PUSH	HL
EDFF: CD09ED  	RDBUF2:	CALL	GETCHAR		;get the next input character.
EE02: E67F    		AND	7FH		;strip bit 7.
EE04: E1      		POP	HL		;reset registers.
EE05: C1      		POP	BC
EE06: FE0D    		CP	CR		;en of the line?
EE08: CACFEE  		JP	Z,RDBUF17
EE0B: FE0A    		CP	LF
EE0D: CACFEE  		JP	Z,RDBUF17
EE10: FE08    		CP	BS		;how about a backspace?
EE12: C224EE  		JP	NZ,RDBUF3
EE15: 78      		LD	A,B		;yes, but ignore at the beginning of the line.
EE16: B7      		OR	A
EE17: CAFDED  		JP	Z,RDBUF1
EE1A: 05      		DEC	B		;ok, update counter.
EE1B: 3A1AEF  		LD	A,(CURPOS)	;if we backspace to the start of the line,
EE1E: 3218EF  		LD	(OUTFLAG),A	;treat as a cancel (control-x).
EE21: C37EEE  		JP	RDBUF10
EE24: FE7F    	RDBUF3:	CP	DEL		;user typed a rubout?
EE26: C234EE  		JP	NZ,RDBUF4
EE29: 78      		LD	A,B		;ignore at the start of the line.
EE2A: B7      		OR	A
EE2B: CAFDED  		JP	Z,RDBUF1
EE2E: 7E      		LD	A,(HL)		;ok, echo the prevoius character.
EE2F: 05      		DEC	B		;and reset pointers (counters).
EE30: 2B      		DEC	HL
EE31: C3B7EE  		JP	RDBUF15
EE34: FE05    	RDBUF4:	CP	CNTRLE		;physical end of line?
EE36: C245EE  		JP	NZ,RDBUF5
EE39: C5      		PUSH	BC		;yes, do it.
EE3A: E5      		PUSH	HL
EE3B: CDD7ED  		CALL	OUTCRLF
EE3E: AF      		XOR	A		;and update starting position.
EE3F: 3219EF  		LD	(STARTING),A
EE42: C3FFED  		JP	RDBUF2
EE45: FE10    	RDBUF5:	CP	CNTRLP		;control-p?
EE47: C256EE  		JP	NZ,RDBUF6
EE4A: E5      		PUSH	HL		;yes, flip the print flag filp-flop byte.
EE4B: 211BEF  		LD	HL,PRTFLAG
EE4E: 3E01    		LD	A,1		;PRTFLAG=1-PRTFLAG
EE50: 96      		SUB	(HL)
EE51: 77      		LD	(HL),A
EE52: E1      		POP	HL
EE53: C3FDED  		JP	RDBUF1
EE56: FE18    	RDBUF6:	CP	CNTRLX		;control-x (cancel)?
EE58: C26DEE  		JP	NZ,RDBUF8
EE5B: E1      		POP	HL
EE5C: 3A19EF  	RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
EE5F: 211AEF  		LD	HL,CURPOS
EE62: BE      		CP	(HL)
EE63: D2EFED  		JP	NC,RDBUFF	;done yet?
EE66: 35      		DEC	(HL)		;no, decrement pointer and output back up one space.
EE67: CDB2ED  		CALL	BACKUP
EE6A: C35CEE  		JP	RDBUF7
EE6D: FE15    	RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
EE6F: C279EE  		JP	NZ,RDBUF9
EE72: CDBFED  		CALL	NEWLINE		;start a new line.
EE75: E1      		POP	HL
EE76: C3EFED  		JP	RDBUFF
EE79: FE12    	RDBUF9:	CP	CNTRLR		;control-r?
EE7B: C2B4EE  		JP	NZ,RDBUF14
EE7E: C5      	RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
EE7F: CDBFED  		CALL	NEWLINE
EE82: C1      		POP	BC
EE83: E1      		POP	HL
EE84: E5      		PUSH	HL
EE85: C5      		PUSH	BC
EE86: 78      	RDBUF11:LD	A,B		;done whole line yet?
EE87: B7      		OR	A
EE88: CA98EE  		JP	Z,RDBUF12
EE8B: 23      		INC	HL		;nope, get next character.
EE8C: 4E      		LD	C,(HL)
EE8D: 05      		DEC	B		;count it.
EE8E: C5      		PUSH	BC
EE8F: E5      		PUSH	HL
EE90: CD8DED  		CALL	SHOWIT		;and display it.
EE93: E1      		POP	HL
EE94: C1      		POP	BC
EE95: C386EE  		JP	RDBUF11
EE98: E5      	RDBUF12:PUSH	HL		;done with line. If we were displaying
EE99: 3A18EF  		LD	A,(OUTFLAG)	;then update cursor position.
EE9C: B7      		OR	A
EE9D: CAFFED  		JP	Z,RDBUF2
EEA0: 211AEF  		LD	HL,CURPOS	;because this line is shorter, we must
EEA3: 96      		SUB	(HL)		;back up the cursor (not the screen however)
EEA4: 3218EF  		LD	(OUTFLAG),A	;some number of positions.
EEA7: CDB2ED  	RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
EEAA: 2118EF  		LD	HL,OUTFLAG	;zero, the screen will not be changed.
EEAD: 35      		DEC	(HL)
EEAE: C2A7EE  		JP	NZ,RDBUF13
EEB1: C3FFED  		JP	RDBUF2		;now just get the next character.
              	;
              	;   Just a normal character, put this in our buffer and echo.
              	;
EEB4: 23      	RDBUF14:INC	HL
EEB5: 77      		LD	(HL),A		;store character.
EEB6: 04      		INC	B		;and count it.
EEB7: C5      	RDBUF15:PUSH	BC
EEB8: E5      		PUSH	HL
EEB9: 4F      		LD	C,A		;echo it now.
EEBA: CD8DED  		CALL	SHOWIT
EEBD: E1      		POP	HL
EEBE: C1      		POP	BC
EEBF: 7E      		LD	A,(HL)		;was it an abort request?
EEC0: FE03    		CP	CNTRLC		;control-c abort?
EEC2: 78      		LD	A,B
EEC3: C2CBEE  		JP	NZ,RDBUF16
EEC6: FE01    		CP	1		;only if at start of line.
EEC8: CA0000  		JP	Z,0
EECB: B9      	RDBUF16:CP	C		;nope, have we filled the buffer?
EECC: DAFDED  		JP	C,RDBUF1
EECF: E1      	RDBUF17:POP	HL		;yes end the line and return.
EED0: 70      		LD	(HL),B
EED1: 0E0D    		LD	C,CR
EED3: C356ED  		JP	OUTCHAR		;output (cr) and return.
              	;
              	;   Function to get a character from the console device.
              	;
EED6: CD14ED  	GETCON:	CALL	GETECHO		;get and echo.
EED9: C30FEF  		JP	SETSTAT		;save status and return.
              	;
              	;   Function to get a character from the tape reader device.
              	;
EEDC: CD23FA  	GETRDR:	CALL	READER		;get a character from reader, set status and return.
EEDF: C30FEF  		JP	SETSTAT
              	;
              	;  Function to perform direct console i/o. If (C) contains (FF)
              	; then this is an input request. If (C) contains (FE) then
              	; this is a status request. Otherwise we are to output (C).
              	;
EEE2: 79      	DIRCIO:	LD	A,C		;test for (FF).
EEE3: 3C      		INC	A
EEE4: CAEEEE  		JP	Z,DIRC1
EEE7: 3C      		INC	A		;test for (FE).
EEE8: CA14FA  		JP	Z,CONST
EEEB: C31AFA  		JP	CONOUT		;just output (C).
EEEE: CD14FA  	DIRC1:	CALL	CONST		;this is an input request.
EEF1: B7      		OR	A
EEF2: CA9FF9  		JP	Z,GOBACK1	;not ready? Just return (directly).
EEF5: CD17FA  		CALL	CONIN		;yes, get character.
EEF8: C30FEF  		JP	SETSTAT		;set status and return.
              	;
              	;   Function to return the i/o byte.
              	;
EEFB: 3A0300  	GETIOB:	LD	A,(IOBYTE)
EEFE: C30FEF  		JP	SETSTAT
              	;
              	;   Function to set the i/o byte.
              	;
EF01: 210300  	SETIOB:	LD	HL,IOBYTE
EF04: 71      		LD	(HL),C
EF05: C9      		RET
              	;
              	;   Function to print the character string pointed to by (DE)
              	; on the console device. The string ends with a '$'.
              	;
EF06: EB      	PRTSTR:	EX	DE,HL
EF07: 4D      		LD	C,L
EF08: 44      		LD	B,H		;now (BC) points to it.
EF09: C3E1ED  		JP	PRTMESG
              	;
              	;   Function to interigate the console device.
              	;
EF0C: CD31ED  	GETCSTS:CALL	CKCONSOL
              	;
              	;   Get here to set the status and return to the cleanup
              	; section. Then back to the user.
              	;
EF0F: 3253EF  	SETSTAT:LD	(STATUS),A
EF12: C9      	RTN:	RET
              	;
              	;   Set the status to 1 (read or write error code).
              	;
EF13: 3E01    	IOERR1:	LD	A,1
EF15: C30FEF  		JP	SETSTAT
              	;
EF18: 00      	OUTFLAG:DEFB	0		;output flag (non zero means no output).
EF19: 02      	STARTING: DEFB	2		;starting position for cursor.
EF1A: 00      	CURPOS:	DEFB	0		;cursor position (0=start of line).
EF1B: 00      	PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero.
EF1C: 00      	CHARBUF:DEFB	0		;single input character buffer.
              	;
              	;   Stack area for BDOS calls.
              	;
EF1D: 0000    	USRSTACK: DEFW	0		;save users stack pointer here.
              	;
EF1F: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EF23: 00...   	
EF37: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EF3B: 00...   	
EF4F:         	STKAREA EQU	$		;end of stack area.
              	;
EF4F: 00      	USERNO:	DEFB	0		;current user number.
EF50: 00      	ACTIVE:	DEFB	0		;currently active drive.
EF51: 0000    	PARAMS:	DEFW	0		;save (DE) parameters here on entry.
EF53: 0000    	STATUS:	DEFW	0		;status returned from bdos function.
              	;
              	;   Select error occured, jump to error routine.
              	;
EF55: 2119EC  	SLCTERR:LD	HL,BADSLCT
              	;
              	;   Jump to (HL) indirectly.
              	;
EF58: 5E      	JUMPHL:	LD	E,(HL)
EF59: 23      		INC	HL
EF5A: 56      		LD	D,(HL)		;now (DE) contain the desired address.
EF5B: EB      		EX	DE,HL
EF5C: E9      		JP	(HL)
              	;
              	;   Block move. (DE) to (HL), (C) bytes total.
              	;
EF5D: 0C      	DE2HL:	INC	C		;is count down to zero?
EF5E: 0D      	DE2HL1:	DEC	C
EF5F: C8      		RET	Z		;yes, we are done.
EF60: 1A      		LD	A,(DE)		;no, move one more byte.
EF61: 77      		LD	(HL),A
EF62: 13      		INC	DE
EF63: 23      		INC	HL
EF64: C35EEF  		JP	DE2HL1		;and repeat.
              	;
              	;   Select the desired drive.
              	;
EF67: 3A50EF  	SELECT:	LD	A,(ACTIVE)	;get active disk.
EF6A: 4F      		LD	C,A
EF6B: CD29FA  		CALL	SELDSK		;select it.
EF6E: 7C      		LD	A,H		;valid drive?
EF6F: B5      		OR	L		;valid drive?
EF70: C8      		RET	Z		;return if not.
              	;
              	;   Here, the BIOS returned the address of the parameter block
              	; in (HL). We will extract the necessary pointers and save them.
              	;
EF71: 5E      		LD	E,(HL)		;yes, get address of translation table into (DE).
EF72: 23      		INC	HL
EF73: 56      		LD	D,(HL)
EF74: 23      		INC	HL
EF75: 22C1F9  		LD	(SCRATCH1),HL	;save pointers to scratch areas.
EF78: 23      		INC	HL
EF79: 23      		INC	HL
EF7A: 22C3F9  		LD	(SCRATCH2),HL	;ditto.
EF7D: 23      		INC	HL
EF7E: 23      		INC	HL
EF7F: 22C5F9  		LD	(SCRATCH3),HL	;ditto.
EF82: 23      		INC	HL
EF83: 23      		INC	HL
EF84: EB      		EX	DE,HL		;now save the translation table address.
EF85: 22DEF9  		LD	(XLATE),HL
EF88: 21C7F9  		LD	HL,DIRBUF	;put the next 8 bytes here.
EF8B: 0E08    		LD	C,8		;they consist of the directory buffer
EF8D: CD5DEF  		CALL	DE2HL		;pointer, parameter block pointer,
EF90: 2AC9F9  		LD	HL,(DISKPB)	;check and allocation vectors.
EF93: EB      		EX	DE,HL
EF94: 21CFF9  		LD	HL,SECTORS	;move parameter block into our ram.
EF97: 0E0F    		LD	C,15		;it is 15 bytes long.
EF99: CD5DEF  		CALL	DE2HL
EF9C: 2AD4F9  		LD	HL,(DSKSIZE)	;check disk size.
EF9F: 7C      		LD	A,H		;more than 256 blocks on this?
EFA0: 21EBF9  		LD	HL,BIGDISK
EFA3: 36FF    		LD	(HL),0FFH	;set to samll.
EFA5: B7      		OR	A
EFA6: CAABEF  		JP	Z,SELECT1
EFA9: 3600    		LD	(HL),0		;wrong, set to large.
EFAB: 3EFF    	SELECT1:LD	A,0FFH		;clear the zero flag.
EFAD: B7      		OR	A
EFAE: C9      		RET
              	;
              	;   Routine to home the disk track head and clear pointers.
              	;
EFAF: CD26FA  	HOMEDRV:CALL	HOME		;home the head.
EFB2: AF      		XOR	A
EFB3: 2AC3F9  		LD	HL,(SCRATCH2)	;set our track pointer also.
EFB6: 77      		LD	(HL),A
EFB7: 23      		INC	HL
EFB8: 77      		LD	(HL),A
EFB9: 2AC5F9  		LD	HL,(SCRATCH3)	;and our sector pointer.
EFBC: 77      		LD	(HL),A
EFBD: 23      		INC	HL
EFBE: 77      		LD	(HL),A
EFBF: C9      		RET
              	;
              	;   Do the actual disk read and check the error return status.
              	;
EFC0: CD35FA  	DOREAD:	CALL	READ
EFC3: C3C9EF  		JP	IORET
              	;
              	;   Do the actual disk write and handle any bios error.
              	;
EFC6: CD38FA  	DOWRITE:CALL	WRITE
EFC9: B7      	IORET:	OR	A
EFCA: C8      		RET	Z		;return unless an error occured.
EFCB: 2117EC  		LD	HL,BADSCTR	;bad read/write on this sector.
EFCE: C358EF  		JP	JUMPHL
              	;
              	;   Routine to select the track and sector that the desired
              	; block number falls in.
              	;
EFD1: 2AF8F9  	TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
EFD4: 0E02    		LD	C,2		;in directory and compute sector #.
EFD6: CDF8F0  		CALL	SHIFTR		;sector #=file-position/4.
EFD9: 22F3F9  		LD	(BLKNMBR),HL	;save this as the block number of interest.
EFDC: 22FAF9  		LD	(CKSUMTBL),HL	;what's it doing here too?
              	;
              	;   if the sector number has already been set (BLKNMBR), enter
              	; at this point.
              	;
EFDF: 21F3F9  	TRKSEC1:LD	HL,BLKNMBR
EFE2: 4E      		LD	C,(HL)		;move sector number into (BC).
EFE3: 23      		INC	HL
EFE4: 46      		LD	B,(HL)
EFE5: 2AC5F9  		LD	HL,(SCRATCH3)	;get current sector number and
EFE8: 5E      		LD	E,(HL)		;move this into (DE).
EFE9: 23      		INC	HL
EFEA: 56      		LD	D,(HL)
EFEB: 2AC3F9  		LD	HL,(SCRATCH2)	;get current track number.
EFEE: 7E      		LD	A,(HL)		;and this into (HL).
EFEF: 23      		INC	HL
EFF0: 66      		LD	H,(HL)
EFF1: 6F      		LD	L,A
EFF2: 79      	TRKSEC2:LD	A,C		;is desired sector before current one?
EFF3: 93      		SUB	E
EFF4: 78      		LD	A,B
EFF5: 9A      		SBC	A,D
EFF6: D208F0  		JP	NC,TRKSEC3
EFF9: E5      		PUSH	HL		;yes, decrement sectors by one track.
EFFA: 2ACFF9  		LD	HL,(SECTORS)	;get sectors per track.
EFFD: 7B      		LD	A,E
EFFE: 95      		SUB	L
EFFF: 5F      		LD	E,A
F000: 7A      		LD	A,D
F001: 9C      		SBC	A,H
F002: 57      		LD	D,A		;now we have backed up one full track.
F003: E1      		POP	HL
F004: 2B      		DEC	HL		;adjust track counter.
F005: C3F2EF  		JP	TRKSEC2
F008: E5      	TRKSEC3:PUSH	HL		;desired sector is after current one.
F009: 2ACFF9  		LD	HL,(SECTORS)	;get sectors per track.
F00C: 19      		ADD	HL,DE		;bump sector pointer to next track.
F00D: DA1DF0  		JP	C,TRKSEC4
F010: 79      		LD	A,C		;is desired sector now before current one?
F011: 95      		SUB	L
F012: 78      		LD	A,B
F013: 9C      		SBC	A,H
F014: DA1DF0  		JP	C,TRKSEC4
F017: EB      		EX	DE,HL		;not yes, increment track counter
F018: E1      		POP	HL		;and continue until it is.
F019: 23      		INC	HL
F01A: C308F0  		JP	TRKSEC3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
F01D: E1      	TRKSEC4:POP	HL		;get track number (HL).
F01E: C5      		PUSH	BC
F01F: D5      		PUSH	DE
F020: E5      		PUSH	HL
F021: EB      		EX	DE,HL
F022: 2ADCF9  		LD	HL,(OFFSET)	;adjust for first track offset.
F025: 19      		ADD	HL,DE
F026: 44      		LD	B,H
F027: 4D      		LD	C,L
F028: CD2CFA  		CALL	SETTRK		;select this track.
F02B: D1      		POP	DE		;reset current track pointer.
F02C: 2AC3F9  		LD	HL,(SCRATCH2)
F02F: 73      		LD	(HL),E
F030: 23      		INC	HL
F031: 72      		LD	(HL),D
F032: D1      		POP	DE
F033: 2AC5F9  		LD	HL,(SCRATCH3)	;reset the first sector on this track.
F036: 73      		LD	(HL),E
F037: 23      		INC	HL
F038: 72      		LD	(HL),D
F039: C1      		POP	BC
F03A: 79      		LD	A,C		;now subtract the desired one.
F03B: 93      		SUB	E		;to make it relative (1-# sectors/track).
F03C: 4F      		LD	C,A
F03D: 78      		LD	A,B
F03E: 9A      		SBC	A,D
F03F: 47      		LD	B,A
F040: 2ADEF9  		LD	HL,(XLATE)	;translate this sector according to this table.
F043: EB      		EX	DE,HL
F044: CD3EFA  		CALL	SECTRN		;let the bios translate it.
F047: 4D      		LD	C,L
F048: 44      		LD	B,H
F049: C32FFA  		JP	SETSEC		;and select it.
              	;
              	;   Compute block number from record number (SAVNREC) and
              	; extent number (SAVEXT).
              	;
F04C: 21D1F9  	GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
F04F: 4E      		LD	C,(HL)		;note that this is base 2 log of ratio.
F050: 3AF1F9  		LD	A,(SAVNREC)	;get record number.
F053: B7      	GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
F054: 1F      		RRA
F055: 0D      		DEC	C
F056: C253F0  		JP	NZ,GETBLK1
F059: 47      		LD	B,A		;save result in (B).
F05A: 3E08    		LD	A,8
F05C: 96      		SUB	(HL)
F05D: 4F      		LD	C,A		;compute (C)=8-BLKSHFT.
F05E: 3AF0F9  		LD	A,(SAVEXT)
F061: 0D      	GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
F062: CA6AF0  		JP	Z,GETBLK3
F065: B7      		OR	A
F066: 17      		RLA
F067: C361F0  		JP	GETBLK2
F06A: 80      	GETBLK3:ADD	A,B
F06B: C9      		RET
              	;
              	;   Routine to extract the (BC) block byte from the fcb pointed
              	; to by (PARAMS). If this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; Number is returned in (HL).
              	;
F06C: 2A51EF  	EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
F06F: 111000  		LD	DE,16		;block numbers start 16 bytes into fcb.
F072: 19      		ADD	HL,DE
F073: 09      		ADD	HL,BC
F074: 3AEBF9  		LD	A,(BIGDISK)	;are we using a big-disk?
F077: B7      		OR	A
F078: CA7FF0  		JP	Z,EXTBLK1
F07B: 6E      		LD	L,(HL)		;no, extract an 8 bit number from the fcb.
F07C: 2600    		LD	H,0
F07E: C9      		RET
F07F: 09      	EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
F080: 5E      		LD	E,(HL)
F081: 23      		INC	HL
F082: 56      		LD	D,(HL)
F083: EB      		EX	DE,HL		;return in (HL).
F084: C9      		RET
              	;
              	;   Compute block number.
              	;
F085: CD4CF0  	COMBLK:	CALL	GETBLOCK
F088: 4F      		LD	C,A
F089: 0600    		LD	B,0
F08B: CD6CF0  		CALL	EXTBLK
F08E: 22F3F9  		LD	(BLKNMBR),HL
F091: C9      		RET
              	;
              	;   Check for a zero block number (unused).
              	;
F092: 2AF3F9  	CHKBLK:	LD	HL,(BLKNMBR)
F095: 7D      		LD	A,L		;is it zero?
F096: B4      		OR	H
F097: C9      		RET
              	;
              	;   Adjust physical block (BLKNMBR) and convert to logical
              	; sector (LOGSECT). This is the starting sector of this block.
              	; The actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (BLKNMBR). This
              	; will still have to be adjusted for the track number.
              	;
F098: 3AD1F9  	LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
F09B: 2AF3F9  		LD	HL,(BLKNMBR)	;get physical sector desired.
F09E: 29      	LOGICL1:ADD	HL,HL		;compute logical sector number.
F09F: 3D      		DEC	A		;note logical sectors are 128 bytes long.
F0A0: C29EF0  		JP	NZ,LOGICL1
F0A3: 22F5F9  		LD	(LOGSECT),HL	;save logical sector.
F0A6: 3AD2F9  		LD	A,(BLKMASK)	;get block mask.
F0A9: 4F      		LD	C,A
F0AA: 3AF1F9  		LD	A,(SAVNREC)	;get next sector to access.
F0AD: A1      		AND	C		;extract the relative position within physical block.
F0AE: B5      		OR	L		;and add it too logical sector.
F0AF: 6F      		LD	L,A
F0B0: 22F3F9  		LD	(BLKNMBR),HL	;and store.
F0B3: C9      		RET
              	;
              	;   Set (HL) to point to extent byte in fcb.
              	;
F0B4: 2A51EF  	SETEXT:	LD	HL,(PARAMS)
F0B7: 110C00  		LD	DE,12		;it is the twelth byte.
F0BA: 19      		ADD	HL,DE
F0BB: C9      		RET
              	;
              	;   Set (HL) to point to record count byte in fcb and (DE) to
              	; next record number byte.
              	;
F0BC: 2A51EF  	SETHLDE:LD	HL,(PARAMS)
F0BF: 110F00  		LD	DE,15		;record count byte (#15).
F0C2: 19      		ADD	HL,DE
F0C3: EB      		EX	DE,HL
F0C4: 211100  		LD	HL,17		;next record number (#32).
F0C7: 19      		ADD	HL,DE
F0C8: C9      		RET
              	;
              	;   Save current file data from fcb.
              	;
F0C9: CDBCF0  	STRDATA:CALL	SETHLDE
F0CC: 7E      		LD	A,(HL)		;get and store record count byte.
F0CD: 32F1F9  		LD	(SAVNREC),A
F0D0: EB      		EX	DE,HL
F0D1: 7E      		LD	A,(HL)		;get and store next record number byte.
F0D2: 32EFF9  		LD	(SAVNXT),A
F0D5: CDB4F0  		CALL	SETEXT		;point to extent byte.
F0D8: 3AD3F9  		LD	A,(EXTMASK)	;get extent mask.
F0DB: A6      		AND	(HL)
F0DC: 32F0F9  		LD	(SAVEXT),A	;and save extent here.
F0DF: C9      		RET
              	;
              	;   Set the next record to access. If (MODE) is set to 2, then
              	; the last record byte (SAVNREC) has the correct number to access.
              	; For sequential access, (MODE) will be equal to 1.
              	;
F0E0: CDBCF0  	SETNREC:CALL	SETHLDE
F0E3: 3AE3F9  		LD	A,(MODE)	;get sequential flag (=1).
F0E6: FE02    		CP	2		;a 2 indicates that no adder is needed.
F0E8: C2ECF0  		JP	NZ,STNREC1
F0EB: AF      		XOR	A		;clear adder (random access?).
F0EC: 4F      	STNREC1:LD	C,A
F0ED: 3AF1F9  		LD	A,(SAVNREC)	;get last record number.
F0F0: 81      		ADD	A,C		;increment record count.
F0F1: 77      		LD	(HL),A		;and set fcb's next record byte.
F0F2: EB      		EX	DE,HL
F0F3: 3AEFF9  		LD	A,(SAVNXT)	;get next record byte from storage.
F0F6: 77      		LD	(HL),A		;and put this into fcb as number of records used.
F0F7: C9      		RET
              	;
              	;   Shift (HL) right (C) bits.
              	;
F0F8: 0C      	SHIFTR:	INC	C
F0F9: 0D      	SHIFTR1:DEC	C
F0FA: C8      		RET	Z
F0FB: 7C      		LD	A,H
F0FC: B7      		OR	A
F0FD: 1F      		RRA
F0FE: 67      		LD	H,A
F0FF: 7D      		LD	A,L
F100: 1F      		RRA
F101: 6F      		LD	L,A
F102: C3F9F0  		JP	SHIFTR1
              	;
              	;   Compute the check-sum for the directory buffer. Return
              	; integer sum in (A).
              	;
F105: 0E80    	CHECKSUM: LD	C,128		;length of buffer.
F107: 2AC7F9  		LD	HL,(DIRBUF)	;get its location.
F10A: AF      		XOR	A		;clear summation byte.
F10B: 86      	CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries.
F10C: 23      		INC	HL
F10D: 0D      		DEC	C
F10E: C20BF1  		JP	NZ,CHKSUM1
F111: C9      		RET
              	;
              	;   Shift (HL) left (C) bits.
              	;
F112: 0C      	SHIFTL:	INC	C
F113: 0D      	SHIFTL1:DEC	C
F114: C8      		RET	Z
F115: 29      		ADD	HL,HL		;shift left 1 bit.
F116: C313F1  		JP	SHIFTL1
              	;
              	;   Routine to set a bit in a 16 bit value contained in (BC).
              	; The bit set depends on the current drive selection.
              	;
F119: C5      	SETBIT:	PUSH	BC		;save 16 bit word.
F11A: 3A50EF  		LD	A,(ACTIVE)	;get active drive.
F11D: 4F      		LD	C,A
F11E: 210100  		LD	HL,1
F121: CD12F1  		CALL	SHIFTL		;shift bit 0 into place.
F124: C1      		POP	BC		;now 'or' this with the original word.
F125: 79      		LD	A,C
F126: B5      		OR	L
F127: 6F      		LD	L,A		;low byte done, do high byte.
F128: 78      		LD	A,B
F129: B4      		OR	H
F12A: 67      		LD	H,A
F12B: C9      		RET
              	;
              	;   Extract the write protect status bit for the current drive.
              	; The result is returned in (A), bit 0.
              	;
F12C: 2ABBF9  	GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
F12F: 3A50EF  		LD	A,(ACTIVE)	;which drive is current?
F132: 4F      		LD	C,A
F133: CDF8F0  		CALL	SHIFTR		;shift status such that bit 0 is the
F136: 7D      		LD	A,L		;one of interest for this drive.
F137: E601    		AND	01H		;and isolate it.
F139: C9      		RET
              	;
              	;   Function to write protect the current disk.
              	;
F13A: 21BBF9  	WRTPRTD:LD	HL,WRTPRT	;point to status word.
F13D: 4E      		LD	C,(HL)		;set (BC) equal to the status.
F13E: 23      		INC	HL
F13F: 46      		LD	B,(HL)
F140: CD19F1  		CALL	SETBIT		;and set this bit according to current drive.
F143: 22BBF9  		LD	(WRTPRT),HL	;then save.
F146: 2AD6F9  		LD	HL,(DIRSIZE)	;now save directory size limit.
F149: 23      		INC	HL		;remember the last one.
F14A: EB      		EX	DE,HL
F14B: 2AC1F9  		LD	HL,(SCRATCH1)	;and store it here.
F14E: 73      		LD	(HL),E		;put low byte.
F14F: 23      		INC	HL
F150: 72      		LD	(HL),D		;then high byte.
F151: C9      		RET
              	;
              	;   Check for a read only file.
              	;
F152: CD6CF1  	CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
F155: 110900  	CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
F158: 19      		ADD	HL,DE
F159: 7E      		LD	A,(HL)
F15A: 17      		RLA
F15B: D0      		RET	NC		;return if ok.
F15C: 211DEC  		LD	HL,ROFILE	;else, print error message and terminate.
F15F: C358EF  		JP	JUMPHL
              	;
              	;   Check the write protect status of the active disk.
              	;
F162: CD2CF1  	CHKWPRT:CALL	GETWPRT
F165: C8      		RET	Z		;return if ok.
F166: 211BEC  		LD	HL,RODISK	;else print message and terminate.
F169: C358EF  		JP	JUMPHL
              	;
              	;   Routine to set (HL) pointing to the proper entry in the
              	; directory buffer.
              	;
F16C: 2AC7F9  	FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
F16F: 3AF7F9  		LD	A,(FCBPOS)	;relative position of file.
              	;
              	;   Routine to add (A) to (HL).
              	;
F172: 85      	ADDA2HL:ADD	A,L
F173: 6F      		LD	L,A
F174: D0      		RET	NC
F175: 24      		INC	H		;take care of any carry.
F176: C9      		RET
              	;
              	;   Routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
F177: 2A51EF  	GETS2:	LD	HL,(PARAMS)	;get address of fcb.
F17A: 110E00  		LD	DE,14		;relative position of 's2'.
F17D: 19      		ADD	HL,DE
F17E: 7E      		LD	A,(HL)		;extract this byte.
F17F: C9      		RET
              	;
              	;   Clear the 's2' byte in the fcb.
              	;
F180: CD77F1  	CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
F183: 3600    		LD	(HL),0		;now clear it.
F185: C9      		RET
              	;
              	;   Set bit 7 in the 's2' byte of the fcb.
              	;
F186: CD77F1  	SETS2B7:CALL	GETS2		;get the byte.
F189: F680    		OR	80H		;and set bit 7.
F18B: 77      		LD	(HL),A		;then store.
F18C: C9      		RET
              	;
              	;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
              	; the difference. This checks to see if there are more file
              	; names in the directory. We are at (FILEPOS) and there are
              	; (SCRATCH1) of them to check.
              	;
F18D: 2AF8F9  	MOREFLS:LD	HL,(FILEPOS)	;we are here.
F190: EB      		EX	DE,HL
F191: 2AC1F9  		LD	HL,(SCRATCH1)	;and don't go past here.
F194: 7B      		LD	A,E		;compute difference but don't keep.
F195: 96      		SUB	(HL)
F196: 23      		INC	HL
F197: 7A      		LD	A,D
F198: 9E      		SBC	A,(HL)		;set carry if no more names.
F199: C9      		RET
              	;
              	;   Call this routine to prevent (SCRATCH1) from being greater
              	; than (FILEPOS).
              	;
F19A: CD8DF1  	CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
F19D: D8      		RET	C
F19E: 13      		INC	DE		;yes, reset it to (FILEPOS).
F19F: 72      		LD	(HL),D
F1A0: 2B      		DEC	HL
F1A1: 73      		LD	(HL),E
F1A2: C9      		RET
              	;
              	;   Compute (HL)=(DE)-(HL)
              	;
F1A3: 7B      	SUBHL:	LD	A,E		;compute difference.
F1A4: 95      		SUB	L
F1A5: 6F      		LD	L,A		;store low byte.
F1A6: 7A      		LD	A,D
F1A7: 9C      		SBC	A,H
F1A8: 67      		LD	H,A		;and then high byte.
F1A9: C9      		RET
              	;
              	;   Set the directory checksum byte.
              	;
F1AA: 0EFF    	SETDIR:	LD	C,0FFH
              	;
              	;   Routine to set or compare the directory checksum byte. If
              	; (C)=0ffh, then this will set the checksum byte. Else the byte
              	; will be checked. If the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
F1AC: 2AFAF9  	CHECKDIR: LD	HL,(CKSUMTBL)
F1AF: EB      		EX	DE,HL
F1B0: 2ADAF9  		LD	HL,(ALLOC1)
F1B3: CDA3F1  		CALL	SUBHL
F1B6: D0      		RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
F1B7: C5      		PUSH	BC
F1B8: CD05F1  		CALL	CHECKSUM	;else compute checksum.
F1BB: 2ACBF9  		LD	HL,(CHKVECT)	;get address of checksum table.
F1BE: EB      		EX	DE,HL
F1BF: 2AFAF9  		LD	HL,(CKSUMTBL)
F1C2: 19      		ADD	HL,DE		;set (HL) to point to byte for this drive.
F1C3: C1      		POP	BC
F1C4: 0C      		INC	C		;set or check ?
F1C5: CAD2F1  		JP	Z,CHKDIR1
F1C8: BE      		CP	(HL)		;check them.
F1C9: C8      		RET	Z		;return if they are the same.
F1CA: CD8DF1  		CALL	MOREFLS		;not the same, do we care?
F1CD: D0      		RET	NC
F1CE: CD3AF1  		CALL	WRTPRTD		;yes, mark this as write protected.
F1D1: C9      		RET
F1D2: 77      	CHKDIR1:LD	(HL),A		;just set the byte.
F1D3: C9      		RET
              	;
              	;   Do a write to the directory of the current disk.
              	;
F1D4: CDAAF1  	DIRWRITE: CALL	SETDIR		;set checksum byte.
F1D7: CDEEF1  		CALL	DIRDMA		;set directory dma address.
F1DA: 0E01    		LD	C,1		;tell the bios to actually write.
F1DC: CDC6EF  		CALL	DOWRITE		;then do the write.
F1DF: C3E8F1  		JP	DEFDMA
              	;
              	;   Read from the directory.
              	;
F1E2: CDEEF1  	DIRREAD:CALL	DIRDMA		;set the directory dma address.
F1E5: CDC0EF  		CALL	DOREAD		;and read it.
              	;
              	;   Routine to set the dma address to the users choice.
              	;
F1E8: 21BFF9  	DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
F1EB: C3F1F1  		JP	DIRDMA1
              	;
              	;   Routine to set the dma address for directory work.
              	;
F1EE: 21C7F9  	DIRDMA:	LD	HL,DIRBUF
              	;
              	;   Set the dma address. On entry, (HL) points to
              	; word containing the desired dma address.
              	;
F1F1: 4E      	DIRDMA1:LD	C,(HL)
F1F2: 23      		INC	HL
F1F3: 46      		LD	B,(HL)		;setup (BC) and go to the bios to set it.
F1F4: C332FA  		JP	SETDMA
              	;
              	;   Move the directory buffer into user's dma space.
              	;
F1F7: 2AC7F9  	MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
F1FA: EB      		EX	DE,HL
F1FB: 2ABFF9  		LD	HL,(USERDMA)	; put it here.
F1FE: 0E80    		LD	C,128		;this is its length.
F200: C35DEF  		JP	DE2HL		;move it now and return.
              	;
              	;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
              	;
F203: 21F8F9  	CKFILPOS: LD	HL,FILEPOS
F206: 7E      		LD	A,(HL)
F207: 23      		INC	HL
F208: BE      		CP	(HL)		;are both bytes the same?
F209: C0      		RET	NZ
F20A: 3C      		INC	A		;yes, but are they each 0ffh?
F20B: C9      		RET
              	;
              	;   Set location (FILEPOS) to 0ffffh.
              	;
F20C: 21FFFF  	STFILPOS: LD	HL,0FFFFH
F20F: 22F8F9  		LD	(FILEPOS),HL
F212: C9      		RET
              	;
              	;   Move on to the next file position within the current
              	; directory buffer. If no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. Enter with (C)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
F213: 2AD6F9  	NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
F216: EB      		EX	DE,HL
F217: 2AF8F9  		LD	HL,(FILEPOS)	;get current count.
F21A: 23      		INC	HL		;go on to the next one.
F21B: 22F8F9  		LD	(FILEPOS),HL
F21E: CDA3F1  		CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
F221: D227F2  		JP	NC,NXENT1	;is there more room left?
F224: C30CF2  		JP	STFILPOS	;no. Set this flag and return.
F227: 3AF8F9  	NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
F22A: E603    		AND	03H		;only look within this sector (only 4 entries fit).
F22C: 0605    		LD	B,5		;convert to relative position (32 bytes each).
F22E: 87      	NXENT2:	ADD	A,A		;note that this is not efficient code.
F22F: 05      		DEC	B		;5 'ADD A's would be better.
F230: C22EF2  		JP	NZ,NXENT2
F233: 32F7F9  		LD	(FCBPOS),A	;save it as position of fcb.
F236: B7      		OR	A
F237: C0      		RET	NZ		;return if we are within buffer.
F238: C5      		PUSH	BC
F239: CDD1EF  		CALL	TRKSEC		;we need the next directory sector.
F23C: CDE2F1  		CALL	DIRREAD
F23F: C1      		POP	BC
F240: C3ACF1  		JP	CHECKDIR
              	;
              	;   Routine to to get a bit from the disk space allocation
              	; map. It is returned in (A), bit position 0. On entry to here,
              	; set (BC) to the block number on the disk to check.
              	; On return, (D) will contain the original bit position for
              	; this block number and (HL) will point to the address for it.
              	;
F243: 79      	CKBITMAP: LD	A,C		;determine bit number of interest.
F244: E607    		AND	07H		;compute (D)=(E)=(C and 7)+1.
F246: 3C      		INC	A
F247: 5F      		LD	E,A		;save particular bit number.
F248: 57      		LD	D,A
              	;
              	;   compute (BC)=(BC)/8.
              	;
F249: 79      		LD	A,C
F24A: 0F      		RRCA			;now shift right 3 bits.
F24B: 0F      		RRCA
F24C: 0F      		RRCA
F24D: E61F    		AND	1FH		;and clear bits 7,6,5.
F24F: 4F      		LD	C,A
F250: 78      		LD	A,B
F251: 87      		ADD	A,A		;now shift (B) into bits 7,6,5.
F252: 87      		ADD	A,A
F253: 87      		ADD	A,A
F254: 87      		ADD	A,A
F255: 87      		ADD	A,A
F256: B1      		OR	C		;and add in (C).
F257: 4F      		LD	C,A		;ok, (C) ha been completed.
F258: 78      		LD	A,B		;is there a better way of doing this?
F259: 0F      		RRCA
F25A: 0F      		RRCA
F25B: 0F      		RRCA
F25C: E61F    		AND	1FH
F25E: 47      		LD	B,A		;and now (B) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
F25F: 2ACDF9  		LD	HL,(ALOCVECT)
F262: 09      		ADD	HL,BC
F263: 7E      		LD	A,(HL)		;now get correct byte.
F264: 07      	CKBMAP1:RLCA			;get correct bit into position 0.
F265: 1D      		DEC	E
F266: C264F2  		JP	NZ,CKBMAP1
F269: C9      		RET
              	;
              	;   Set or clear the bit map such that block number (BC) will be marked
              	; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
F26A: D5      	STBITMAP: PUSH	DE
F26B: CD43F2  		CALL	CKBITMAP	;get the byte of interest.
F26E: E6FE    		AND	0FEH		;clear the affected bit.
F270: C1      		POP	BC
F271: B1      		OR	C		;and now set it acording to (C).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (A) contains the value, (D) contains the bit
              	; position (1-8), and (HL) points to the address within the
              	; space allocation table for this byte.
              	;
F272: 0F      	STBMAP1:RRCA			;restore original bit position.
F273: 15      		DEC	D
F274: C272F2  		JP	NZ,STBMAP1
F277: 77      		LD	(HL),A		;and stor byte in table.
F278: C9      		RET
              	;
              	;   Set/clear space used bits in allocation map for this file.
              	; On entry, (C)=1 to set the map and (C)=0 to clear it.
              	;
F279: CD6CF1  	SETFILE:CALL	FCB2HL		;get address of fcb
F27C: 111000  		LD	DE,16
F27F: 19      		ADD	HL,DE		;get to block number bytes.
F280: C5      		PUSH	BC
F281: 0E11    		LD	C,17		;check all 17 bytes (max) of table.
F283: D1      	SETFL1:	POP	DE
F284: 0D      		DEC	C		;done all bytes yet?
F285: C8      		RET	Z
F286: D5      		PUSH	DE
F287: 3AEBF9  		LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
F28A: B7      		OR	A
F28B: CA96F2  		JP	Z,SETFL2
F28E: C5      		PUSH	BC		;only 8 bit numbers. set (BC) to this one.
F28F: E5      		PUSH	HL
F290: 4E      		LD	C,(HL)		;get low byte from table, always
F291: 0600    		LD	B,0		;set high byte to zero.
F293: C39CF2  		JP	SETFL3
F296: 0D      	SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
F297: C5      		PUSH	BC
F298: 4E      		LD	C,(HL)		;now get both the low and high bytes.
F299: 23      		INC	HL
F29A: 46      		LD	B,(HL)
F29B: E5      		PUSH	HL
F29C: 79      	SETFL3:	LD	A,C		;block used?
F29D: B0      		OR	B
F29E: CAABF2  		JP	Z,SETFL4
F2A1: 2AD4F9  		LD	HL,(DSKSIZE)	;is this block number within the
F2A4: 7D      		LD	A,L		;space on the disk?
F2A5: 91      		SUB	C
F2A6: 7C      		LD	A,H
F2A7: 98      		SBC	A,B
F2A8: D46AF2  		CALL	NC,STBITMAP	;yes, set the proper bit.
F2AB: E1      	SETFL4:	POP	HL		;point to next block number in fcb.
F2AC: 23      		INC	HL
F2AD: C1      		POP	BC
F2AE: C383F2  		JP	SETFL1
              	;
              	;   Construct the space used allocation bit map for the active
              	; drive. If a file name starts with '$' and it is under the
              	; current user number, then (STATUS) is set to minus 1. Otherwise
              	; it is not set at all.
              	;
F2B1: 2AD4F9  	BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
F2B4: 0E03    		LD	C,3
F2B6: CDF8F0  		CALL	SHIFTR		;(HL)=(HL)/8.
F2B9: 23      		INC	HL		;at lease 1 byte.
F2BA: 44      		LD	B,H
F2BB: 4D      		LD	C,L		;set (BC) to the allocation table length.
              	;
              	;   Initialize the bitmap for this drive. Right now, the first
              	; two bytes are specified by the disk parameter block. However
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. For example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
F2BC: 2ACDF9  		LD	HL,(ALOCVECT)	;now zero out the table now.
F2BF: 3600    	BITMAP1:LD	(HL),0
F2C1: 23      		INC	HL
F2C2: 0B      		DEC	BC
F2C3: 78      		LD	A,B
F2C4: B1      		OR	C
F2C5: C2BFF2  		JP	NZ,BITMAP1
F2C8: 2AD8F9  		LD	HL,(ALLOC0)	;get initial space used by directory.
F2CB: EB      		EX	DE,HL
F2CC: 2ACDF9  		LD	HL,(ALOCVECT)	;and put this into map.
F2CF: 73      		LD	(HL),E
F2D0: 23      		INC	HL
F2D1: 72      		LD	(HL),D
              	;
              	;   End of initialization portion.
              	;
F2D2: CDAFEF  		CALL	HOMEDRV		;now home the drive.
F2D5: 2AC1F9  		LD	HL,(SCRATCH1)
F2D8: 3603    		LD	(HL),3		;force next directory request to read
F2DA: 23      		INC	HL		;in a sector.
F2DB: 3600    		LD	(HL),0
F2DD: CD0CF2  		CALL	STFILPOS	;clear initial file position also.
F2E0: 0EFF    	BITMAP2:LD	C,0FFH		;read next file name in directory
F2E2: CD13F2  		CALL	NXENTRY		;and set checksum byte.
F2E5: CD03F2  		CALL	CKFILPOS	;is there another file?
F2E8: C8      		RET	Z
F2E9: CD6CF1  		CALL	FCB2HL		;yes, get its address.
F2EC: 3EE5    		LD	A,0E5H
F2EE: BE      		CP	(HL)		;empty file entry?
F2EF: CAE0F2  		JP	Z,BITMAP2
F2F2: 3A4FEF  		LD	A,(USERNO)	;no, correct user number?
F2F5: BE      		CP	(HL)
F2F6: C204F3  		JP	NZ,BITMAP3
F2F9: 23      		INC	HL
F2FA: 7E      		LD	A,(HL)		;yes, does name start with a '$'?
F2FB: D624    		SUB	'$'
F2FD: C204F3  		JP	NZ,BITMAP3
F300: 3D      		DEC	A		;yes, set atatus to minus one.
F301: 3253EF  		LD	(STATUS),A
F304: 0E01    	BITMAP3:LD	C,1		;now set this file's space as used in bit map.
F306: CD79F2  		CALL	SETFILE
F309: CD9AF1  		CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
F30C: C3E0F2  		JP	BITMAP2
              	;
              	;   Set the status (STATUS) and return.
              	;
F30F: 3AE2F9  	STSTATUS: LD	A,(FNDSTAT)
F312: C30FEF  		JP	SETSTAT
              	;
              	;   Check extents in (A) and (C). Set the zero flag if they
              	; are the same. The number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (EXTMASK+1).
              	; No registers are modified.
              	;
F315: C5      	SAMEXT:	PUSH	BC
F316: F5      		PUSH	AF
F317: 3AD3F9  		LD	A,(EXTMASK)	;get extent mask and use it to
F31A: 2F      		CPL			;to compare both extent numbers.
F31B: 47      		LD	B,A		;save resulting mask here.
F31C: 79      		LD	A,C		;mask first extent and save in (C).
F31D: A0      		AND	B
F31E: 4F      		LD	C,A
F31F: F1      		POP	AF		;now mask second extent and compare
F320: A0      		AND	B		;with the first one.
F321: 91      		SUB	C
F322: E61F    		AND	1FH		;(* only check buts 0-4 *)
F324: C1      		POP	BC		;the zero flag is set if they are the same.
F325: C9      		RET			;restore (BC) and return.
              	;
              	;   Search for the first occurence of a file name. On entry,
              	; register (C) should contain the number of bytes of the fcb
              	; that must match.
              	;
F326: 3EFF    	FINDFST:LD	A,0FFH
F328: 32E2F9  		LD	(FNDSTAT),A
F32B: 21E6F9  		LD	HL,COUNTER	;save character count.
F32E: 71      		LD	(HL),C
F32F: 2A51EF  		LD	HL,(PARAMS)	;get filename to match.
F332: 22E7F9  		LD	(SAVEFCB),HL	;and save.
F335: CD0CF2  		CALL	STFILPOS	;clear initial file position (set to 0ffffh).
F338: CDAFEF  		CALL	HOMEDRV		;home the drive.
              	;
              	;   Entry to locate the next occurence of a filename within the
              	; directory. The disk is not expected to have been changed. If
              	; it was, then it will be write protected.
              	;
F33B: 0E00    	FINDNXT:LD	C,0		;write protect the disk if changed.
F33D: CD13F2  		CALL	NXENTRY		;get next filename entry in directory.
F340: CD03F2  		CALL	CKFILPOS	;is file position = 0ffffh?
F343: CAA2F3  		JP	Z,FNDNXT6	;yes, exit now then.
F346: 2AE7F9  		LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
F349: EB      		EX	DE,HL
F34A: 1A      		LD	A,(DE)
F34B: FEE5    		CP	0E5H		;empty directory entry?
F34D: CA58F3  		JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
F350: D5      		PUSH	DE
F351: CD8DF1  		CALL	MOREFLS		;more files in directory?
F354: D1      		POP	DE
F355: D2A2F3  		JP	NC,FNDNXT6	;no more. Exit now.
F358: CD6CF1  	FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
F35B: 3AE6F9  		LD	A,(COUNTER)	;get number of bytes (characters) to check.
F35E: 4F      		LD	C,A
F35F: 0600    		LD	B,0		;initialize byte position counter.
F361: 79      	FNDNXT2:LD	A,C		;are we done with the compare?
F362: B7      		OR	A
F363: CA91F3  		JP	Z,FNDNXT5
F366: 1A      		LD	A,(DE)		;no, check next byte.
F367: FE3F    		CP	'?'		;don't care about this character?
F369: CA8AF3  		JP	Z,FNDNXT4
F36C: 78      		LD	A,B		;get bytes position in fcb.
F36D: FE0D    		CP	13		;don't care about the thirteenth byte either.
F36F: CA8AF3  		JP	Z,FNDNXT4
F372: FE0C    		CP	12		;extent byte?
F374: 1A      		LD	A,(DE)
F375: CA81F3  		JP	Z,FNDNXT3
F378: 96      		SUB	(HL)		;otherwise compare characters.
F379: E67F    		AND	7FH
F37B: C23BF3  		JP	NZ,FINDNXT	;not the same, check next entry.
F37E: C38AF3  		JP	FNDNXT4		;so far so good, keep checking.
F381: C5      	FNDNXT3:PUSH	BC		;check the extent byte here.
F382: 4E      		LD	C,(HL)
F383: CD15F3  		CALL	SAMEXT
F386: C1      		POP	BC
F387: C23BF3  		JP	NZ,FINDNXT	;not the same, look some more.
              	;
              	;   So far the names compare. Bump pointers to the next byte
              	; and continue until all (C) characters have been checked.
              	;
F38A: 13      	FNDNXT4:INC	DE		;bump pointers.
F38B: 23      		INC	HL
F38C: 04      		INC	B
F38D: 0D      		DEC	C		;adjust character counter.
F38E: C361F3  		JP	FNDNXT2
F391: 3AF8F9  	FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
F394: E603    		AND	03H
F396: 3253EF  		LD	(STATUS),A
F399: 21E2F9  		LD	HL,FNDSTAT
F39C: 7E      		LD	A,(HL)
F39D: 17      		RLA
F39E: D0      		RET	NC
F39F: AF      		XOR	A
F3A0: 77      		LD	(HL),A
F3A1: C9      		RET
              	;
              	;   Filename was not found. Set appropriate status.
              	;
F3A2: CD0CF2  	FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
F3A5: 3EFF    		LD	A,0FFH		;say not located.
F3A7: C30FEF  		JP	SETSTAT
              	;
              	;   Erase files from the directory. Only the first byte of the
              	; fcb will be affected. It is set to (E5).
              	;
F3AA: CD62F1  	ERAFILE:CALL	CHKWPRT		;is disk write protected?
F3AD: 0E0C    		LD	C,12		;only compare file names.
F3AF: CD26F3  		CALL	FINDFST		;get first file name.
F3B2: CD03F2  	ERAFIL1:CALL	CKFILPOS	;any found?
F3B5: C8      		RET	Z		;nope, we must be done.
F3B6: CD52F1  		CALL	CHKROFL		;is file read only?
F3B9: CD6CF1  		CALL	FCB2HL		;nope, get address of fcb and
F3BC: 36E5    		LD	(HL),0E5H	;set first byte to 'empty'.
F3BE: 0E00    		LD	C,0		;clear the space from the bit map.
F3C0: CD79F2  		CALL	SETFILE
F3C3: CDD4F1  		CALL	DIRWRITE	;now write the directory sector back out.
F3C6: CD3BF3  		CALL	FINDNXT		;find the next file name.
F3C9: C3B2F3  		JP	ERAFIL1		;and repeat process.
              	;
              	;   Look through the space allocation map (bit map) for the
              	; next available block. Start searching at block number (BC-1).
              	; The search procedure is to look for an empty block that is
              	; before the starting block. If not empty, look at a later
              	; block number. In this way, we return the closest empty block
              	; on either side of the 'target' block number. This will speed
              	; access on random devices. For serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   On return, (DE)= block number that is empty and (HL) =0
              	; if no empry block was found.
              	;
F3CC: 50      	FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
F3CD: 59      		LD	E,C
              	;
              	;   Look before target block. Registers (BC) are used as the lower
              	; pointer and (DE) as the upper pointer.
              	;
F3CE: 79      	FNDSPA1:LD	A,C		;is block 0 specified?
F3CF: B0      		OR	B
F3D0: CADFF3  		JP	Z,FNDSPA2
F3D3: 0B      		DEC	BC		;nope, check previous block.
F3D4: D5      		PUSH	DE
F3D5: C5      		PUSH	BC
F3D6: CD43F2  		CALL	CKBITMAP
F3D9: 1F      		RRA			;is this block empty?
F3DA: D2FAF3  		JP	NC,FNDSPA3	;yes. use this.
              	;
              	;   Note that the above logic gets the first block that it finds
              	; that is empty. Thus a file could be written 'backward' making
              	; it very slow to access. This could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; This should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
F3DD: C1      		POP	BC		;nope, check some more.
F3DE: D1      		POP	DE
              	;
              	;   Now look after target block.
              	;
F3DF: 2AD4F9  	FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
F3E2: 7B      		LD	A,E
F3E3: 95      		SUB	L
F3E4: 7A      		LD	A,D
F3E5: 9C      		SBC	A,H
F3E6: D202F4  		JP	NC,FNDSPA4
F3E9: 13      		INC	DE		;yes, move on to next one.
F3EA: C5      		PUSH	BC
F3EB: D5      		PUSH	DE
F3EC: 42      		LD	B,D
F3ED: 4B      		LD	C,E
F3EE: CD43F2  		CALL	CKBITMAP	;check it.
F3F1: 1F      		RRA			;empty?
F3F2: D2FAF3  		JP	NC,FNDSPA3
F3F5: D1      		POP	DE		;nope, continue searching.
F3F6: C1      		POP	BC
F3F7: C3CEF3  		JP	FNDSPA1
              	;
              	;   Empty block found. Set it as used and return with (HL)
              	; pointing to it (true?).
              	;
F3FA: 17      	FNDSPA3:RLA			;reset byte.
F3FB: 3C      		INC	A		;and set bit 0.
F3FC: CD72F2  		CALL	STBMAP1		;update bit map.
F3FF: E1      		POP	HL		;set return registers.
F400: D1      		POP	DE
F401: C9      		RET
              	;
              	;   Free block was not found. If (BC) is not zero, then we have
              	; not checked all of the disk space.
              	;
F402: 79      	FNDSPA4:LD	A,C
F403: B0      		OR	B
F404: C2CEF3  		JP	NZ,FNDSPA1
F407: 210000  		LD	HL,0		;set 'not found' status.
F40A: C9      		RET
              	;
              	;   Move a complete fcb entry into the directory and write it.
              	;
F40B: 0E00    	FCBSET:	LD	C,0
F40D: 1E20    		LD	E,32		;length of each entry.
              	;
              	;   Move (E) bytes from the fcb pointed to by (PARAMS) into
              	; fcb in directory starting at relative byte (C). This updated
              	; directory buffer is then written to the disk.
              	;
F40F: D5      	UPDATE:	PUSH	DE
F410: 0600    		LD	B,0		;set (BC) to relative byte position.
F412: 2A51EF  		LD	HL,(PARAMS)	;get address of fcb.
F415: 09      		ADD	HL,BC		;compute starting byte.
F416: EB      		EX	DE,HL
F417: CD6CF1  		CALL	FCB2HL		;get address of fcb to update in directory.
F41A: C1      		POP	BC		;set (C) to number of bytes to change.
F41B: CD5DEF  		CALL	DE2HL
F41E: CDD1EF  	UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
F421: C3D4F1  		JP	DIRWRITE	;then write this sector out.
              	;
              	;   Routine to change the name of all files on the disk with a
              	; specified name. The fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
F424: CD62F1  	CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
F427: 0E0C    		LD	C,12		;match first 12 bytes of fcb only.
F429: CD26F3  		CALL	FINDFST		;get first name.
F42C: 2A51EF  		LD	HL,(PARAMS)	;get address of fcb.
F42F: 7E      		LD	A,(HL)		;get user number.
F430: 111000  		LD	DE,16		;move over to desired name.
F433: 19      		ADD	HL,DE
F434: 77      		LD	(HL),A		;keep same user number.
F435: CD03F2  	CHGNAM1:CALL	CKFILPOS	;any matching file found?
F438: C8      		RET	Z		;no, we must be done.
F439: CD52F1  		CALL	CHKROFL		;check for read only file.
F43C: 0E10    		LD	C,16		;start 16 bytes into fcb.
F43E: 1E0C    		LD	E,12		;and update the first 12 bytes of directory.
F440: CD0FF4  		CALL	UPDATE
F443: CD3BF3  		CALL	FINDNXT		;get te next file name.
F446: C335F4  		JP	CHGNAM1		;and continue.
              	;
              	;   Update a files attributes. The procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). No other changes
              	; are made.
              	;
F449: 0E0C    	SAVEATTR: LD	C,12		;match first 12 bytes.
F44B: CD26F3  		CALL	FINDFST		;look for first filename.
F44E: CD03F2  	SAVATR1:CALL	CKFILPOS	;was one found?
F451: C8      		RET	Z		;nope, we must be done.
F452: 0E00    		LD	C,0		;yes, update the first 12 bytes now.
F454: 1E0C    		LD	E,12
F456: CD0FF4  		CALL	UPDATE		;update filename and write directory.
F459: CD3BF3  		CALL	FINDNXT		;and get the next file.
F45C: C34EF4  		JP	SAVATR1		;then continue until done.
              	;
              	;  Open a file (name specified in fcb).
              	;
F45F: 0E0F    	OPENIT:	LD	C,15		;compare the first 15 bytes.
F461: CD26F3  		CALL	FINDFST		;get the first one in directory.
F464: CD03F2  		CALL	CKFILPOS	;any at all?
F467: C8      		RET	Z
F468: CDB4F0  	OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
F46B: 7E      		LD	A,(HL)		;and get it.
F46C: F5      		PUSH	AF		;save it and address.
F46D: E5      		PUSH	HL
F46E: CD6CF1  		CALL	FCB2HL		;point to fcb in directory.
F471: EB      		EX	DE,HL
F472: 2A51EF  		LD	HL,(PARAMS)	;this is the users copy.
F475: 0E20    		LD	C,32		;move it into users space.
F477: D5      		PUSH	DE
F478: CD5DEF  		CALL	DE2HL
F47B: CD86F1  		CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
F47E: D1      		POP	DE		;now get the extent byte from this fcb.
F47F: 210C00  		LD	HL,12
F482: 19      		ADD	HL,DE
F483: 4E      		LD	C,(HL)		;into (C).
F484: 210F00  		LD	HL,15		;now get the record count byte into (B).
F487: 19      		ADD	HL,DE
F488: 46      		LD	B,(HL)
F489: E1      		POP	HL		;keep the same extent as the user had originally.
F48A: F1      		POP	AF
F48B: 77      		LD	(HL),A
F48C: 79      		LD	A,C		;is it the same as in the directory fcb?
F48D: BE      		CP	(HL)
F48E: 78      		LD	A,B		;if yes, then use the same record count.
F48F: CA99F4  		JP	Z,OPENIT2
F492: 3E00    		LD	A,0		;if the user specified an extent greater than
F494: DA99F4  		JP	C,OPENIT2	;the one in the directory, then set record count to 0.
F497: 3E80    		LD	A,128		;otherwise set to maximum.
F499: 2A51EF  	OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
F49C: 110F00  		LD	DE,15
F49F: 19      		ADD	HL,DE		;compute relative position.
F4A0: 77      		LD	(HL),A		;and set the record count.
F4A1: C9      		RET	
              	;
              	;   Move two bytes from (DE) to (HL) if (and only if) (HL)
              	; point to a zero value (16 bit).
              	;   Return with zero flag set it (DE) was moved. Registers (DE)
              	; and (HL) are not changed. However (A) is.
              	;
F4A2: 7E      	MOVEWORD: LD	A,(HL)		;check for a zero word.
F4A3: 23      		INC	HL
F4A4: B6      		OR	(HL)		;both bytes zero?
F4A5: 2B      		DEC	HL
F4A6: C0      		RET	NZ		;nope, just return.
F4A7: 1A      		LD	A,(DE)		;yes, move two bytes from (DE) into
F4A8: 77      		LD	(HL),A		;this zero space.
F4A9: 13      		INC	DE
F4AA: 23      		INC	HL
F4AB: 1A      		LD	A,(DE)
F4AC: 77      		LD	(HL),A
F4AD: 1B      		DEC	DE		;don't disturb these registers.
F4AE: 2B      		DEC	HL
F4AF: C9      		RET	
              	;
              	;   Get here to close a file specified by (fcb).
              	;
F4B0: AF      	CLOSEIT:XOR	A		;clear status and file position bytes.
F4B1: 3253EF  		LD	(STATUS),A
F4B4: 32F8F9  		LD	(FILEPOS),A
F4B7: 32F9F9  		LD	(FILEPOS+1),A
F4BA: CD2CF1  		CALL	GETWPRT		;get write protect bit for this drive.
F4BD: C0      		RET	NZ		;just return if it is set.
F4BE: CD77F1  		CALL	GETS2		;else get the 's2' byte.
F4C1: E680    		AND	80H		;and look at bit 7 (file unmodified?).
F4C3: C0      		RET	NZ		;just return if set.
F4C4: 0E0F    		LD	C,15		;else look up this file in directory.
F4C6: CD26F3  		CALL	FINDFST
F4C9: CD03F2  		CALL	CKFILPOS	;was it found?
F4CC: C8      		RET	Z		;just return if not.
F4CD: 011000  		LD	BC,16		;set (HL) pointing to records used section.
F4D0: CD6CF1  		CALL	FCB2HL
F4D3: 09      		ADD	HL,BC
F4D4: EB      		EX	DE,HL
F4D5: 2A51EF  		LD	HL,(PARAMS)	;do the same for users specified fcb.
F4D8: 09      		ADD	HL,BC
F4D9: 0E10    		LD	C,16		;this many bytes are present in this extent.
F4DB: 3AEBF9  	CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
F4DE: B7      		OR	A
F4DF: CAF6F4  		JP	Z,CLOSEIT4
F4E2: 7E      		LD	A,(HL)		;just 8 bit. Get one from users fcb.
F4E3: B7      		OR	A
F4E4: 1A      		LD	A,(DE)		;now get one from directory fcb.
F4E5: C2E9F4  		JP	NZ,CLOSEIT2
F4E8: 77      		LD	(HL),A		;users byte was zero. Update from directory.
F4E9: B7      	CLOSEIT2: OR	A
F4EA: C2EFF4  		JP	NZ,CLOSEIT3
F4ED: 7E      		LD	A,(HL)		;directories byte was zero, update from users fcb.
F4EE: 12      		LD	(DE),A
F4EF: BE      	CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
F4F0: C22DF5  		JP	NZ,CLOSEIT7	;then close error if they are not the same.
F4F3: C30BF5  		JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
F4F6: CDA2F4  	CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
F4F9: EB      		EX	DE,HL
F4FA: CDA2F4  		CALL	MOVEWORD	;update directories fcb if it is zero.
F4FD: EB      		EX	DE,HL
F4FE: 1A      		LD	A,(DE)		;if these two values are no different,
F4FF: BE      		CP	(HL)		;then a close error occured.
F500: C22DF5  		JP	NZ,CLOSEIT7
F503: 13      		INC	DE		;check second byte.
F504: 23      		INC	HL
F505: 1A      		LD	A,(DE)
F506: BE      		CP	(HL)
F507: C22DF5  		JP	NZ,CLOSEIT7
F50A: 0D      		DEC	C		;remember 16 bit values.
F50B: 13      	CLOSEIT5: INC	DE		;bump to next item in table.
F50C: 23      		INC	HL
F50D: 0D      		DEC	C		;there are 16 entries only.
F50E: C2DBF4  		JP	NZ,CLOSEIT1	;continue if more to do.
F511: 01ECFF  		LD	BC,0FFECH	;backup 20 places (extent byte).
F514: 09      		ADD	HL,BC
F515: EB      		EX	DE,HL
F516: 09      		ADD	HL,BC
F517: 1A      		LD	A,(DE)
F518: BE      		CP	(HL)		;directory's extent already greater than the
F519: DA25F5  		JP	C,CLOSEIT6	;users extent?
F51C: 77      		LD	(HL),A		;no, update directory extent.
F51D: 010300  		LD	BC,3		;and update the record count byte in
F520: 09      		ADD	HL,BC		;directories fcb.
F521: EB      		EX	DE,HL
F522: 09      		ADD	HL,BC
F523: 7E      		LD	A,(HL)		;get from user.
F524: 12      		LD	(DE),A		;and put in directory.
F525: 3EFF    	CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
F527: 32E0F9  		LD	(CLOSEFLG),A
F52A: C31EF4  		JP	UPDATE1		;update the directory now.
F52D: 2153EF  	CLOSEIT7: LD	HL,STATUS	;set return status and then return.
F530: 35      		DEC	(HL)
F531: C9      		RET
              	;
              	;   Routine to get the next empty space in the directory. It
              	; will then be cleared for use.
              	;
F532: CD62F1  	GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
F535: 2A51EF  		LD	HL,(PARAMS)	;save current parameters (fcb).
F538: E5      		PUSH	HL
F539: 21BAF9  		LD	HL,EMPTYFCB	;use special one for empty space.
F53C: 2251EF  		LD	(PARAMS),HL
F53F: 0E01    		LD	C,1		;search for first empty spot in directory.
F541: CD26F3  		CALL	FINDFST		;(* only check first byte *)
F544: CD03F2  		CALL	CKFILPOS	;none?
F547: E1      		POP	HL
F548: 2251EF  		LD	(PARAMS),HL	;restore original fcb address.
F54B: C8      		RET	Z		;return if no more space.
F54C: EB      		EX	DE,HL
F54D: 210F00  		LD	HL,15		;point to number of records for this file.
F550: 19      		ADD	HL,DE
F551: 0E11    		LD	C,17		;and clear all of this space.
F553: AF      		XOR	A
F554: 77      	GETMT1:	LD	(HL),A
F555: 23      		INC	HL
F556: 0D      		DEC	C
F557: C254F5  		JP	NZ,GETMT1
F55A: 210D00  		LD	HL,13		;clear the 's1' byte also.
F55D: 19      		ADD	HL,DE
F55E: 77      		LD	(HL),A
F55F: CD9AF1  		CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
F562: CD0BF4  		CALL	FCBSET		;write out this fcb entry to directory.
F565: C386F1  		JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   Routine to close the current extent and open the next one
              	; for reading.
              	;
F568: AF      	GETNEXT:XOR	A
F569: 32E0F9  		LD	(CLOSEFLG),A	;clear close flag.
F56C: CDB0F4  		CALL	CLOSEIT		;close this extent.
F56F: CD03F2  		CALL	CKFILPOS
F572: C8      		RET	Z		;not there???
F573: 2A51EF  		LD	HL,(PARAMS)	;get extent byte.
F576: 010C00  		LD	BC,12
F579: 09      		ADD	HL,BC
F57A: 7E      		LD	A,(HL)		;and increment it.
F57B: 3C      		INC	A
F57C: E61F    		AND	1FH		;keep within range 0-31.
F57E: 77      		LD	(HL),A
F57F: CA91F5  		JP	Z,GTNEXT1	;overflow?
F582: 47      		LD	B,A		;mask extent byte.
F583: 3AD3F9  		LD	A,(EXTMASK)
F586: A0      		AND	B
F587: 21E0F9  		LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
F58A: A6      		AND	(HL)
F58B: CA9CF5  		JP	Z,GTNEXT2	;if zero, we must read in next extent.
F58E: C3BAF5  		JP	GTNEXT3		;else, it is already in memory.
F591: 010200  	GTNEXT1:LD	BC,2		;Point to the 's2' byte.
F594: 09      		ADD	HL,BC
F595: 34      		INC	(HL)		;and bump it.
F596: 7E      		LD	A,(HL)		;too many extents?
F597: E60F    		AND	0FH
F599: CAC4F5  		JP	Z,GTNEXT5	;yes, set error code.
              	;
              	;   Get here to open the next extent.
              	;
F59C: 0E0F    	GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
F59E: CD26F3  		CALL	FINDFST		;find the first one.
F5A1: CD03F2  		CALL	CKFILPOS	;none available?
F5A4: C2BAF5  		JP	NZ,GTNEXT3
F5A7: 3AE1F9  		LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
F5AA: 3C      		INC	A		;0ffh means reading (so not possible).
F5AB: CAC4F5  		JP	Z,GTNEXT5	;or an error.
F5AE: CD32F5  		CALL	GETEMPTY	;we are writing, get an empty entry.
F5B1: CD03F2  		CALL	CKFILPOS	;none?
F5B4: CAC4F5  		JP	Z,GTNEXT5	;error if true.
F5B7: C3BDF5  		JP	GTNEXT4		;else we are almost done.
F5BA: CD68F4  	GTNEXT3:CALL	OPENIT1		;open this extent.
F5BD: CDC9F0  	GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
F5C0: AF      		XOR	A		;clear status and return.
F5C1: C30FEF  		JP	SETSTAT
              	;
              	;   Error in extending the file. Too many extents were needed
              	; or not enough space on the disk.
              	;
F5C4: CD13EF  	GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
F5C7: C386F1  		JP	SETS2B7		;so this is not written on a close.
              	;
              	;   Read a sequential file.
              	;
F5CA: 3E01    	RDSEQ:	LD	A,1		;set sequential access mode.
F5CC: 32E3F9  		LD	(MODE),A
F5CF: 3EFF    	RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
F5D1: 32E1F9  		LD	(RDWRTFLG),A
F5D4: CDC9F0  		CALL	STRDATA		;put rec# and ext# into fcb.
F5D7: 3AF1F9  		LD	A,(SAVNREC)	;get next record to read.
F5DA: 21EFF9  		LD	HL,SAVNXT	;get number of records in extent.
F5DD: BE      		CP	(HL)		;within this extent?
F5DE: DAF4F5  		JP	C,RDSEQ2
F5E1: FE80    		CP	128		;no. Is this extent fully used?
F5E3: C209F6  		JP	NZ,RDSEQ3	;no. End-of-file.
F5E6: CD68F5  		CALL	GETNEXT		;yes, open the next one.
F5E9: AF      		XOR	A		;reset next record to read.
F5EA: 32F1F9  		LD	(SAVNREC),A
F5ED: 3A53EF  		LD	A,(STATUS)	;check on open, successful?
F5F0: B7      		OR	A
F5F1: C209F6  		JP	NZ,RDSEQ3	;no, error.
F5F4: CD85F0  	RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
F5F7: CD92F0  		CALL	CHKBLK		;check it. Within bounds?
F5FA: CA09F6  		JP	Z,RDSEQ3	;no, error.
F5FD: CD98F0  		CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
F600: CDDFEF  		CALL	TRKSEC1		;set the track and sector for this block #.
F603: CDC0EF  		CALL	DOREAD		;and read it.
F606: C3E0F0  		JP	SETNREC		;and set the next record to be accessed.
              	;
              	;   Read error occured. Set status and return.
              	;
F609: C313EF  	RDSEQ3:	JP	IOERR1
              	;
              	;   Write the next sequential record.
              	;
F60C: 3E01    	WTSEQ:	LD	A,1		;set sequential access mode.
F60E: 32E3F9  		LD	(MODE),A
F611: 3E00    	WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
F613: 32E1F9  		LD	(RDWRTFLG),A
F616: CD62F1  		CALL	CHKWPRT		;check write protect status.
F619: 2A51EF  		LD	HL,(PARAMS)
F61C: CD55F1  		CALL	CKROF1		;check for read only file, (HL) already set to fcb.
F61F: CDC9F0  		CALL	STRDATA		;put updated data into fcb.
F622: 3AF1F9  		LD	A,(SAVNREC)	;get record number to write.
F625: FE80    		CP	128		;within range?
F627: D213EF  		JP	NC,IOERR1	;no, error(?).
F62A: CD85F0  		CALL	COMBLK		;compute block number.
F62D: CD92F0  		CALL	CHKBLK		;check number.
F630: 0E00    		LD	C,0		;is there one to write to?
F632: C27CF6  		JP	NZ,WTSEQ6	;yes, go do it.
F635: CD4CF0  		CALL	GETBLOCK	;get next block number within fcb to use.
F638: 32E5F9  		LD	(RELBLOCK),A	;and save.
F63B: 010000  		LD	BC,0		;start looking for space from the start
F63E: B7      		OR	A		;if none allocated as yet.
F63F: CA49F6  		JP	Z,WTSEQ2
F642: 4F      		LD	C,A		;extract previous block number from fcb
F643: 0B      		DEC	BC		;so we can be closest to it.
F644: CD6CF0  		CALL	EXTBLK
F647: 44      		LD	B,H
F648: 4D      		LD	C,L
F649: CDCCF3  	WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
F64C: 7D      		LD	A,L		;check for a zero number.
F64D: B4      		OR	H
F64E: C256F6  		JP	NZ,WTSEQ3
F651: 3E02    		LD	A,2		;no more space?
F653: C30FEF  		JP	SETSTAT
F656: 22F3F9  	WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
F659: EB      		EX	DE,HL		;put block number into (DE).
F65A: 2A51EF  		LD	HL,(PARAMS)	;now we must update the fcb for this
F65D: 011000  		LD	BC,16		;newly allocated block.
F660: 09      		ADD	HL,BC
F661: 3AEBF9  		LD	A,(BIGDISK)	;8 or 16 bit block numbers?
F664: B7      		OR	A
F665: 3AE5F9  		LD	A,(RELBLOCK)	;(* update this entry *)
F668: CA72F6  		JP	Z,WTSEQ4	;zero means 16 bit ones.
F66B: CD72F1  		CALL	ADDA2HL		;(HL)=(HL)+(A)
F66E: 73      		LD	(HL),E		;store new block number.
F66F: C37AF6  		JP	WTSEQ5
F672: 4F      	WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
F673: 0600    		LD	B,0
F675: 09      		ADD	HL,BC
F676: 09      		ADD	HL,BC
F677: 73      		LD	(HL),E		;stuff block number (DE) there.
F678: 23      		INC	HL
F679: 72      		LD	(HL),D
F67A: 0E02    	WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
F67C: 3A53EF  	WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
F67F: B7      		OR	A
F680: C0      		RET	NZ
F681: C5      		PUSH	BC		;yes, save write flag for bios (register C).
F682: CD98F0  		CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
F685: 3AE3F9  		LD	A,(MODE)	;get access mode flag (1=sequential,
F688: 3D      		DEC	A		;0=random, 2=special?).
F689: 3D      		DEC	A
F68A: C2C9F6  		JP	NZ,WTSEQ9
              	;
              	;   Special random i/o from function #40. Maybe for M/PM, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
F68D: C1      		POP	BC
F68E: C5      		PUSH	BC
F68F: 79      		LD	A,C		;get write status flag (2=writing unused space).
F690: 3D      		DEC	A
F691: 3D      		DEC	A
F692: C2C9F6  		JP	NZ,WTSEQ9
F695: E5      		PUSH	HL
F696: 2AC7F9  		LD	HL,(DIRBUF)	;zero out the directory buffer.
F699: 57      		LD	D,A		;note that (A) is zero here.
F69A: 77      	WTSEQ7:	LD	(HL),A
F69B: 23      		INC	HL
F69C: 14      		INC	D		;do 128 bytes.
F69D: F29AF6  		JP	P,WTSEQ7
F6A0: CDEEF1  		CALL	DIRDMA		;tell the bios the dma address for directory access.
F6A3: 2AF5F9  		LD	HL,(LOGSECT)	;get sector that starts current block.
F6A6: 0E02    		LD	C,2		;set 'writing to unused space' flag.
F6A8: 22F3F9  	WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
F6AB: C5      		PUSH	BC
F6AC: CDDFEF  		CALL	TRKSEC1		;determine its track and sector numbers.
F6AF: C1      		POP	BC
F6B0: CDC6EF  		CALL	DOWRITE		;now write out 128 bytes of zeros.
F6B3: 2AF3F9  		LD	HL,(BLKNMBR)	;get sector number.
F6B6: 0E00    		LD	C,0		;set normal write flag.
F6B8: 3AD2F9  		LD	A,(BLKMASK)	;determine if we have written the entire
F6BB: 47      		LD	B,A		;physical block.
F6BC: A5      		AND	L
F6BD: B8      		CP	B
F6BE: 23      		INC	HL		;prepare for the next one.
F6BF: C2A8F6  		JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
F6C2: E1      		POP	HL		;reset next sector number.
F6C3: 22F3F9  		LD	(BLKNMBR),HL
F6C6: CDE8F1  		CALL	DEFDMA		;and reset dma address.
              	;
              	;   Normal disk write. Set the desired track and sector then
              	; do the actual write.
              	;
F6C9: CDDFEF  	WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
F6CC: C1      		POP	BC		;get write status flag.
F6CD: C5      		PUSH	BC
F6CE: CDC6EF  		CALL	DOWRITE		;and write this out.
F6D1: C1      		POP	BC
F6D2: 3AF1F9  		LD	A,(SAVNREC)	;get number of records in file.
F6D5: 21EFF9  		LD	HL,SAVNXT	;get last record written.
F6D8: BE      		CP	(HL)
F6D9: DAE0F6  		JP	C,WTSEQ10
F6DC: 77      		LD	(HL),A		;we have to update record count.
F6DD: 34      		INC	(HL)
F6DE: 0E02    		LD	C,2
              	;
              	;*   This area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the BIOS.
              	;
F6E0: 00      	WTSEQ10:NOP			;was 'dcr c'
F6E1: 00      		NOP			;was 'dcr c'
F6E2: 210000  		LD	HL,0		;was 'jnz wtseq99'
              	;
              	; *   End of patch.
              	;
F6E5: F5      		PUSH	AF
F6E6: CD77F1  		CALL	GETS2		;set 'extent written to' flag.
F6E9: E67F    		AND	7FH		;(* clear bit 7 *)
F6EB: 77      		LD	(HL),A
F6EC: F1      		POP	AF		;get record count for this extent.
F6ED: FE7F    	WTSEQ99:CP	127		;is it full?
F6EF: C20EF7  		JP	NZ,WTSEQ12
F6F2: 3AE3F9  		LD	A,(MODE)	;yes, are we in sequential mode?
F6F5: FE01    		CP	1
F6F7: C20EF7  		JP	NZ,WTSEQ12
F6FA: CDE0F0  		CALL	SETNREC		;yes, set next record number.
F6FD: CD68F5  		CALL	GETNEXT		;and get next empty space in directory.
F700: 2153EF  		LD	HL,STATUS	;ok?
F703: 7E      		LD	A,(HL)
F704: B7      		OR	A
F705: C20CF7  		JP	NZ,WTSEQ11
F708: 3D      		DEC	A		;yes, set record count to -1.
F709: 32F1F9  		LD	(SAVNREC),A
F70C: 3600    	WTSEQ11:LD	(HL),0		;clear status.
F70E: C3E0F0  	WTSEQ12:JP	SETNREC		;set next record to access.
              	;
              	;   For random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   On entry, register (C) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. Otherwise,
              	; another extent will be opened (for writing) if required.
              	;
F711: AF      	POSITION: XOR	A		;set random i/o flag.
F712: 32E3F9  		LD	(MODE),A
              	;
              	;   Special entry (function #40). M/PM ?
              	;
F715: C5      	POSITN1:PUSH	BC		;save read/write flag.
F716: 2A51EF  		LD	HL,(PARAMS)	;get address of fcb.
F719: EB      		EX	DE,HL
F71A: 212100  		LD	HL,33		;now get byte 'r0'.
F71D: 19      		ADD	HL,DE
F71E: 7E      		LD	A,(HL)
F71F: E67F    		AND	7FH		;keep bits 0-6 for the record number to access.
F721: F5      		PUSH	AF
F722: 7E      		LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
F723: 17      		RLA
F724: 23      		INC	HL
F725: 7E      		LD	A,(HL)
F726: 17      		RLA
F727: E61F    		AND	1FH		;and save this in bits 0-4 of (C).
F729: 4F      		LD	C,A		;this is the extent byte.
F72A: 7E      		LD	A,(HL)		;now get the extra extent byte.
F72B: 1F      		RRA
F72C: 1F      		RRA
F72D: 1F      		RRA
F72E: 1F      		RRA
F72F: E60F    		AND	0FH
F731: 47      		LD	B,A		;and save it in (B).
F732: F1      		POP	AF		;get record number back to (A).
F733: 23      		INC	HL		;check overflow byte 'r2'.
F734: 6E      		LD	L,(HL)
F735: 2C      		INC	L
F736: 2D      		DEC	L
F737: 2E06    		LD	L,6		;prepare for error.
F739: C299F7  		JP	NZ,POSITN5	;out of disk space error.
F73C: 212000  		LD	HL,32		;store record number into fcb.
F73F: 19      		ADD	HL,DE
F740: 77      		LD	(HL),A
F741: 210C00  		LD	HL,12		;and now check the extent byte.
F744: 19      		ADD	HL,DE
F745: 79      		LD	A,C
F746: 96      		SUB	(HL)		;same extent as before?
F747: C255F7  		JP	NZ,POSITN2
F74A: 210E00  		LD	HL,14		;yes, check extra extent byte 's2' also.
F74D: 19      		ADD	HL,DE
F74E: 78      		LD	A,B
F74F: 96      		SUB	(HL)
F750: E67F    		AND	7FH
F752: CA8DF7  		JP	Z,POSITN3	;same, we are almost done then.
              	;
              	;  Get here when another extent is required.
              	;
F755: C5      	POSITN2:PUSH	BC
F756: D5      		PUSH	DE
F757: CDB0F4  		CALL	CLOSEIT		;close current extent.
F75A: D1      		POP	DE
F75B: C1      		POP	BC
F75C: 2E03    		LD	L,3		;prepare for error.
F75E: 3A53EF  		LD	A,(STATUS)
F761: 3C      		INC	A
F762: CA92F7  		JP	Z,POSITN4	;close error.
F765: 210C00  		LD	HL,12		;put desired extent into fcb now.
F768: 19      		ADD	HL,DE
F769: 71      		LD	(HL),C
F76A: 210E00  		LD	HL,14		;and store extra extent byte 's2'.
F76D: 19      		ADD	HL,DE
F76E: 70      		LD	(HL),B
F76F: CD5FF4  		CALL	OPENIT		;try and get this extent.
F772: 3A53EF  		LD	A,(STATUS)	;was it there?
F775: 3C      		INC	A
F776: C28DF7  		JP	NZ,POSITN3
F779: C1      		POP	BC		;no. can we create a new one (writing?).
F77A: C5      		PUSH	BC
F77B: 2E04    		LD	L,4		;prepare for error.
F77D: 0C      		INC	C
F77E: CA92F7  		JP	Z,POSITN4	;nope, reading unwritten space error.
F781: CD32F5  		CALL	GETEMPTY	;yes we can, try to find space.
F784: 2E05    		LD	L,5		;prepare for error.
F786: 3A53EF  		LD	A,(STATUS)
F789: 3C      		INC	A
F78A: CA92F7  		JP	Z,POSITN4	;out of space?
              	;
              	;   Normal return location. Clear error code and return.
              	;
F78D: C1      	POSITN3:POP	BC		;restore stack.
F78E: AF      		XOR	A		;and clear error code byte.
F78F: C30FEF  		JP	SETSTAT
              	;
              	;   Error. Set the 's2' byte to indicate this (why?).
              	;
F792: E5      	POSITN4:PUSH	HL
F793: CD77F1  		CALL	GETS2
F796: 36C0    		LD	(HL),0C0H
F798: E1      		POP	HL
              	;
              	;   Return with error code (presently in L).
              	;
F799: C1      	POSITN5:POP	BC
F79A: 7D      		LD	A,L		;get error code.
F79B: 3253EF  		LD	(STATUS),A
F79E: C386F1  		JP	SETS2B7
              	;
              	;   Read a random record.
              	;
F7A1: 0EFF    	READRAN:LD	C,0FFH		;set 'read' status.
F7A3: CD11F7  		CALL	POSITION	;position the file to proper record.
F7A6: CCCFF5  		CALL	Z,RDSEQ1	;and read it as usual (if no errors).
F7A9: C9      		RET
              	;
              	;   Write to a random record.
              	;
F7AA: 0E00    	WRITERAN: LD	C,0		;set 'writing' flag.
F7AC: CD11F7  		CALL	POSITION	;position the file to proper record.
F7AF: CC11F6  		CALL	Z,WTSEQ1	;and write as usual (if no errors).
F7B2: C9      		RET
              	;
              	;   Compute the random record number. Enter with (HL) pointing
              	; to a fcb an (DE) contains a relative location of a record
              	; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
              	; byte, and (A) the 'r2' byte.
              	;
              	;   On return, the zero flag is set if the record is within
              	; bounds. Otherwise, an overflow occured.
              	;
F7B3: EB      	COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
F7B4: 19      		ADD	HL,DE		;compute relative position of record #.
F7B5: 4E      		LD	C,(HL)		;get record number into (BC).
F7B6: 0600    		LD	B,0
F7B8: 210C00  		LD	HL,12		;now get extent.
F7BB: 19      		ADD	HL,DE
F7BC: 7E      		LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
F7BD: 0F      		RRCA			;move lower bit into bit 7.
F7BE: E680    		AND	80H		;and ignore all other bits.
F7C0: 81      		ADD	A,C		;add to our record number.
F7C1: 4F      		LD	C,A
F7C2: 3E00    		LD	A,0		;take care of any carry.
F7C4: 88      		ADC	A,B
F7C5: 47      		LD	B,A
F7C6: 7E      		LD	A,(HL)		;now get the upper bits of extent into
F7C7: 0F      		RRCA			;bit positions 0-3.
F7C8: E60F    		AND	0FH		;and ignore all others.
F7CA: 80      		ADD	A,B		;add this in to 'r1' byte.
F7CB: 47      		LD	B,A
F7CC: 210E00  		LD	HL,14		;get the 's2' byte (extra extent).
F7CF: 19      		ADD	HL,DE
F7D0: 7E      		LD	A,(HL)
F7D1: 87      		ADD	A,A		;and shift it left 4 bits (bits 4-7).
F7D2: 87      		ADD	A,A
F7D3: 87      		ADD	A,A
F7D4: 87      		ADD	A,A
F7D5: F5      		PUSH	AF		;save carry flag (bit 0 of flag byte).
F7D6: 80      		ADD	A,B		;now add extra extent into 'r1'.
F7D7: 47      		LD	B,A
F7D8: F5      		PUSH	AF		;and save carry (overflow byte 'r2').
F7D9: E1      		POP	HL		;bit 0 of (L) is the overflow indicator.
F7DA: 7D      		LD	A,L
F7DB: E1      		POP	HL		;and same for first carry flag.
F7DC: B5      		OR	L		;either one of these set?
F7DD: E601    		AND	01H		;only check the carry flags.
F7DF: C9      		RET
              	;
              	;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; This reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. Then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. This is used to compute the space used
              	; by a random file.
              	;
F7E0: 0E0C    	RANSIZE:LD	C,12		;look thru directory for first entry with
F7E2: CD26F3  		CALL	FINDFST		;this name.
F7E5: 2A51EF  		LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
F7E8: 112100  		LD	DE,33
F7EB: 19      		ADD	HL,DE
F7EC: E5      		PUSH	HL
F7ED: 72      		LD	(HL),D		;note that (D)=0.
F7EE: 23      		INC	HL
F7EF: 72      		LD	(HL),D
F7F0: 23      		INC	HL
F7F1: 72      		LD	(HL),D
F7F2: CD03F2  	RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
F7F5: CA1AF8  		JP	Z,RANSIZ3	;no, we are done.
F7F8: CD6CF1  		CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
F7FB: 110F00  		LD	DE,15		;point to last record in extent.
F7FE: CDB3F7  		CALL	COMPRAND	;and compute random parameters.
F801: E1      		POP	HL
F802: E5      		PUSH	HL		;now check these values against those
F803: 5F      		LD	E,A		;already in fcb.
F804: 79      		LD	A,C		;the carry flag will be set if those
F805: 96      		SUB	(HL)		;in the fcb represent a larger size than
F806: 23      		INC	HL		;this extent does.
F807: 78      		LD	A,B
F808: 9E      		SBC	A,(HL)
F809: 23      		INC	HL
F80A: 7B      		LD	A,E
F80B: 9E      		SBC	A,(HL)
F80C: DA14F8  		JP	C,RANSIZ2
F80F: 73      		LD	(HL),E		;we found a larger (in size) extent.
F810: 2B      		DEC	HL		;stuff these values into fcb.
F811: 70      		LD	(HL),B
F812: 2B      		DEC	HL
F813: 71      		LD	(HL),C
F814: CD3BF3  	RANSIZ2:CALL	FINDNXT		;now get the next extent.
F817: C3F2F7  		JP	RANSIZ1		;continue til all done.
F81A: E1      	RANSIZ3:POP	HL		;we are done, restore the stack and
F81B: C9      		RET			;return.
              	;
              	;   Function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
F81C: 2A51EF  	SETRAN:	LD	HL,(PARAMS)	;point to fcb.
F81F: 112000  		LD	DE,32		;and to last used record.
F822: CDB3F7  		CALL	COMPRAND	;compute random position.
F825: 212100  		LD	HL,33		;now stuff these values into fcb.
F828: 19      		ADD	HL,DE
F829: 71      		LD	(HL),C		;move 'r0'.
F82A: 23      		INC	HL
F82B: 70      		LD	(HL),B		;and 'r1'.
F82C: 23      		INC	HL
F82D: 77      		LD	(HL),A		;and lastly 'r2'.
F82E: C9      		RET
              	;
              	;   This routine select the drive specified in (ACTIVE) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
F82F: 2ABDF9  	LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
F832: 3A50EF  		LD	A,(ACTIVE)	;get the default drive.
F835: 4F      		LD	C,A
F836: CDF8F0  		CALL	SHIFTR		;position active bit for this drive
F839: E5      		PUSH	HL		;into bit 0.
F83A: EB      		EX	DE,HL
F83B: CD67EF  		CALL	SELECT		;select this drive.
F83E: E1      		POP	HL
F83F: CC55EF  		CALL	Z,SLCTERR	;valid drive?
F842: 7D      		LD	A,L		;is this a newly activated drive?
F843: 1F      		RRA
F844: D8      		RET	C
F845: 2ABDF9  		LD	HL,(LOGIN)	;yes, update the login vector.
F848: 4D      		LD	C,L
F849: 44      		LD	B,H
F84A: CD19F1  		CALL	SETBIT
F84D: 22BDF9  		LD	(LOGIN),HL	;and save.
F850: C3B1F2  		JP	BITMAP		;now update the bitmap.
              	;
              	;   Function to set the active disk number.
              	;
F853: 3AE4F9  	SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
F856: 2150EF  		LD	HL,ACTIVE	;represents a change in drives.
F859: BE      		CP	(HL)
F85A: C8      		RET	Z
F85B: 77      		LD	(HL),A		;yes it does, log it in.
F85C: C32FF8  		JP	LOGINDRV
              	;
              	;   This is the 'auto disk select' routine. The firsst byte
              	; of the fcb is examined for a drive specification. If non
              	; zero then the drive will be selected and loged in.
              	;
F85F: 3EFF    	AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
F861: 32ECF9  		LD	(AUTO),A
F864: 2A51EF  		LD	HL,(PARAMS)	;get drive specified.
F867: 7E      		LD	A,(HL)
F868: E61F    		AND	1FH		;look at lower 5 bits.
F86A: 3D      		DEC	A		;adjust for (1=A, 2=B) etc.
F86B: 32E4F9  		LD	(EPARAM),A	;and save for the select routine.
F86E: FE1E    		CP	1EH		;check for 'no change' condition.
F870: D283F8  		JP	NC,AUTOSL1	;yes, don't change.
F873: 3A50EF  		LD	A,(ACTIVE)	;we must change, save currently active
F876: 32EDF9  		LD	(OLDDRV),A	;drive.
F879: 7E      		LD	A,(HL)		;and save first byte of fcb also.
F87A: 32EEF9  		LD	(AUTOFLAG),A	;this must be non-zero.
F87D: E6E0    		AND	0E0H		;whats this for (bits 6,7 are used for
F87F: 77      		LD	(HL),A		;something)?
F880: CD53F8  		CALL	SETDSK		;select and log in this drive.
F883: 3A4FEF  	AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
F886: 2A51EF  		LD	HL,(PARAMS)	;(* upper half of first byte *)
F889: B6      		OR	(HL)
F88A: 77      		LD	(HL),A
F88B: C9      		RET			;and return (all done).
              	;
              	;   Function to return the current cp/m version number.
              	;
F88C: 3E22    	GETVER:	LD	A,022H		;version 2.2
F88E: C30FEF  		JP	SETSTAT
              	;
              	;   Function to reset the disk system.
              	;
F891: 210000  	RSTDSK:	LD	HL,0		;clear write protect status and log
F894: 22BBF9  		LD	(WRTPRT),HL	;in vector.
F897: 22BDF9  		LD	(LOGIN),HL
F89A: AF      		XOR	A		;select drive 'A'.
F89B: 3250EF  		LD	(ACTIVE),A
F89E: 218000  		LD	HL,TBUFF	;setup default dma address.
F8A1: 22BFF9  		LD	(USERDMA),HL
F8A4: CDE8F1  		CALL	DEFDMA
F8A7: C32FF8  		JP	LOGINDRV	;now log in drive 'A'.
              	;
              	;   Function to open a specified file.
              	;
F8AA: CD80F1  	OPENFIL:CALL	CLEARS2		;clear 's2' byte.
F8AD: CD5FF8  		CALL	AUTOSEL		;select proper disk.
F8B0: C35FF4  		JP	OPENIT		;and open the file.
              	;
              	;   Function to close a specified file.
              	;
F8B3: CD5FF8  	CLOSEFIL: CALL	AUTOSEL		;select proper disk.
F8B6: C3B0F4  		JP	CLOSEIT		;and close the file.
              	;
              	;   Function to return the first occurence of a specified file
              	; name. If the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
F8B9: 0E00    	GETFST:	LD	C,0		;prepare for special search.
F8BB: EB      		EX	DE,HL
F8BC: 7E      		LD	A,(HL)		;is first byte a '?'?
F8BD: FE3F    		CP	'?'
F8BF: CAD0F8  		JP	Z,GETFST1	;yes, just get very first entry (zero length match).
F8C2: CDB4F0  		CALL	SETEXT		;get the extension byte from fcb.
F8C5: 7E      		LD	A,(HL)		;is it '?'? if yes, then we want
F8C6: FE3F    		CP	'?'		;an entry with a specific 's2' byte.
F8C8: C480F1  		CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
F8CB: CD5FF8  		CALL	AUTOSEL		;select proper drive.
F8CE: 0E0F    		LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
F8D0: CD26F3  	GETFST1:CALL	FINDFST		;find an entry and then move it into
F8D3: C3F7F1  		JP	MOVEDIR		;the users dma space.
              	;
              	;   Function to return the next occurence of a file name.
              	;
F8D6: 2AE7F9  	GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
F8D9: 2251EF  		LD	(PARAMS),HL	;other dbos calls are allowed.
F8DC: CD5FF8  		CALL	AUTOSEL		;no error will be returned, but the
F8DF: CD3BF3  		CALL	FINDNXT		;results will be wrong.
F8E2: C3F7F1  		JP	MOVEDIR
              	;
              	;   Function to delete a file by name.
              	;
F8E5: CD5FF8  	DELFILE:CALL	AUTOSEL		;select proper drive.
F8E8: CDAAF3  		CALL	ERAFILE		;erase the file.
F8EB: C30FF3  		JP	STSTATUS	;set status and return.
              	;
              	;   Function to execute a sequential read of the specified
              	; record number.
              	;
F8EE: CD5FF8  	READSEQ:CALL	AUTOSEL		;select proper drive then read.
F8F1: C3CAF5  		JP	RDSEQ
              	;
              	;   Function to write the net sequential record.
              	;
F8F4: CD5FF8  	WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
F8F7: C30CF6  		JP	WTSEQ
              	;
              	;   Create a file function.
              	;
F8FA: CD80F1  	FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
F8FD: CD5FF8  		CALL	AUTOSEL		;select proper drive and get the next
F900: C332F5  		JP	GETEMPTY	;empty directory space.
              	;
              	;   Function to rename a file.
              	;
F903: CD5FF8  	RENFILE:CALL	AUTOSEL		;select proper drive and then switch
F906: CD24F4  		CALL	CHGNAMES	;file names.
F909: C30FF3  		JP	STSTATUS
              	;
              	;   Function to return the login vector.
              	;
F90C: 2ABDF9  	GETLOG:	LD	HL,(LOGIN)
F90F: C337F9  		JP	GETPRM1
              	;
              	;   Function to return the current disk assignment.
              	;
F912: 3A50EF  	GETCRNT:LD	A,(ACTIVE)
F915: C30FEF  		JP	SETSTAT
              	;
              	;   Function to set the dma address.
              	;
F918: EB      	PUTDMA:	EX	DE,HL
F919: 22BFF9  		LD	(USERDMA),HL	;save in our space and then get to
F91C: C3E8F1  		JP	DEFDMA		;the bios with this also.
              	;
              	;   Function to return the allocation vector.
              	;
F91F: 2ACDF9  	GETALOC:LD	HL,(ALOCVECT)
F922: C337F9  		JP	GETPRM1
              	;
              	;   Function to return the read-only status vector.
              	;
F925: 2ABBF9  	GETROV:	LD	HL,(WRTPRT)
F928: C337F9  		JP	GETPRM1
              	;
              	;   Function to set the file attributes (read-only, system).
              	;
F92B: CD5FF8  	SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
F92E: CD49F4  		CALL	SAVEATTR
F931: C30FF3  		JP	STSTATUS
              	;
              	;   Function to return the address of the disk parameter block
              	; for the current drive.
              	;
F934: 2AC9F9  	GETPARM:LD	HL,(DISKPB)
F937: 2253EF  	GETPRM1:LD	(STATUS),HL
F93A: C9      		RET
              	;
              	;   Function to get or set the user number. If (E) was (FF)
              	; then this is a request to return the current user number.
              	; Else set the user number from (E).
              	;
F93B: 3AE4F9  	GETUSER:LD	A,(EPARAM)	;get parameter.
F93E: FEFF    		CP	0FFH		;get user number?
F940: C249F9  		JP	NZ,SETUSER
F943: 3A4FEF  		LD	A,(USERNO)	;yes, just do it.
F946: C30FEF  		JP	SETSTAT
F949: E61F    	SETUSER:AND	1FH		;no, we should set it instead. keep low
F94B: 324FEF  		LD	(USERNO),A	;bits (0-4) only.
F94E: C9      		RET
              	;
              	;   Function to read a random record from a file.
              	;
F94F: CD5FF8  	RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
F952: C3A1F7  		JP	READRAN
              	;
              	;   Function to compute the file size for random files.
              	;
F955: CD5FF8  	WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
F958: C3AAF7  		JP	WRITERAN
              	;
              	;   Function to compute the size of a random file.
              	;
F95B: CD5FF8  	FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
F95E: C3E0F7  		JP	RANSIZE
              	;
              	;   Function #37. This allows a program to log off any drives.
              	; On entry, set (DE) to contain a word with bits set for those
              	; drives that are to be logged off. The log-in vector and the
              	; write protect vector will be updated. This must be a M/PM
              	; special function.
              	;
F961: 2A51EF  	LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
F964: 7D      		LD	A,L		;for each bit that is set, we want
F965: 2F      		CPL			;to clear that bit in (LOGIN)
F966: 5F      		LD	E,A		;and (WRTPRT).
F967: 7C      		LD	A,H
F968: 2F      		CPL
F969: 2ABDF9  		LD	HL,(LOGIN)	;reset the login vector.
F96C: A4      		AND	H
F96D: 57      		LD	D,A
F96E: 7D      		LD	A,L
F96F: A3      		AND	E
F970: 5F      		LD	E,A
F971: 2ABBF9  		LD	HL,(WRTPRT)
F974: EB      		EX	DE,HL
F975: 22BDF9  		LD	(LOGIN),HL	;and save.
F978: 7D      		LD	A,L		;now do the write protect vector.
F979: A3      		AND	E
F97A: 6F      		LD	L,A
F97B: 7C      		LD	A,H
F97C: A2      		AND	D
F97D: 67      		LD	H,A
F97E: 22BBF9  		LD	(WRTPRT),HL	;and save. all done.
F981: C9      		RET
              	;
              	;   Get here to return to the user.
              	;
F982: 3AECF9  	GOBACK:	LD	A,(AUTO)	;was auto select activated?
F985: B7      		OR	A
F986: CA9FF9  		JP	Z,GOBACK1
F989: 2A51EF  		LD	HL,(PARAMS)	;yes, but was a change made?
F98C: 3600    		LD	(HL),0		;(* reset first byte of fcb *)
F98E: 3AEEF9  		LD	A,(AUTOFLAG)
F991: B7      		OR	A
F992: CA9FF9  		JP	Z,GOBACK1
F995: 77      		LD	(HL),A		;yes, reset first byte properly.
F996: 3AEDF9  		LD	A,(OLDDRV)	;and get the old drive and select it.
F999: 32E4F9  		LD	(EPARAM),A
F99C: CD53F8  		CALL	SETDSK
F99F: 2A1DEF  	GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
F9A2: F9      		LD	SP,HL
F9A3: 2A53EF  		LD	HL,(STATUS)	;get return status.
F9A6: 7D      		LD	A,L		;force version 1.4 compatability.
F9A7: 44      		LD	B,H
F9A8: C9      		RET			;and go back to user.
              	;
              	;   Function #40. This is a special entry to do random i/o.
              	; For the case where we are writing to unused disk space, this
              	; space will be zeroed out first. This must be a M/PM special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
F9A9: CD5FF8  	WTSPECL:CALL	AUTOSEL		;select proper drive.
F9AC: 3E02    		LD	A,2		;use special write mode.
F9AE: 32E3F9  		LD	(MODE),A
F9B1: 0E00    		LD	C,0		;set write indicator.
F9B3: CD15F7  		CALL	POSITN1		;position the file.
F9B6: CC11F6  		CALL	Z,WTSEQ1	;and write (if no errors).
F9B9: C9      		RET
              	;
              	;**************************************************************
              	;*
              	;*     BDOS data storage pool.
              	;*
              	;**************************************************************
              	;
F9BA: E5      	EMPTYFCB: DEFB	0E5H		;empty directory segment indicator.
F9BB: 0000    	WRTPRT:	DEFW	0		;write protect status for all 16 drives.
F9BD: 0000    	LOGIN:	DEFW	0		;drive active word (1 bit per drive).
F9BF: 8000    	USERDMA:DEFW	080H		;user's dma address (defaults to 80h).
              	;
              	;   Scratch areas from parameter block.
              	;
F9C1: 0000    	SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3).
F9C3: 0000    	SCRATCH2: DEFW	0		;last selected track number.
F9C5: 0000    	SCRATCH3: DEFW	0		;last selected sector number.
              	;
              	;   Disk storage areas from parameter block.
              	;
F9C7: 0000    	DIRBUF:	DEFW	0		;address of directory buffer to use.
F9C9: 0000    	DISKPB:	DEFW	0		;contains address of disk parameter block.
F9CB: 0000    	CHKVECT:DEFW	0		;address of check vector.
F9CD: 0000    	ALOCVECT: DEFW	0		;address of allocation vector (bit map).
              	;
              	;   Parameter block returned from the bios.
              	;
F9CF: 0000    	SECTORS:DEFW	0		;sectors per track from bios.
F9D1: 00      	BLKSHFT:DEFB	0		;block shift.
F9D2: 00      	BLKMASK:DEFB	0		;block mask.
F9D3: 00      	EXTMASK:DEFB	0		;extent mask.
F9D4: 0000    	DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1).
F9D6: 0000    	DIRSIZE:DEFW	0		;directory size.
F9D8: 0000    	ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used).
F9DA: 0000    	ALLOC1:	DEFW	0
F9DC: 0000    	OFFSET:	DEFW	0		;first usable track number.
F9DE: 0000    	XLATE:	DEFW	0		;sector translation table address.
              	;
              	;
F9E0: 00      	CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok).
F9E1: 00      	RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write).
F9E2: 00      	FNDSTAT:DEFB	0		;filename found status (0=found first entry).
F9E3: 00      	MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
F9E4: 00      	EPARAM:	DEFB	0		;storage for register (E) on entry to bdos.
F9E5: 00      	RELBLOCK: DEFB	0		;relative position within fcb of block number written.
F9E6: 00      	COUNTER:DEFB	0		;byte counter for directory name searches.
F9E7: 00000000	SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches).
F9EB: 00      	BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long.
F9EC: 00      	AUTO:	DEFB	0		;if non-zero, then auto select activated.
F9ED: 00      	OLDDRV:	DEFB	0		;on auto select, storage for previous drive.
F9EE: 00      	AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives.
F9EF: 00      	SAVNXT:	DEFB	0		;storage for next record number to access.
F9F0: 00      	SAVEXT:	DEFB	0		;storage for extent number of file.
F9F1: 0000    	SAVNREC:DEFW	0		;storage for number of records in file.
F9F3: 0000    	BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect
F9F5: 0000    	LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector).
F9F7: 00      	FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest.
F9F8: 0000    	FILEPOS:DEFW	0		;files position within directory (0 to max entries -1).
              	;
              	;   Disk directory buffer checksum bytes. One for each of the
              	; 16 possible drives.
              	;
F9FA: 00000000	CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F9FE: 00...   	
              	;
              	;   Extra space ?
              	;
FA0A: 00000000		DEFB	0,0,0,0
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   J U M P   T A B L E
              	;*
              	;**************************************************************
              	;
FA0E: C341FA  	BOOT:	JP	DUMMY
FA11: C341FA  	WBOOT:	JP	DUMMY
FA14: C357FA  	CONST:	JP	RZ80_CONSTAT
FA17: C342FA  	CONIN:	JP	RZ80_CONIN
FA1A: C34DFA  	CONOUT:	JP	RZ80_CONOUT
FA1D: C341FA  	LIST:	JP	DUMMY
FA20: C341FA  	PUNCH:	JP	DUMMY
FA23: C341FA  	READER:	JP	DUMMY
FA26: C341FA  	HOME:	JP	DUMMY
FA29: C36AFA  	SELDSK:	JP	RZ80_SELDSK
FA2C: C383FA  	SETTRK:	JP	RZ80_SETTRK
FA2F: C388FA  	SETSEC:	JP	RZ80_SETSEC
FA32: C364FA  	SETDMA:	JP	RZ80_SETDMA
FA35: C38DFA  	READ:	JP	RZ80_READ
FA38: C38EFA  	WRITE:	JP	RZ80_WRITE
FA3B: C341FA  	PRSTAT:	JP	DUMMY
FA3E: C341FA  	SECTRN:	JP	DUMMY
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	;****************** REICHEL RZ80 BIOS *************************
              	;
0004:         	#define DISKS 4
              	
FA41:         	DUMMY:
FA41: C9      		RET
              	
FA42:         	RZ80_CONIN:
FA42: DB01    		IN A, (1)
FA44: E601    		AND A, 1
FA46: 20FA    		JR NZ, RZ80_CONIN
FA48: DB00    		IN A, (0)
FA4A: E67F    		AND 7Fh
FA4C: C9      		RET
              	
FA4D:         	RZ80_CONOUT:
FA4D: DB01    		IN A, (1)
FA4F: E602    		AND A, 2
FA51: 20FA    		JR NZ, RZ80_CONOUT
FA53: 79      		LD A, C
FA54: D300    		OUT (0), A
FA56: C9      		RET
              	
FA57:         	RZ80_CONSTAT:
FA57: DB01    		IN A, (1)
FA59: E601    		AND A, 1
FA5B: C261FA  		JP NZ, RZ80CONSTAT_NOCHAR
FA5E: 3EFF    		LD A, 0FFh
FA60: C9      		RET
FA61:         	RZ80CONSTAT_NOCHAR:
FA61: 3E00    		LD A, 00h
FA63: C9      		RET
              	
FA64:         	RZ80_SETDMA:
FA64: 69      		LD L, C
FA65: 60      		LD H, B
FA66: 2294FA  		LD (dmaad), HL
FA69: C9      		RET
              	
FA6A:         	RZ80_SELDSK:
FA6A: 210000  		LD HL, 0
FA6D: 79      		LD A, C
FA6E: 3293FA  		LD (diskno), A
FA71: FE04    		CP DISKS
FA73: D0      		RET NC
FA74: 3A93FA  		LD A, (diskno)
FA77: 6F      		LD L, A
FA78: 2600    		LD H, 0
FA7A: 29      		ADD HL, HL
FA7B: 29      		ADD HL, HL
FA7C: 29      		ADD HL, HL
FA7D: 29      		ADD HL, HL
FA7E: 1196FA  		LD DE, dpbase
FA81: 19      		ADD HL, DE
FA82: C9      		RET
              	
FA83:         	RZ80_SETTRK:
FA83: 79      		LD A, C
FA84: 328FFA  		LD (track), A
FA87: C9      		RET
              	
FA88:         	RZ80_SETSEC:
FA88: 79      		LD A, C
FA89: 3291FA  		LD (sector), A
FA8C: C9      		RET
              	
FA8D:         	RZ80_READ:
FA8D: C9      		RET
              	
FA8E:         	RZ80_WRITE:
FA8E: C9      		RET
              	
FA8F: 0000    	track: DEFW 0
FA91: 0000    	sector: DEFW 0
FA93: 00      	diskno: DEFB 0
FA94: 0000    	dmaad: DEFW 0
              	
              	; ibm-compatible 8" disks
              	; no translations
              	;
              	; disk Parameter header for disk 00
FA96: 00000000	dpbase: 	defw  	0000h, 0000h
FA9A: 00000000		defw 	0000h, 0000h
FA9E: FFFAF0FA		defw 	dirbf, dpblk
FAA2: FBFB7FFB		defw 	chk00, all00
              	; disk parameter header for disk 01
FAA6: 00000000	          	defw 	0000h, 0000h
FAAA: 00000000		defw  	0000h, 0000h
FAAE: FFFAF0FA		defw 	dirbf, dpblk
FAB2: 0BFC9EFB		defw 	chk01, all01
              	; disk parameter header for disk 02
FAB6: 00000000	          	defw 	0000h, 0000h
FABA: 00000000		defw  	0000h, 0000h
FABE: FFFAF0FA		defw 	dirbf, dpblk
FAC2: 1BFCBDFB		defw 	chk02, all02
              	; disk parameter header for disk 03
FAC6: 00000000	          	defw 	0000h, 0000h
FACA: 00000000		defw  	0000h, 0000h
FACE: FFFAF0FA		defw 	dirbf, dpblk
FAD2: 2BFCDCFB		defw 	chk03, all03
              	;
              	; sector translate vector
FAD6: 01070D13	trans: 	defm  	1, 7, 13, 19 	;sectors 1, 2, 3, 4
FADA: 19050B11		defm 	25, 5, 11, 17 	;sectors 5, 6, 7, 6
FADE: 1703090F		defm 	23, 3, 9, 15 	;sectors 9, 10, 11, 12
FAE2: 1502080E		defm 	21, 2, 8, 14 	;sectors 13, 14, 15, 16
FAE6: 141A060C		defm 	20, 26, 6, 12  	;sectors 17, 18, 19, 20
FAEA: 1218040A		defm 	18, 24, 4, 10 	;sectors 21, 22, 23, 24
FAEE: 1016    		defm 	16, 22 	;sectors 25, 26
              	;
FAF0:         	dpblk: ;disk parameter block for all disks.
FAF0: 1A00    	          	defw  	26 	;sectors per track
FAF2: 03      		defm 	3 	;block shift factor
FAF3: 07      		defm 	7 	;block mask
FAF4: 00      		defm 	0 	;null mask
FAF5: F200    		defw 	242  	;disk size-1
FAF7: 3F00    		defw 	63 	;directory max
FAF9: C0      		defm 	192 	;alloc 0
FAFA: 00      		defm 	0 	;alloc 1
FAFB: 0000    		defw 	0 	;check size
FAFD: 0200    		defw 	2 	;track offset
              	;
              	; end of fixed tables
              	;
FAFF: FFFFFFFF	dirbf: defs 128
FB03: FF...   	
FB7F: FFFFFFFF	all00: defs 31
FB83: FF...   	
FB9E: FFFFFFFF	all01: defs 31
FBA2: FF...   	
FBBD: FFFFFFFF	all02: defs 31
FBC1: FF...   	
FBDC: FFFFFFFF	all03: defs 31
FBE0: FF...   	
FBFB: FFFFFFFF	chk00: defs 16
FBFF: FF...   	
FC0B: FFFFFFFF	chk01: defs 16
FC0F: FF...   	
FC1B: FFFFFFFF	chk02: defs 16
FC1F: FF...   	
FC2B: FFFFFFFF	chk03: defs 16
FC2F: FF...   	
              	
FC3B: 0A0D5265	WELCOME_MSG:	.ascii 0Ah,0Dh,"ReichelZ80 BIOS 0.1 (c) 2019 A.J.Reichel",0Ah,0Dh
FC3F: 69636865	
FC43: 6C5A3830	
FC47: 2042494F	
FC4B: 5320302E	
FC4F: 31202863	
FC53: 29203230	
FC57: 31392041	
FC5B: 2E4A2E52	
FC5F: 65696368	
FC63: 656C0A0D	
FC67: 43502F4D			.ascii "CP/M, Version 2.2", 0Ah, 0Dh, "$"
FC6B: 2C205665	
FC6F: 7273696F	
FC73: 6E20322E	
FC77: 320A0D24	
              	


total time: 0.0137 sec.
no errors
